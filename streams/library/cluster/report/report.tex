\documentclass[11pt,oneside]{article}
\usepackage[left=1in,right=1in,top=1in,bottom=1in]{geometry}
\usepackage[pdftex]{graphicx,color}
\usepackage{verbatim,indentfirst}
\usepackage{listings}
\usepackage{textcomp}

\usepackage{pifont}
\newcommand{\X}{\ding{54} }
\newcommand{\note}[1]{\marginpar{{\it #1}}}
%\renewcommand{\note}[1]{}

\title{Dynamic Load Balancing for Executing\\ Stream Programs on a Cluster\\ \ \\}
\author{Hasti Ahlehagh \\ Quinn Mahoney \\ Janis Sermulins\\ \ \\}
\date{\today}


\begin{document}

\maketitle

%\thispagestyle{empty}

%\vspace{50pt}

\begin{abstract}
 
This work considers dynamic load balancing for executing stream programs 
on a cluster. StreamIt is a high-level data-flow programming language and 
compiler for modern streaming systems \cite{thies}. This language is 
designed to facilitate the programming of large streaming applications; 
it outputs a set of components that can be distributed among a cluster of 
commodity computers. Load balancing is vital for improving performance. 
The current StreamIt implementation uses statically generated mappings to 
assign threads to cluster computers, but these static mappings assume 
that an equal amount of CPU resources are available on each cluster 
machine. In this study, we propose a new load balancing algorithm for 
detecting load imbalances. This allows a StreamIt program to adjust to 
varying CPU resources on cluster machines by collecting run-time 
statistics. We compare StreamIt performance with our approach to that 
of the current implementation.
 
\end{abstract} 

%\newpage

\section{Introduction}
The emergence of different streaming applications like streaming media, 
software radio, and graphic packages on a variety of embedded and 
high-performance system has fomented the need for a streaming language 
and compiler that facilitate modularity, programming productivity, and 
robustness. StreamIt is a high-level data-flow programming language and 
compiler introduced to facilitate the development of modern streaming 
applications \cite{thies}. StreamIt exploits the modular nature of the 
streaming application to distribute the computation workload to 
different processors, which results in faster execution. This 
characterisÂtic of StreamIt introduces load balancing issues, which is 
an important area for improvement. The performance of a StreamIt 
application is closely related to the distribution of the load on 
each processor.

The current StreamIt implementation uses static load balancing to assign 
threads to each cluster machine; it assumes that each machine has an 
equal amount of CPU resources available to run the application. However, 
this assumption is not always valid since the computers in a cluster may 
a have different number of processors or different clock speeds. 
Additionally, there might be other processes executing on the cluster 
machines, which decrease the resources available to the StreamIt 
application. The resources consumed by these unrelated processes may 
change dynamically. Therefore, dynamic load balancing is preferable 
because it can adapt to changing conditions as well as accommodate 
heterogeneous clusters.

In the current implementation, a Central Control Processor (CCP) runs 
on one of the cluster machines and monitors the running application. 
It periodically checks that each node is alive and reachable and uses 
this information to reconfigure the stream application if any of the 
machines fails or is disconnected from the network. We will modify the 
CCP to collect statistics about CPU utilization from each node. This 
information can be used to optimize the distribution of the components 
corresponding to the stream program. We propose an algorithm that 
computes an efficient mapping given the current CPU resources.

The key challenges in designing a good dynamic load balancing algorithm
for StreamIt are: estimating the CPU resources needed for each component
of the stream program, estimating the CPU resources available for
StreamIt on each of the cluster machines, finding a suitable mapping for
the stream program components to cluster machines and deciding when
to change the current assignement due to a change in CPU resources available.
The estimation of CPU resources for each component of the stream program
has already been implemented in the StreamIt compiler. We propose a
solution to the other key challenges.

In this paper we briefly present an overview of the dynamic load balancing 
problem and description of the StreamIt compiler as a distributed 
system. Next, we discuss the design of the dynamic load balancing algorithm 
and potential improvements, and finally we evaluate and compare our 
proposed algorithm with the current implementation of StreamIt.

\subsection*{Related Work}
 
Load balancing algorithms have been studied both in terms of CPU usage 
in parallel processing and route selection algorithm in communication 
networks. For our study, we assume the bandwidth between two nodes is 
abundant and that memory usage is not a concern. We only consider CPU 
utilization for load balancing. Static and dynamic load balancing have 
been studied in \cite{ghosh,hamdi,nandy}. \cite{ghosh} studies load 
balancing in the context of graph theory and solves the problem of 
Incremental Weight Migration on an arbitrary graph. \cite{nandy} proposes 
and compares different load balancing techniques for parallel discrete 
event driven simulation. \cite{hamdi} introduces a load balancing scheme 
that aims at dynamically balancing the workload of data parallel 
applications. They use a central manager to partition a given image 
into a set of several smaller sub-images, distribute them to all 
components involved, and collect the results. Our load balancing 
technique is also centralized and specific to the StreamIt implementation.

\newpage 

\section{Current StreamIt Implementation}

In this section we present how StreamIt programs can be compiled
to and executed on a cluster. We present the existing partitioner
and reasons why we need to modify the partitioner. We also explain
how by using the Central Control Process it is possible to restart a 
StreamIt program on a cluster from a recent checkpoint. We will 
need this property in order to restart a StreamIt program after
reconfiguration.

\subsection*{Existing Partitioner}

The current StreamIt implementation estimates how much computational 
resources each stream program component will require. It then applies 
a sequence of $N-1$ vertical and horizontal cuts to the graph of the 
stream program to produce $N$ partitions such that the estimated work 
within all partitions is as uniform as possible. The algorithm starts
with a single partition that contains the whole graph. Each cut is applied
to only one of the existing partitions and therefore increases the number
of partitions by exactly one. In some cases, the algorithm must insert 
components whose outputs are equal to their inputs in order to enforce 
certain properties of the stream graph. Better load balancing may be 
achieved if the algorithm is not restricted only to horizontal or 
vertical cuts as shown in Figure~\ref{part1} and Figure~\ref{part2}.


\begin{figure}[h] %  figure placement: here, top, bottom, or page
\begin{center}
\begin{minipage}{.4\textwidth}
\begin{center}
   \includegraphics*[width=180pt]{partition1.png} 
   \caption{Partitions considered by the existiong partitioner}
   \label{part1}
\end{center}
\end{minipage}
\begin{minipage}{.1\textwidth}
\end{minipage}
\begin{minipage}{.4\textwidth}
\begin{center}
   \includegraphics*[width=120pt]{partition2.png} 
   \caption{Partitions not considered by the existiong partitioner}
   \label{part2}
\end{center}
\end{minipage}
\end{center}
\end{figure}


\subsection*{Executing Stream Programs on a Cluster}

When executing StreamIt application on a cluster each stream program
component is executed as a separate thread. The StreamIt compiler
generates the code for each thread using C language.
The existing static partitioner maps the threads to a given number
of cluster machines. The mapping is stored in a cluster configuration 
file. Note that multiple threads can be mapped to a single machine.

Initially, a process is started on each of the cluster machines. These 
processes read the cluster configuration file and create the necessary 
TCP connections between corresponding process running on the other 
cluster machines. Once the connections have been established, the 
computation threads are started. The computation continues for a 
specified number of iterations. This does not provide support for any 
dynamic reconfiguration or failure recovery.

\subsection*{Restarting a Stream Program from a Checkpoint}

The CCP process is started on one of the cluster machines. We make an 
assumption that this machine will not crash. In theory we could deal 
even with the CCP crashing. However, a failure of the CCP would require 
an intervention by a person who would have to start a new CCP process 
and start new computation processes on all of the cluster machines; the 
computation could proceed from a recent checkpoint. 

On each of the cluster nodes a NodeServer thread connects to the CCP 
machine and informs it that a node is available for stream processing. 
The CCP then gives instructions to the NodeServer and periodically 
checks that the node is alive.

Each time that a new computation node connects to the CCP or an existing 
node becomes unavailable the assignment of threads to nodes has to be 
changed.

\begin{list}{}
\item 1. The CCP sends a STOP\_ALL\_THREADS message to all connected nodes.
\item 2. The CCP reads a mapping for the threads to a given number of nodes from a file (a set of files has to be pre-generated statically).
\item 3. The CCP sends out CLUSTER\_CONFIG message that contains mapping of threads to the node IP addresses. At this point all nodes perform same logic as if a new stream program is to be executed unreliably; they create TCP connections and start computation (the only difference is that they may have to read state variables of the threads from a recent checkpoint Ð this information is present in CLUSTER\_CONFIG message).
\end{list}
\ \\

In order to support the restart of a stream computation, each computation 
thread periodically saves its state variables to disk, each time creating 
a new file called a checkpoint. The checkpoints are created such that
if we restore all threads using a set of matching checkpoints then all
communication channels are empty; therefore we do not need to checkpoint
data in the communication channels.

One thread of the CCP process deletes checkpoints that are no longer 
needed. For example, once all computation threads have created a 
checkpoint for the iteration 200, we no longer need checkpoints for 
earlier iterations (ex. 100) and can delete them (If we need to recover, 
we can use iteration 200 instead of any earlier iteration). 

\newpage 

\section{Design Overview}

Our implementation of the dynamic load balancing algorithm gathers 
statistics from the cluster machines such as the percentage of the CPU 
utilized by the StreamIt process and the percentage of the CPU cycles 
that are idle. The CCP gathers this data periodically
and computes a new mapping of threads to machines that represents
the CPU resources available at each cluster machine. If the new mapping
is sufficiently different from the current mapping then the CCP initiates
a reconfiguration where the stream program is halted and restarted
from a most recent checkpoint. The restart allows us to adjust
the mapping of threads to machines.

Initially we assume that all cluster machines have equal CPU 
resources. However, as we gather profiling data we can adjust the
mapping to improve the load balance. The result is that the program 
is able to reconfigure itself for optimization and react to changing 
conditions, such as other programs running on the same cluster.

\subsection*{Data Collection}

Our dynamic load balancing algorithm requires that certain data be 
collected. We divide this data into two categories, dynamic and static. 
The dynamic data is measured at run-time by each computer and sent to 
the CCP. This data includes the CPU usage of the StreamIt program on 
every node, and the amount of idle CPU cycles on each node as the 
program runs. The static data is produced at compile-time by the 
StreamIt compiler. This information includes the estimate of the CPU 
resources required by each thread relative to other threads. 
This estimate, when combined with actual CPU usage, 
allows us to estimate relative speeds of different cluster machines.

Suppose that a cluster machine $i$ has threads whose work
estimates sum up to $work_i$, average CPU utilization by the
StreamIt threads is $util_i$ and CPU has $idle_i$ idle cycyles
($util_i$ and $idle_i$ are represented as integers from 0 to 100).
We calculate the $R_i$ relative amount of CPU resources available on the
machine $i$ by using the following formula:

$R_i = \displaystyle\frac{work_i}{util_i} * (util_i + idle_i)$

\subsection*{New Partitioner}

The existing partitioner calculates the best $N-1$ horizontal and vertical
cuts, such that the load balance among the $N$ partitions is as equal as
possible. The algorithm uses dynamic programing and is implenented in 
Java. The existing partitioner is invoked during the compilation of the 
StreamIt program to C. It is therefore inappropriate for execution 
during runtime.

We have developed an alternative partitioner, which does not use
dynamic programing, but is not restricted to making only horizontal
and vertical cuts. Because the algorithm is greedy its
execution time is negligible even for large graphs.

The algorithm begins at the top of the stream program and adds threads to 
a partition using a breadth-first search. It only adds a thread to the 
current partition if all the threads that supply input to it have already 
been added to the current or a previous partition. Otherwise, the algorithm 
is greedy; it adds a thread if it can be added without the current 
partition's work estimate becoming larger than a certain threshold. 
When no thread can be added to satisfy the condition, it starts a 
new partition from the remaining eligible threads. A thread is considered 
eligible if all the threads that supply input to it have been added to 
some previous partition.

For a homogenous cluster, the threshold for all partitions is the 
sum of all the work estimates divided by the number of partitions. 
Once we have gathered statistics from the cluster machines the 
thresholds are proportional to $R_i$ values for the machines.

\subsection*{Dynamic Load Balancing Algorithm}

When we start executing a StreamIt program on a cluster consisting
on $N$ machines the initial mapping of threads to machines
is constructed using our new partitioner, but assuming that 
all machines have equal CPU resources.

The CCP collects current statistics from the cluster machines
every 1 to 2 seconds. It calculates the average values for each
statistic (the CPU utilization by StreamIt and the idle CPU cycles)
over a time period of 20 seconds. Every 30 seconds the CCP computes
a new mapping of threads to machines using the new partitioner
and $R_i$ values that have been computed using the average 
values of CPU statistics.

If the sum of the work estimates of the threads that are located on a
different machine in the new mapping is more than 5 percent, the
CCP initiates a reconfiguration. During a reconfiguration the CCP sends 
a STOP\_ALL\_THREADS message to all of the machines and then sends out a 
new mapping of threads to machines. The threads examine the most recent
checkpoint and load their state variables. The CCP makes sure that
all threads examine the same checkpoint by including a unique
checkpoint identification number along with the mapping that it
sends to all machines.

\begin{figure}[htp]
\begin{center}
\framebox[.8 \textwidth]{
\vbox{
\begin{flushleft}
\begin{tabbing}
xxxx \= xxxx \= xxxx \= xxxx \= \kill
1. Receive Load Info from Machines\\
2. Find New Mapping of Threads to Machines\\
3. If ( More Than 5 Percent Differece )\\
\> Send STOP\_ALL\_THREADS to Machines\\
\> Send New Mapping to Machines\\
\> Ask Machines to Resume Computation from a Checkpoint\\
4. Goto Step 2
\end{tabbing}
\end{flushleft}
}
}
\end{center}
\caption{StreamIt dynamic load balancing algorithm}\label{load-balance}
\end{figure}

\begin{figure}[h] %  figure placement: here, top, bottom, or page
   \begin{center}
   \includegraphics*[width=\textwidth]{mpeg-1ghz-3ghz.png} 
   \caption{Inserted Graphics Example}
   \label{mpeg-1ghz-3ghz}
   \end{center}
\end{figure}




%\begin{figure}[htp]
%\begin{center}
%\framebox[.75 \textwidth]{
%\vbox{
%\begin{flushleft}
%\begin{tabbing}
%xxxx \= xxxx \= xxxx \= xxxx \= \kill
%1. Read-config-file ( )\\
%2. Send-alive-command-to-nodes ( )\\
%3. Receive-load-info-from-nodes ( )\\
%4. Find-relative-distribution-of-load ( )\\
%5. If require-redistribution == TRUE\\
%\> Send-stop-thread-to-nodes ( )\\
%\> \> Send-new-mapping-to-nodes ( )\\
%\> \> Send-resume-computation-from-checkpoint-to-nodes ( )\\
%\> \> \> If success\\
%\> \> \> \> Return ( ) \\
%\> \> \> Else\\
%\> \> \> \> Halt-the-system-or-continue ( )\\
%6. Else \\
%\> Goto step 2
%\end{tabbing}
%\end{flushleft}
%}
%}
%\end{center}
%\caption{StreamIt dynamic load balancing algorithm}\label{load-balance}
%\end{figure}

\newpage

\nocite{*}
\bibliography{report}
\bibliographystyle{plain}

\end{document}