package at.dms.kjc.spacetime;

import java.util.Vector;
import at.dms.kjc.flatgraph.FlatNode;
import at.dms.kjc.flatgraph.FlatVisitor;
import at.dms.kjc.*;
import at.dms.kjc.sir.*;
import at.dms.kjc.iterator.*;
import at.dms.util.Utils;
import java.util.List;
import java.util.ListIterator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.HashMap;
import java.io.*;
import at.dms.compiler.*;
import at.dms.kjc.sir.lowering.*;
import java.util.Hashtable;
import java.math.BigInteger;
import at.dms.kjc.flatgraph2.FilterContent;

/**
 * This class implements filter communication with a peek buffer.  The peek buffer can 
 * either be circular with and'ing or linear with reseting of indices.  
 * 
 * This class follows the RawExecutionCode model and defines classes for 
 * calculating and retrieving the init, prime pump, and steady-state methods
 * for the given filter of the slice that this object is used for. 
 * 
 * {@link at.dms.kjc.spacetime.ComputeCodeStore} uses this when it is 
 * constructing each tile's compute code.
 * 
 * @author mgordon
 *
 */
public class BufferedCommunication extends RawExecutionCode
    implements Constants
{
   
    
    /**
     * The number of times this filter fires in the init stage.
     *  
     * In this class we want to treat all the filters as 
     * two stage, so if it is not two stage by type,
     * add one to the init multiplicity of the filter 
     */
    private int initFire;

    /**
     * Create a new Buffered communication object that will be used to 
     * generate code for the FilterTraceNode described by filterInfo.
     * 
     * @param tile The tile assigned to filterInfo
     * @param filterInfo The filter we this is going to generate code for.
     * @param layout The layout of the entire application.
     */
    public BufferedCommunication(RawTile tile, FilterInfo filterInfo, Layout layout) 
    {
        super(tile, filterInfo, layout);
        FilterTraceNode node=filterInfo.traceNode;
        System.out.println(tile + "Generating code for " + filterInfo.filter + " using Buffered Comm.");
    
        //set the unique id to append to each variable name
        //treat all the filters as two stages, i.e.
        //initWork is always called, so add one to non-2 stages
        //init multiplicity
        initFire = filterInfo.initMult;
        if (!filterInfo.isTwoStage()) {
            initFire++;
        }   
    }


    /**
     * Convert the peek and pop expressions for a filter into
     * buffer accesses, do this for all functions just in case helper
     * functions call peek or pop.
     */
    private void convertCommExprs() 
    {
        SLIRReplacingVisitor convert;
    
        ConvertPushesToMethCall.doit(filterInfo, gdnOutput);
        
        if (filterInfo.isSimple()) {
            convert = 
                new ConvertCommunicationSimple(generatedVariables, filterInfo);
        }
        else
            convert = new ConvertCommunication(generatedVariables, filterInfo);
    
        JMethodDeclaration[] methods = filterInfo.filter.getMethods();

        if(methods!=null)
            for (int i = 0; i < methods.length; i++) {
                //iterate over the statements and call the ConvertCommunication
                //class to convert peek, pop
                for (ListIterator it = methods[i].getStatementIterator();
                     it.hasNext(); ){
                    ((JStatement)it.next()).accept(convert);
                }
            }
    }

    /**
     * Return an array of JFieldDecl's that need to be added to the 
     * fields of this tile becuase they are generated by this pass.
     * 
     * @return fields that are created by this pass and used in its
     * generated code.
     */
    public JFieldDeclaration[] getVarDecls() 
    {
        Vector decls = new Vector();
        FilterContent filter = filterInfo.filter;

        JFieldDeclaration[] fields=filter.getFields();
    
        if(fields!=null)
            for (int i = 0; i < fields.length; i++) 
                decls.add(fields[i]);
    
        //index variable for certain for loops
        JVariableDefinition exeIndexVar = 
            new JVariableDefinition(null, 
                                    0, 
                                    CStdType.Integer,
                                    exeIndex + uniqueID,
                                    null);

        //remember the JVarDef for latter (in the raw main function)
        generatedVariables.exeIndex = exeIndexVar;
        decls.add(new JFieldDeclaration(null, exeIndexVar, null, null));
    
        //index variable for certain for loops
        JVariableDefinition exeIndex1Var = 
            new JVariableDefinition(null, 
                                    0, 
                                    CStdType.Integer,
                                    exeIndex1 + uniqueID,
                                    null);

        generatedVariables.exeIndex1 = exeIndex1Var;
        decls.add(new JFieldDeclaration(null, exeIndex1Var, null, null));
    
        //only add the receive buffer and its vars if the 
        //filter receives data
        if (!filterInfo.noBuffer()) {
            //initialize the buffersize to be the size of the 
            //struct being passed over it
            int buffersize;
        
            int maxpeek = filterInfo.peek;
            //set up the maxpeek
            maxpeek = (filterInfo.prePeek > maxpeek) ? filterInfo.prePeek : maxpeek;
        
        
            System.out.println(filterInfo.filter.getName() + " remaining: " + filterInfo.remaining);
            if (filterInfo.isSimple()) {
                //simple filter (no remaining items)
                if (KjcOptions.ratematch) {
                    //i don't know, the prepeek could be really large, so just in case
                    //include it.  Make the buffer big enough to hold 
                    buffersize = 
                        Math.max
                        ((filterInfo.steadyMult - 1) * 
                         filterInfo.pop + filterInfo.peek, filterInfo.prePeek);
                }
                else //not ratematching and we do not have a circular buffer
                    buffersize = maxpeek;  //this really should be max pop, but peek  == pop
                //in this case 

                //define the simple index variable
                JVariableDefinition simpleIndexVar = 
                    new JVariableDefinition(null, 
                                            0, 
                                            CStdType.Integer,
                                            simpleIndex + filterInfo.filter.getName(),
                                            new JIntLiteral(-1));
        
                //remember the JVarDef for latter (in the raw main function)
                generatedVariables.simpleIndex = simpleIndexVar;
                decls.add(new JFieldDeclaration(null, simpleIndexVar, null, null));
            }
            else { //filter with remaing items on the buffer after initialization 
                buffersize = Util.nextPow2(maxpeek + filterInfo.remaining);
            }

        
            //compute how many times this filter fires
            //find the stage with the max number of executions and add the primepump
            //int maxExe = Math.max(filterInfo.initMult, filterInfo.steadyMult) +       
            //  filterInfo.primePump;
        
            //buffersize *= maxExe;
            /*
        
            FilterTraceNode[] previousFilters = filterInfo.getPreviousFilters();
            if (previousFilters.length == 1) {
            FilterInfo prevInfo = FilterInfo.getFilterInfo(previousFilters[0]);
        
            //find the stage with the max number of executions
            int maxExe = Math.max(Math.max(prevInfo.initMult, prevInfo.steadyMult),
            prevInfo.primePump);
            //now mult the previous buffersize calc by the stage with the 
            //greatest number of executions...
            buffersize *= maxExe;
            }
            else {
            //splitjoin
            Utils.fail("Split/joins not supported");
            }
            */

            JVariableDefinition recvBufVar = 
                new JVariableDefinition(null, 
                                        at.dms.kjc.Constants.ACC_FINAL, //?????????
                                        new CArrayType(filter.getInputType(), 
                                                       1 /* dimension */ ,
                                                       bufferDims(filter, filter.getInputType(), buffersize)),
                                        recvBuffer + filterInfo.filter.getName(),
                                        null);
        
        
            //the size of the buffer 
            JVariableDefinition recvBufferSizeVar = 
                new JVariableDefinition(null, 
                                        at.dms.kjc.Constants.ACC_FINAL, //?????????
                                        CStdType.Integer,
                                        recvBufferSize + filterInfo.filter.getName(),
                                        new JIntLiteral(buffersize));
        
            //the size of the buffer 
            JVariableDefinition recvBufferBitsVar = 
                new JVariableDefinition(null, 
                                        at.dms.kjc.Constants.ACC_FINAL, //?????????
                                        CStdType.Integer,
                                        recvBufferBits + filterInfo.filter.getName(),
                                        new JIntLiteral(buffersize - 1));
        
            //the receive buffer index (start of the buffer)
            JVariableDefinition recvBufferIndexVar = 
                new JVariableDefinition(null, 
                                        0, 
                                        CStdType.Integer,
                                        recvBufferIndex + filterInfo.filter.getName(),
                                        new JIntLiteral(-1));
        
            //the index to the end of the receive buffer)
            JVariableDefinition recvIndexVar = 
                new JVariableDefinition(null, 
                                        0, 
                                        CStdType.Integer,
                                        recvIndex + filterInfo.filter.getName(),
                                        new JIntLiteral(-1));

            generatedVariables.recvBuffer = recvBufVar;
            decls.add(new JFieldDeclaration(null, recvBufVar, null, null));
            generatedVariables.recvBufferSize = recvBufferSizeVar;
            decls.add(new JFieldDeclaration(null, recvBufferSizeVar, null, null));
            generatedVariables.recvBufferBits = recvBufferBitsVar;
            decls.add(new JFieldDeclaration(null, recvBufferBitsVar, null, null));
            generatedVariables.recvBufferIndex = recvBufferIndexVar;
            decls.add(new JFieldDeclaration(null, recvBufferIndexVar, null, null));
            generatedVariables.recvIndex = recvIndexVar;
            decls.add(new JFieldDeclaration(null, recvIndexVar, null, null));

        }
    
        //if we are rate matching, create the output buffer with its 
        //index
        if (KjcOptions.ratematch && filter.getPushInt() > 0) {
            //define the send buffer index variable
            JVariableDefinition sendBufferIndexVar = 
                new JVariableDefinition(null, 
                                        0, 
                                        CStdType.Integer,
                                        sendBufferIndex + uniqueID,
                                        new JIntLiteral(-1));
        
            generatedVariables.sendBufferIndex = sendBufferIndexVar;
            decls.add(new JFieldDeclaration(null, sendBufferIndexVar, null, null));
         
            //define the send buffer
        
            JExpression[] dims = new JExpression[1];
            //the size of the output array is number of executions in steady *
            // number of items pushed * size of item
            dims[0] = new JIntLiteral(filterInfo.steadyMult * filterInfo.push * 
                                      Util.getTypeSize(filter.getOutputType()));

            JVariableDefinition sendBufVar = 
                new JVariableDefinition(null, 
                                        at.dms.kjc.Constants.ACC_FINAL, //?????????
                                        new CArrayType(filter.getOutputType(), 
                                                       1 /* dimension */ ,
                                                       dims),
                                        sendBuffer + uniqueID, 
                                        null);

            generatedVariables.sendBuffer = sendBufVar;
            decls.add(new JFieldDeclaration(null, sendBufVar, null, null));
        }
    
    
        //print the declarations for the array indices for pushing and popping
        //if this filter deals with arrays
        if (filter.getInputType().isArrayType() || 
            filter.getOutputType().isArrayType()) {
            int inputDim = 0, outputDim = 0, maxDim;
            //find which array has the greatest dimensionality     
            if (filter.getInputType().isArrayType())
                inputDim = 
                    ((CArrayType)filter.getInputType()).getArrayBound();
            if (filter.getOutputType().isArrayType()) 
                outputDim = 
                    ((CArrayType)filter.getOutputType()).getArrayBound();
            maxDim = (inputDim > outputDim) ? inputDim : outputDim;
        
            generatedVariables.ARRAY_INDEX = new JVariableDefinition[maxDim];
        
            //create enough index vars as max dim
            for (int i = 0; i < maxDim; i++) {
                JVariableDefinition arrayIndexVar = 
                    new JVariableDefinition(null, 
                                            0, 
                                            CStdType.Integer,
                                            ARRAY_INDEX + i + uniqueID,
                                            null);
                //remember the array index vars
                generatedVariables.ARRAY_INDEX[i] = arrayIndexVar;
                decls.add(new JFieldDeclaration(null, arrayIndexVar, null, null));
            }
        }
    
        //convert the pops/peeks into buffer access 
        convertCommExprs();

        return (JFieldDeclaration[])decls.toArray(new JFieldDeclaration[0]);
    }

    /**
     * Return an array of methods for any helper methods that we create
     * or that were present in this filter.  They need to be added to the
     * methods of the entire tile.
     * 
     * @return helper methods that need to be placed in the tile's code.
     */
    public JMethodDeclaration[] getHelperMethods() 
    {
        Vector methods = new Vector();

        //add all helper methods, except work function and initWork
        /*
          for (int i = 0; i < filterInfo.filter.getMethods().length; i++) 
          if (!(filterInfo.filter.getMethods()[i].equals(filterInfo.filter.getWork()) ||
          (filterInfo.isTwoStage() && 
          filterInfo.filter.getInitWork().
          equals(filterInfo.filter.getMethods()[i]))))
          methods.add(filterInfo.filter.getMethods()[i]);
        */
    
        //add all methods
        for (int i = 0; i < filterInfo.filter.getMethods().length; i++) 
            methods.add(filterInfo.filter.getMethods()[i]);
        return (JMethodDeclaration[])methods.toArray(new JMethodDeclaration[0]);
    }

    /**
     * Calculate and return the method that will implement one execution
     * of this filter in the primepump stage.  This method may be called multiple
     * times depending on the number of stages in the primepump stage itself.   
     * 
     * @return The method that implements one stage of the primepump exeuction of this
     * filter. 
     */
    public JMethodDeclaration getPrimePumpMethod() 
    {
        if (primePumpMethod != null)
            return primePumpMethod;
        
        JBlock statements = new JBlock(null, new JStatement[0], null);
        FilterContent filter = filterInfo.filter;

      
        //add the calls to the work function for the priming of the pipeline
        statements.addStatement(getWorkFunctionBlock(false, filterInfo.steadyMult));
        //return the method
        primePumpMethod = new JMethodDeclaration(null, at.dms.kjc.Constants.ACC_PUBLIC,
                                      CStdType.Void,
                                      primePumpStage + uniqueID,
                                      JFormalParameter.EMPTY,
                                      CClassType.EMPTY,
                                      statements,
                                      null,
                                      null);
        return primePumpMethod;
    }
    

    /**
     * Calculate and return the method that implements the init stage 
     * computation for this filter.  It should be called only once in the 
     * generated code.
     * <p>
     * This does not include the call to the init function of the filter.
     * That is done in {@link ComputeCodeStore#addInitFunctionCall}. 
     * 
     * @return The method that implements the init stage for this filter.
     */
    public JMethodDeclaration getInitStageMethod() 
    {
        JBlock statements = new JBlock(null, new JStatement[0], null);
        FilterContent filter = filterInfo.filter;

        //if we have gdn output then we have to set up the gdn packet header for
        //each gdn send
        if (gdnOutput) {
            statements.addStatement(setupGDNStore(true, false));
        }

        //add the call to initWork
        if (filterInfo.isTwoStage()) {
            //FilterContent two = filter;
            /*
              JBlock body = 
              (JBlock)ObjectDeepCloner.deepCopy
              (filter.getInitWork().getBody());
            */
            JMethodCallExpression initWorkCall = 
                new JMethodCallExpression(null, new JThisExpression(null),
                                          filter.getInitWork().getName(),
                                          new JExpression[0]);
        
            //add the code to receive the items into the buffer from the network
            statements.addStatement
                (makeForLoop(receiveCode(filter, filter.getInputType(), 
                                         generatedVariables),
                             generatedVariables.exeIndex,
                             new JIntLiteral(filterInfo.prePeek)));

            //now inline the init work body
            statements.addStatement(new JExpressionStatement(null, initWorkCall, null));
            //if a simple filter, reset the simpleIndex
            if (filterInfo.isSimple()) {
                statements.addStatement
                    (new JExpressionStatement(null,
                                              (new JAssignmentExpression
                                               (null,
                                                new JFieldAccessExpression
                                                (null, new JThisExpression(null), 
                                                 generatedVariables.simpleIndex.getIdent()),
                                                new JIntLiteral(-1))), null));
            }
        }
    
        if (initFire - 1 > 0) {
            //add the code to collect enough data necessary to fire the 
            //work function for the first time
        
            if (filterInfo.bottomPeek > 0) {
                statements.addStatement
                    (makeForLoop(receiveCode(filter, filter.getInputType(),
                                             generatedVariables),
                                 generatedVariables.exeIndex,
                                 new JIntLiteral(filterInfo.bottomPeek)));
            }
        
            //add the calls for the work function in the initialization stage
            statements.addStatement(generateInitWorkLoop
                                    (filter, generatedVariables));
        }

        //add the code to collect all data produced by the upstream filter 
        //but not consumed by this filter in the initialization stage
        if (filterInfo.remaining > 0) {
            statements.addStatement
                (makeForLoop(receiveCode(filter, filter.getInputType(),
                                         generatedVariables),
                             generatedVariables.exeIndex,
                             new JIntLiteral(filterInfo.remaining))); 
        }

        if (SpaceTimeBackend.FILTER_DEBUG_MODE) {
            statements.addStatement
                (new SIRPrintStatement(null,
                                       new JStringLiteral(null, filter.getName() + " Starting Steady-State"),
                                       null));
        }
        
        //add the necessary handling of dram cache alignment over the gdn
        statements.addStatement(gdnCacheAlign(true));
    
        return new JMethodDeclaration(null, at.dms.kjc.Constants.ACC_PUBLIC,
                                      CStdType.Void,
                                      initStage + uniqueID,
                                      JFormalParameter.EMPTY,
                                      CClassType.EMPTY,
                                      statements,
                                      null,
                                      null); 
    }
    
    
    /** 
     * Return the block that implements this filter in the steady state.
     * It may be a functino call to the work function or the inlined work
     * function itself.
     * 
     * @see RawExecutionCode#INLINE_WORK
     * 
     * @return The steady-state code for one complete steady-state firing of the
     * filter.
     */
    public JBlock getSteadyBlock() 
    {
        return getWorkFunctionBlock(true, filterInfo.steadyMult);
    }
    

    /**
     * Generate code to receive data and call the work function mult times.
     * 
     * @param steady if true, then steady state, if false, then primepump
     * @param mult the work function will be called this many times.
     * 
     * @return code to receive data and call the work function mult times.
     **/
    private JBlock getWorkFunctionBlock(boolean steady, int mult)
    {
        JBlock block = new JBlock(null, new JStatement[0], null);
        FilterContent filter = filterInfo.filter;
                      
        JStatement workBlock = 
            getWorkFunctionCall(filter);
    
        //if we are compressing the switch code, then send the rates to the switch
        sendRatesToSwitch(filterInfo, block);
                
        //reset the simple index
        if (filterInfo.isSimple()) {
            block.addStatement
                (new JExpressionStatement(null,
                                          (new JAssignmentExpression
                                           (null,
                                            new JFieldAccessExpression
                                            (null, new JThisExpression(null),
                                             generatedVariables.simpleIndex.getIdent()),
                                            new JIntLiteral(-1))), null));
        }
    
        //add the statements to receive pop into the buffer
        //execute this before the for loop that has the work function
        block.addStatement
            (makeForLoop(receiveCode(filter, filter.getInputType(),
                                     generatedVariables),
                         generatedVariables.exeIndex,
                         new JIntLiteral(filterInfo.pop)));

        //if we are in debug mode, print out that the filter is firing
        if (SpaceTimeBackend.FILTER_DEBUG_MODE) {
            block.addStatement
                (new SIRPrintStatement(null,
                                       new JStringLiteral(null, filter.getName() + " firing."),
                                       null));
        }

        //add the cloned work function to the block
        block.addStatement(workBlock);
    
        //if we are in decoupled mode do not put the work function in a for loop
        //and add the print statements
        if (KjcOptions.decoupled) {
            block.addStatementFirst
                (new SIRPrintStatement(null, 
                                       new JIntLiteral(0),
                                       null));
            block.addStatement(block.size(), 
                               new SIRPrintStatement(null, 
                                                     new JIntLiteral(1),
                                                     null));
        }
        else {
            //create the for loop that will execute the work function
            //local variable for the work loop
            JVariableDefinition loopCounter = new JVariableDefinition(null,
                                                                      0,
                                                                      CStdType.Integer,
                                                                      workCounter,
                                                                      null);
         
            JStatement loop = makeForLoop(block, loopCounter, new JIntLiteral(mult));
            block = new JBlock(null, new JStatement[0], null);
            block.addStatement(new JVariableDeclarationStatement(null,
                                                                 loopCounter,
                                                                 null));
            block.addStatement(loop);
        }
        
        //if we have gdn output then we have to set up the gdn packet header for
        //each gdn send
        if (gdnOutput) {
            block.addStatementFirst(setupGDNStore(false, !steady));
        }
        
        //now we must make sure that 
        block.addStatement(gdnCacheAlign(false));
        
        return block;
    }


    /**
     * Return the code that will call the work work function once.
     * It will either be the entire function inlined or a function call.
     * 
     * @see RawExecutionCode#INLINE_WORK
     * 
     * @param filter The filter content for this filter.
     * 
     * @return The code to execute the work function once.
     */
    protected JStatement getWorkFunctionCall(FilterContent filter) 
    {
        if (INLINE_WORK)
            return (JBlock)ObjectDeepCloner.deepCopy(filter.getWork().getBody());
        else 
            return new JExpressionStatement(null, 
                                            new JMethodCallExpression(null,
                                                                      new JThisExpression(null),
                                                                      filter.getWork().getName(),
                                                                      new JExpression[0]),
                                            null);
    }
    

    /**
     * Generate the loop for the work function firings in the 
     * initialization schedule.  This does not include receiving the
     * necessary items for the first firing.  This is handled in  
     * {@link BufferedCommunication#getInitStageMethod}.
     * This block will generate code to receive items for all subsequent 
     * calls of the work function in the init stage plus the class themselves. 
     *
     * @param filter
     * @param generatedVariables
     * @return
     */
    JStatement generateInitWorkLoop(FilterContent filter, 
                                    GeneratedVariables generatedVariables) 
    {
        JBlock block = new JBlock(null, new JStatement[0], null);
    
        //if a simple filter, reset the simpleIndex
        if (filterInfo.isSimple()) {
            block.addStatement
                (new JExpressionStatement(null,
                                          (new JAssignmentExpression
                                           (null,
                                            new JFieldAccessExpression
                                            (null, new JThisExpression(null), 
                                             generatedVariables.simpleIndex.getIdent()),
                                            new JIntLiteral(-1))), null));
        }
    
        JStatement innerReceiveLoop = 
            makeForLoop(receiveCode(filter, filter.getInputType(),
                                    generatedVariables),
                        generatedVariables.exeIndex,
                        new JIntLiteral(filter.getPopInt()));
    
        JExpression isFirst = 
            new JEqualityExpression(null,
                                    false,
                                    new JFieldAccessExpression
                                    (null, new JThisExpression(null),
                                     generatedVariables.exeIndex1.getIdent()),
                                    new JIntLiteral(0));
        JStatement ifStatement = 
            new JIfStatement(null,
                             isFirst,
                             innerReceiveLoop,
                             null, 
                             null);
    
        //add the if statement
        block.addStatement(ifStatement);
    
        //clone the work function and inline it
        JStatement workBlock = 
            getWorkFunctionCall(filter);
    
        //if we are in debug mode, print out that the filter is firing
        if (SpaceTimeBackend.FILTER_DEBUG_MODE) {
            block.addStatement
                (new SIRPrintStatement(null,
                                       new JStringLiteral(null, filter.getName() + " firing (init)."),
                                       null));
        }
    
        block.addStatement(workBlock);
    
        //return the for loop that executes the block init - 1
        //times
        return makeForLoop(block, generatedVariables.exeIndex1, 
                           new JIntLiteral(initFire - 1));
    }

    /**
     * Not used!
     * 
     * @param filter
     * @return Got me?
     */
    JBlock generateRateMatchSteadyState(FilterContent filter)
                
    {
        Utils.fail("This is not supported");
    
        JBlock block = new JBlock(null, new JStatement[0], null);

        //reset the simple index
        if (filterInfo.isSimple()){
            block.addStatement
                (new JExpressionStatement(null,
                                          (new JAssignmentExpression
                                           (null,
                                            new JLocalVariableExpression
                                            (null, generatedVariables.simpleIndex),
                                            new JIntLiteral(-1))), null));
        }
        
    
        //should be at least peek - pop items in the buffer, so
        //just receive pop * filterInfo.steadyMult in the buffer and we can
        //run for an entire filterInfo.steadyMult state
        block.addStatement
            (makeForLoop(receiveCode(filter, filter.getInputType(),
                                     generatedVariables),
                         generatedVariables.exeIndex,
                         new JIntLiteral(filterInfo.pop * filterInfo.steadyMult)));

    
        //now, run the work function steady times...
        JBlock workBlock = 
            (JBlock)ObjectDeepCloner.
            deepCopy(filter.getWork().getBody());

        //convert all of the push expressions in the steady state work block into
        //stores to the output buffer
        workBlock.accept(new SLIRReplacingVisitor() {
                /**
                 * Visits a push expression.
                 */
                public Object visitPushExpression(SIRPushExpression self,
                                                  CType tapeType,
                                                  JExpression arg) {
                    JExpression newExp = (JExpression)arg.accept(this);
                    //the expression is the argument of the call
                    JExpression[] args = new JExpression[1];
                    args[0] = newExp;
            
                    JMethodCallExpression ratematchsend = 
                        new JMethodCallExpression(null, new JThisExpression(null),
                                                  rateMatchSendMethod,
                                                  args);
                    //set the type of the method call
                    ratematchsend.setTapeType(tapeType);
                    return ratematchsend;
                }
            });
    

        //if we are in debug mode, print out that the filter is firing
        if (SpaceTimeBackend.FILTER_DEBUG_MODE) {
            block.addStatement
                (new SIRPrintStatement(null,
                                       new JStringLiteral(null, filter.getName() + " firing."),
                                       null));
        }

        //add the cloned work function to the block
        block.addStatement
            (makeForLoop(workBlock, generatedVariables.exeIndex,
                         new JIntLiteral(filterInfo.steadyMult)));
    
        //now add the code to push the output buffer onto the static network and 
        //reset the output buffer index
        //    for (steady*push*typesize)
        //        push(__SENDBUFFER__[++ __SENDBUFFERINDEX__])
        if (filterInfo.push > 0) {
        
            SIRPushExpression pushExp =  new SIRPushExpression
                (new JArrayAccessExpression
                 (null, 
                  new JLocalVariableExpression
                  (null,
                   generatedVariables.sendBuffer),
                  new JLocalVariableExpression
                  (null,
                   generatedVariables.exeIndex)));
        
            pushExp.setTapeType(Util.getBaseType(filter.getOutputType()));
        
            JExpressionStatement send = new JExpressionStatement(null, pushExp, null);
        
            block.addStatement
                (makeForLoop(send, generatedVariables.exeIndex,
                             new JIntLiteral(filterInfo.steadyMult * filterInfo.push * 
                                             Util.getTypeSize(filter.getOutputType()))));
            //reset the send buffer index
            block.addStatement
                (new JExpressionStatement(null,
                                          new JAssignmentExpression(null,
                                                                    new JLocalVariableExpression
                                                                    (null, generatedVariables.sendBufferIndex),
                                                                    new JIntLiteral(-1)),
                                          null));
        }
    

        //if we are in decoupled mode do not put the work function in a for loop
        //and add the print statements
        if (KjcOptions.decoupled) {
            block.addStatementFirst
                (new SIRPrintStatement(null, 
                                       new JIntLiteral(0),
                                       null));
            block.addStatement(block.size(), 
                               new SIRPrintStatement(null, 
                                                     new JIntLiteral(1),
                                                     null));
        }
    
        return block;
    
    }

    /** 
     * Returns the dimensions for the peek buffer for filter with type inputType and
     * size buffersize.  
     * 
     * If the type is an array type, then prepend the array dimensions before the 
     * buffersize dimensions.
     * 
     * @param filter The filter
     * @param inputType The input type of the filter
     * @param buffersize The size of the peek buffer.
     * @return
     */
    private JExpression[] bufferDims(FilterContent filter, CType inputType, int buffersize) 
    {
        //this is an array type
        if (inputType.isArrayType()) {
            CType baseType = ((CArrayType)inputType).getBaseType();
            //create the array to hold the dims of the buffer
            JExpression baseTypeDims[] = ((CArrayType)inputType).getDims();
            //the buffer is an array itself, so add one to the size of the input type
            JExpression[] dims =  new JExpression[baseTypeDims.length + 1];
            //the first dim is the buffersize
            dims[0] = new JIntLiteral(buffersize);
            //copy the dims for the basetype
            for (int i = 0; i < baseTypeDims.length; i++)
                dims[i+1] = baseTypeDims[i];
            return dims;
        } else {
            JExpression dims[] = {new JIntLiteral(buffersize)};
            return dims;
        }
    }
    
    /**
     * Generate code for filter that will receive pop elements into the peek
     * buffer.  This is called before each execution of the work function.
     * 
     * @param filter The filter.
     * @param type The type of the filter.
     * @param generatedVariables The variables that we have generated for this filter, 
     * including the peek buffer and any indices we might use.
     * 
     * @return The code to receive into the peek buffer.
     */
    private JStatement receiveCode(FilterContent filter, CType type, GeneratedVariables generatedVariables) {
        if (filterInfo.noBuffer()) 
            return null;

        //the name of the method we are calling, this will
        //depend on type of the pop, by default set it to be the scalar receive
        String receiveMethodName = (gdnInput ? gdnReceiveMethod : staticReceiveMethod);

        JBlock statements = new JBlock(null, new JStatement[0], null);
    
        //if it is not a scalar receive change the name to the appropriate 
        //method call, from struct.h
        if (type.isArrayType()) 
            receiveMethodName = arrayReceiveMethod;
        else if (type.isClassType()) {
            receiveMethodName = structReceiveMethodPrefix  + type.toString();
        }

        System.out.println(generatedVariables.recvBuffer);
        //create the array access expression to access the buffer 
        JArrayAccessExpression arrayAccess = 
            new JArrayAccessExpression(null,
                                       new JFieldAccessExpression
                                       (null, new JThisExpression(null),
                                        generatedVariables.recvBuffer.getIdent()),
                                       bufferIndex(filter,
                                                   generatedVariables));
    
        //put the arrayaccess in an array...
        JExpression[] bufferAccess = 
            {new JParenthesedExpression(null,
                                        arrayAccess)};
     
        //the method call expression, for scalars, flatIRtoC
        //changes this into c code thatw will perform the receive...
        JExpression exp =
            new JMethodCallExpression(null,  new JThisExpression(null),
                                      receiveMethodName,
                                      bufferAccess);
    
        ((JMethodCallExpression)exp).setTapeType(filter.getInputType());

        //return a statement
        return new JExpressionStatement(null, exp, null);
    }


    /**
     * Return the buffer access expression that is used when we are receiving
     * items from the network and placing them into the buffer before the  
     * work function fires.  
     * 
     * @see BufferedCommunication#receiveCode
     * 
     * depends if this is a simple filter
     * 
     * @param filter The filter
     * @param generatedVariables The variables that we have generated for this filter, 
     * including the peek buffer and any indices we might use.
     * 
     * @return The buffer access expression.
     */
    private JExpression bufferIndex(FilterContent filter, 
                                    GeneratedVariables generatedVariables) 
    {
        if (filterInfo.isSimple()) {
            return new JFieldAccessExpression
                (null, new JThisExpression(null),
                 generatedVariables.exeIndex.getIdent());
        }
        else {
            //create the increment of the index var
            JPrefixExpression bufferIncrement = 
                new JPrefixExpression(null, 
                                      OPE_PREINC,
                                      new JFieldAccessExpression
                                      (null, new JThisExpression(null),
                                       generatedVariables.recvIndex.getIdent()));
    
        
            //create the modulo expression
            JBitwiseExpression indexAnd = 
                new JBitwiseExpression(null, 
                                       OPE_BAND,
                                       bufferIncrement, 
                                       new JFieldAccessExpression
                                       (null, new JThisExpression(null),
                                        generatedVariables.recvBufferBits.getIdent()));
        
            return indexAnd;
        }
    }
}
