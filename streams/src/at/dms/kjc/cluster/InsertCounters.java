package at.dms.kjc.cluster;

import at.dms.kjc.Constants;
import at.dms.kjc.JBinaryExpression;
import at.dms.kjc.JBitwiseExpression;
import at.dms.kjc.JCompoundAssignmentExpression;
import at.dms.kjc.JEqualityExpression;
import at.dms.kjc.JExpression;
import at.dms.kjc.JPostfixExpression;
import at.dms.kjc.JPrefixExpression;
import at.dms.kjc.JRelationalExpression;
import at.dms.kjc.JShiftExpression;
import at.dms.kjc.JUnaryExpression;
import at.dms.kjc.KjcOptions;
import at.dms.kjc.common.CodegenPrintWriter;

/**
 * If KjcOptions.countops is enabled, this class inserts
 * insrumentation calls for counting the number of operations in the C
 * runtime.  If KjcOptions.countops is false, then this layer of code
 * generation is a no-op.
 *
 * Instrumentation calls are primarily to the profiler::register_op
 * function, documented in the cluster library.
 */
public class InsertCounters extends at.dms.kjc.common.ToC implements Constants {

    public InsertCounters() {
        super();
    }

    public InsertCounters(CodegenPrintWriter p) {
        super(p);
    }

    /**
     * Converts a string opcode (as used in visits to binary arith
     * expression) to the name of the opcode in cluster library.
     */
    private String convertToProfilerOp(String op) {
        if (op.equals("+"))  return "BINOP_ADD"; 
        if (op.equals("*"))  return "BINOP_MUL";
        if (op.equals("-"))  return "BINOP_SUB";
        if (op.equals("&&")) return "BINOP_AND";
        if (op.equals("||")) return "BINOP_OR";
        if (op.equals("/"))  return "BINOP_DIV";
        if (op.equals("%"))  return "BINOP_MOD";
        assert false : "Unexpected operation: " + op;
        return null;
    }

    /**
     * Converts an opcode in at.dms.kjc.Constants to the name of the
     * opcode in cluster library. 
     */
    private String convertToProfilerOp(int op) {
        switch(op) {
            // binary operators
        case OPE_SIMPLE:  assert false : "Don't know what to do with \"simple\" op.";
        case OPE_PLUS:    return "BINOP_ADD"; 
        case OPE_MINUS:   return "BINOP_SUB"; 
        case OPE_STAR:    return "BINOP_MUL"; 
        case OPE_SLASH:   return "BINOP_DIV"; 
        case OPE_PERCENT: return "BINOP_MOD"; 
        case OPE_SR:      return "BINOP_RSHIFT"; 
        case OPE_BSR:     return "BINOP_RSHIFT"; 
        case OPE_SL:      return "BINOP_LSHIFT"; 
        case OPE_BAND:    return "BINOP_BAND"; 
        case OPE_BXOR:    return "BINOP_BXOR"; 
        case OPE_BOR:     return "BINOP_BOR"; 
            // not sure about the next two, they don't seem to fit.
            // Anyway, I think they are never used since bitwisecomplement
            // and logicalcomplement are visited independently and do not
            // call this helper function
        case OPE_BNOT:    return "UNOP_COMPLEMENT"; 
        case OPE_LNOT:    return "UNOP_NOT"; 
        case OPE_LT:      return "BINOP_LT"; 
        case OPE_LE:      return "BINOP_LE"; 
        case OPE_GT:      return "BINOP_GT"; 
        case OPE_GE:      return "BINOP_GE"; 
        case OPE_EQ:      return "BINOP_EQ"; 
        case OPE_NE:      return "BINOP_NEQ"; 
            // unary operators
        case OPE_PREINC:  return "UNOP_PREINC"; 
        case OPE_PREDEC:  return "UNOP_PREDEC"; 
        case OPE_POSTINC: return "UNOP_POSTINC"; 
        case OPE_POSTDEC: return "UNOP_POSTDEC"; 
        default: assert false : "Unrecognized op: " + op;
        }
        return null;
    }

    /*
     * If profiling is enabled, emit a call to the profiler that
     * indicates operation <op> (as defined in at.dms.kjc.Constants)
     * is executed.
     */
    private void beginWrapper(int op) {
        beginWrapper(convertToProfilerOp(op));
    }

    /**
     * If profiling is enabled, emit a call to the profiler that
     * indicates operation <op> (as defined in profiler.h) is
     * executed.
     */
    protected void beginWrapper(String op) {
        if (KjcOptions.countops) {
            // generate a unique ID for this arith op
            int id = MAX_PROFILE_ID++;
            // call to function in Java library (it returns the
            // third argument, which is generated by this visitor
            // in generating code for the actual expression)
            p.print("profiler::register_op(profiler::" + op + ", " + id + ", ");
        }
    }
    // counter for wrapWithProfiling
    private static int MAX_PROFILE_ID = 0;

    /**
     * If profiling is enabled, close an emitted call to the profiler.
     */
    protected void endWrapper() {
        if (KjcOptions.countops) {
            // just close the function call that was started in
            // beginWrapper
            p.print(")");
        }
    }

    /**
     * Returns the number of ID's that were assigned by the profiler.
     */
    public static int getNumIds() {
        return MAX_PROFILE_ID;
    }

    /******************************************************
     * Visitors
     ******************************************************/
    
    @Override
	public void visitUnaryPlusExpression(JUnaryExpression self,
                                         JExpression expr)
    {
        beginWrapper("UNOP_POS");
        super.visitUnaryPlusExpression(self, expr);
        endWrapper();
    }

    @Override
	public void visitUnaryMinusExpression(JUnaryExpression self,
                                          JExpression expr)
    {
        beginWrapper("UNOP_NEG");
        super.visitUnaryMinusExpression(self, expr);
        endWrapper();
    }

    @Override
	public void visitBitwiseComplementExpression(JUnaryExpression self,
                                                 JExpression expr)
    {
        beginWrapper("UNOP_COMPLEMENT");
        super.visitBitwiseComplementExpression(self, expr);
        endWrapper();
    }

    @Override
	public void visitLogicalComplementExpression(JUnaryExpression self,
                                                 JExpression expr)
    {
        beginWrapper("UNOP_NOT");
        super.visitLogicalComplementExpression(self, expr);
        endWrapper();
    }

    @Override
	public void visitShiftExpression(JShiftExpression self,
                                     int oper,
                                     JExpression left,
                                     JExpression right) {
        beginWrapper(oper);
        super.visitShiftExpression(self, oper, left, right);
        endWrapper();
    }

    @Override
	public void visitRelationalExpression(JRelationalExpression self,
                                          int oper,
                                          JExpression left,
                                          JExpression right) {
        beginWrapper(oper);
        super.visitRelationalExpression(self, oper, left, right);
        endWrapper();
    }

    @Override
	public void visitPrefixExpression(JPrefixExpression self,
                                      int oper,
                                      JExpression expr) {
        beginWrapper(oper);
        super.visitPrefixExpression(self, oper, expr);
        endWrapper();
    }

    @Override
	public void visitPostfixExpression(JPostfixExpression self,
                                       int oper,
                                       JExpression expr) {
        beginWrapper(oper);
        super.visitPostfixExpression(self, oper, expr);
        endWrapper();
    }

    @Override
	public void visitBinaryExpression(JBinaryExpression self,
                                      String oper,
                                      JExpression left,
                                      JExpression right) {
        // strangely, binary arithmetic expressions are visited with a
        // string representation of the operation.  Convert this to
        // the version needed by the profiler.
        beginWrapper(convertToProfilerOp(oper));
        super.visitBinaryExpression(self, oper, left, right);
        endWrapper();
    }

    @Override
	public void visitEqualityExpression(JEqualityExpression self,
                                        boolean equal,
                                        JExpression left,
                                        JExpression right) {
        beginWrapper(equal ? "BINOP_EQ" : "BINOP_NEQ");
        super.visitEqualityExpression(self, equal, left, right);
        endWrapper();
    }

    @Override
	public void visitCompoundAssignmentExpression(JCompoundAssignmentExpression self,
                                                  int oper,
                                                  JExpression left,
                                                  JExpression right) {
        beginWrapper(oper);
        super.visitCompoundAssignmentExpression(self, oper, left, right);
        endWrapper();
    }

    @Override
	public void visitBitwiseExpression(JBitwiseExpression self,
                                       int oper,
                                       JExpression left,
                                       JExpression right) {
        beginWrapper(oper);
        super.visitBitwiseExpression(self, oper, left, right);
        endWrapper();
    }

    /******************************************************
     * End visitors
     ******************************************************/
}
