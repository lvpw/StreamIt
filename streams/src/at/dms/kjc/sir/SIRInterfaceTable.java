package at.dms.kjc.sir;

import at.dms.compiler.TokenReference;
import at.dms.kjc.AttributeVisitor;
import at.dms.kjc.CClassType;
import at.dms.kjc.CExpressionContext;
import at.dms.kjc.CStdType;
import at.dms.kjc.CType;
import at.dms.kjc.CodeSequence;
import at.dms.kjc.ExpressionVisitor;
import at.dms.kjc.JExpression;
import at.dms.kjc.JLocalVariable;
import at.dms.kjc.JMethodDeclaration;
import at.dms.kjc.KjcVisitor;
import at.dms.kjc.SLIRAttributeVisitor;
import at.dms.kjc.SLIRVisitor;

/**
 * This represents an interface table.  This encapsulates the
 * relationship between a message-sending interface and a
 * message-receiving class.  It contains the name of the interface and
 * an ordered list of functions corresponding to the interface.
 * 
 * TODO: It seems an unfortunate accident in LIRToC made this a JExpression.
 */
public class SIRInterfaceTable extends JExpression
{
    /**
	 * 
	 */
	private static final long serialVersionUID = 1834731554394615294L;

	/**
     * The interface that the class implements.
     */
    protected CClassType iface;
    
    /**
     * The methods that implement that interface.
     */
    protected JMethodDeclaration[] methods;

    /**
     * The variable declaration containing this interface table.
     */
    protected JLocalVariable vardecl;

    /**
     * No argument constructor, FOR AUTOMATIC CLONING ONLY.
     */
    protected SIRInterfaceTable() {
        super();
    }
    
    /**
     * Construct a new interface table.
     * @param where    The line of this node in the source code
     * @param iface    The interface being implemented
     * @param methods  The methods that implement it
     */
    public SIRInterfaceTable(TokenReference where,
                             CClassType iface,
                             JMethodDeclaration[] methods)
    {
        super(where);
        this.iface = iface;
        this.methods = methods;
        this.vardecl = null;
    }

    /**
     * Returns the type of this expression.
     */
    @Override
	public CType getType() 
    {
        return CStdType.Void;
    }

    /**
     * Better be identical to manifest type returned by getType().
     */
    @Override
	public void setType(CType type) {
        assert type == getType();
    }
    
    @Override
	public JExpression analyse(CExpressionContext context)
    {
        at.dms.util.Utils.fail("Analysis of SIR nodes not supported yet.");
        return this;
    }

    @Override
	public void genCode(CodeSequence code, boolean discardValue)
    {
        at.dms.util.Utils.fail("Codegen of SIR nodes not supported yet.");
    }

    /**
     * Returns the interface this implements.
     */
    public CClassType getIface()
    {
        return this.iface;
    }
    
    /**
     * Returns the list of methods.
     */
    public JMethodDeclaration[] getMethods()
    {
        return this.methods;
    }

    /**
     * Associates a variable declaration with the table.
     */
    public void setVarDecl(JLocalVariable vardecl)
    {
        this.vardecl = vardecl;
    }
    
    /**
     * Returns the variable declaration for the table.
     */
    public JLocalVariable getVarDecl()
    {
        return this.vardecl;
    }

    /**
     * Accepts the specified visitor.
     */
    @Override
	public void accept(KjcVisitor p) 
    {
        if (p instanceof SLIRVisitor)
            {
                ((SLIRVisitor)p).visitInterfaceTable(this);
            }
        else
            {
                // Would accept any sub-objects, but there aren't any.
            }
    }
    
    @Override
	public Object accept(AttributeVisitor p) 
    {
        if (p instanceof SLIRAttributeVisitor)
            return ((SLIRAttributeVisitor)p).visitInterfaceTable(this);
        else
            return this;
    }

    /**
     * Accepts the specified visitor
     * @param p the visitor
     * @param o object containing extra data to be passed to visitor
     * @return object containing data generated by visitor 
     */
    @Override
    public <S,T> S accept(ExpressionVisitor<S,T> p, T o) {
        return p.visitInterfaceTable(this,o); //author claims is expression.  Is it really?
    }

     

    /** THE FOLLOWING SECTION IS AUTO-GENERATED CLONING CODE - DO NOT MODIFY! */

    /** Returns a deep clone of this object. */
    @Override
	public Object deepClone() {
        at.dms.kjc.sir.SIRInterfaceTable other = new at.dms.kjc.sir.SIRInterfaceTable();
        at.dms.kjc.AutoCloner.register(this, other);
        deepCloneInto(other);
        return other;
    }

    /** Clones all fields of this into <pre>other</pre> */
    protected void deepCloneInto(at.dms.kjc.sir.SIRInterfaceTable other) {
        super.deepCloneInto(other);
        other.iface = (at.dms.kjc.CClassType)at.dms.kjc.AutoCloner.cloneToplevel(this.iface);
        other.methods = (at.dms.kjc.JMethodDeclaration[])at.dms.kjc.AutoCloner.cloneToplevel(this.methods);
        other.vardecl = (at.dms.kjc.JLocalVariable)at.dms.kjc.AutoCloner.cloneToplevel(this.vardecl);
    }

    /** THE PRECEDING SECTION IS AUTO-GENERATED CLONING CODE - DO NOT MODIFY! */
}

