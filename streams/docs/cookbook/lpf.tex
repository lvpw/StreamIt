\section{A Low-Pass Filter}

\begin{lstlisting}{}
float->float filter LowPassFilter(float rate, float cutoff, int taps) {
  float[taps] coeff;
  init {
    int i;
    float m = taps - 1;
    float w = 2 * pi * cutoff / rate;
    for (i = 0; i < taps; i++) {
      if (i - m/2 == 0)
        coeff[i] = w/pi;
      else
        coeff[i] = sin(w*(i-m/2)) / pi / (i-m/2) *
          (0.54 - 0.46 * cos(2*pi*i/m));
    }
  }
  work pop 1 push 1 peek taps {
    float sum = 0;
    for (int i = 0; i < taps; i++)
      sum += peek(i) * coeff[i];
    push(sum);
    pop();
  }
}
\end{lstlisting}

The work function for a low-pass filter looks much like the work
function of the moving-average filter; however, it has extensive
initialization code.  From the sampling rate, cutoff frequency, and
number of taps, coefficients for an FIR filter can be statically
calculated.  This is done once, in the init function, and saved in the
\lstinline|coeff| array; the work function then effectively does a
convolution.  StreamIt provides a number of built-in mathematical
functions, such as the call to \lstinline|sin()| here, along with
the constant \lstinline|pi|.

StreamIt's array syntax is more C-like than Java-like.  Every array
has a fixed length; this length can be a numeric constant or stream
parameter, or other value that can be statically evaluated.  In the
declaration syntax, the length of the array comes between the base
type and the variable name.

The coefficient array here is defined as a \emph{field} in the
filter.  If the name \lstinline|coeff| were used as a local variable
in the init or work function, it would shadow the field, as in other
languages.  Otherwise, uses in both the init and work functions
reference the field.  If multiple low-pass filters existed, each would
have its own coefficient array.
