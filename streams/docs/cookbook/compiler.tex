\newcommand{\entry}[1]{\raisebox{0pt}[24pt][20pt]{\parbox{2.75in}{#1}}}
\newcommand{\entrymed}[1]{\raisebox{0pt}[36pt][30pt]{\parbox{2.75in}{#1}}}
\newcommand{\entrybig}[1]{\raisebox{0pt}[42pt][36pt]{\parbox{2.75in}{#1}}}

This section walks through a sample session with the compiler and
runtime system.  We will use the {\tt FMRadio} example from the
StreamIt release as a running example.  To get started, change to the
following directory:
{\small
\begin{verbatim}
% cd $STREAMIT_HOME/apps/examples/cookbook
\end{verbatim}
}
\noindent The example is in {\tt FMRadio.str}. The following
sections describe the compilation of {\tt FMRadio} using the
uniprocessor backend, the Java library, and the Raw backend.  A
summary of the compiler's command-line options can be found in
Appendix~\ref{ap:options}, or by typing {\tt strc -help} at the
command line.

\subsection{Compiling for a Uniprocessor}

There are two ways to compile a StreamIt program for execution on a
general-purpose processor.  Both methods compile StreamIt to a C
program that can be further compiled with a C compiler.  The first
method (the default) preserves the hierarchical structure of the
original program and relies on a C runtime library to do buffer
management.  The second method (``standalone'') produces a
self-contained file where the entire stream graph has been collapsed
into a single function, with buffer management embedded into the code.
The default output is more readable and provides some flexibility (by
exposing the runtime library interface).  The standalone output might
be useful for groups interested in compiling C programs to new
architectures; however, the size of the main work function might grow
very large.  We recommend using the default backend with the C runtime
library.

\medskip {\bf Compiling for C library.}  To compile {\tt FMRadio} using the
uniprocessor backend and C runtime library, issue the following
command (the compiler output is shown): {\small
\begin{verbatim}
% strc FMRadio.str -o fm
Running Constant Prop and Unroll... done.
Raising variable declarations... done.
Propagating constant fields... done.
Flattening blocks... done.
Raising variables... done.
Raising variable declarations... done.
Moving initial assignments... done.
Structuring... done.
Scheduling... got schedule, interpreting... done.
Annotating IR for uniprocessor... done.
Generating code...
\end{verbatim}
} 
This will create a C file named FMRadio.c and a binary named {\tt
fm}.  The binary can be executed for 5 steady-state iterations as follows:
{\small
\begin{verbatim}
% ./fm -i 5
278074.000000
278074.750000
278075.437500
278075.968750
278076.437500
\end{verbatim}
} 
During the compilation process, several {\tt dot} graphs are
generated.  The {\tt dot} format can be displayed and converted to
other formats using the Graphviz software, which is available
online\footnote{\tt http://www.research.att.com/sw/tools/graphviz/}.
For example, we can examine a stream graph for the FM application as
follows: {\small
\begin{verbatim}
% dotty first-sir-tree.dot
\end{verbatim}
} The result appears in Figure~\ref{fig:fm-sir-tree}.  A complete list
of the {\tt dot} graphs that are produced on the normal uniprocessor path
are shown in Figure~\ref{fig:dot-uni}.

\begin{figure}[t]
\hspace{-0.75in}\psfig{figure=fm-sir-tree.eps,width=6.6in}
\caption{{\tt first-sir-tree.dot} for the FMRadio example.\protect\label{fig:fm-sir-tree}}
\end{figure}

\begin{figure}[t]
{\small
\noindent \begin{tabular}{|l|l|}
\hline
{\bf Filename} & {\bf Description} \\
\hline
{\tt first-sir-tree.dot} & \entry{Original stream graph, as written by programmer.} \\ \hline
{\tt before-partition.dot} & \entry{Canonical version of stream graph, before any stream transformations are applied.  Nodes are annotated with their I/O rates.}\\ \hline
{\tt after-partition.dot} & \entry{Canonical version of stream graph, after any stream transformations are applied.  Nodes are annotated with their I/O rates.}\\ \hline
{\tt schedule.dot} & \entry{Final stream graph, annotated with I/O rates and the number of times each node executes in the initial and steady-state schedule.} \\ \hline
\end{tabular}
}
\caption{{\tt dot} graphs produced on the uniprocessor path.\protect\label{fig:dot-uni}}
\end{figure}

\medskip {\bf Domain-specific optimizations.}  It turns out that our
version of the FMRadio has a lot of redundant computation the way in
which it is written.  For example, each {\tt BandPassFilter} could be
implemented as a single FIR filter rather than a composition of {\tt
LowPassFilter}'s; in fact, the entire equalizer could be collapsed to
a single FIR filter.  Further, some of these operations are more
efficient if executed in the frequency domain, with an FFT/IFFT being
used to translate to and from the time domain.

The StreamIt compiler includes a set of domain-specific optimizations
that will automatically perform the transformations described above.
The analysis considers all filters that are ``linear''---that is, each
of their outputs is an affine combination of their inputs.  The
compiler automatically detects linear filters by analyzing the code in
their work functions.  Then, it performs algebraic simplification of
adjacent linear filters, as well as automatic translation to the
frequency domain.  Since these transformations can sometimes hamper
performance, the compiler also does a global cost/benefit analysis to
determine the best set of transformations for a given stream graph.

\begin{figure}[t]
\hspace{3pt} \psfig{figure=fm-linear-simple.eps,width=4.6in}
\caption{{\tt linear-simple.dot}, which illustrates the linear sections of FMRadio.  Linear filters are shaded blue, while linear containers are shaded pink.\protect\label{fig:fm-linear-simple}}
\end{figure}

\begin{figure}[t]
\vspace{-6pt}
\begin{center}
\mbox{}\psfig{figure=fm-after-linear.eps,width=2.5in}
\vspace{-6pt}
\caption{Final stream graph ({\tt after-linear.dot}) for the FMRadio, compiling with the {\tt -linearpartition} option.\protect\label{fig:fm-after-linear}}
\end{center}
\vspace{-14pt}
\end{figure}

The {\tt linearpartition} option to strc will enable linear analysis
and optimizations\footnote{In contrast, the {\tt linearreplacement}
and {\tt frequencyreplacement} options will perform maximal algebraic
simplification and frequency translation, respectively, even in cases
where it is not beneficial.}:
{\small
\begin{verbatim}
% strc -linearpartition FMRadio.str -o fm
Running Constant Prop and Unroll... done.
Raising variable declarations... done.
Propagating constant fields... done.
Flattening blocks... done.
Raising variables... done.
Raising variable declarations... done.
Moving initial assignments... done.
Running linear analysis...
WARNING: Assuming method call expression non linear(atan). Also 
  removing all field mappings.
WARNING: Insufficient pushes detected in filter
done with linear analysis.
Linear partitioner took 1 secs to calculate partitions.
Structuring... done.
Scheduling... got schedule, interpreting... done.
Annotating IR for uniprocessor... done.
Generating code...
\end{verbatim}
} 
%
The linear analysis produces its own set of {\tt dot} files that we
can use to inspect the results of the optimizations.  For example, the
following command will display the stream graph with the linear
sections highlighted: {\small
\begin{verbatim}
% dotty linear-simple.dot
\end{verbatim}
} 
%
As shown in Figure~\ref{fig:fm-linear-simple}, FMRadio contains many
linear components, including the first LowPassFilter and the
equalizer.  To see the stream graph after linear optimizations have
been applied, we can issue the following command:
{\small
\begin{verbatim}
% dotty after-linear.dot
\end{verbatim}
} 
%
As illustrated in Figure~\ref{fig:fm-after-linear}, this stream
graph shows that the equalizer was collapsed into a single filter and
then was translated to the frequency domain (by virtue of the ``Freq''
prefix in the filter's name.)  However, the LowPassFilter at the top
was left unmodified; this is because it has a large pop rate that
degrades the performance of the frequency transformation.  In this
case, the linear optimizations lead to a 6.5X improvement in
throughput.

The linear optimizations produce additional {\tt dot} graphs; see
Figure~\ref{fig:dot-linear} for details.  For more information on the
linear analysis and optimization, please refer to {\tt http://cag.lcs.mit.edu/linear}.

\begin{figure}[t]
\vspace{-6pt}
{\small
\noindent \begin{tabular}{|l|l|}
\hline
{\bf Filename} & {\bf Description} \\
\hline
{\tt ldp-partition-input.dot} & \entry{The stream graph as it was input to the linear partitioning algorithm.}\\ \hline
{\tt linear.dot} & \entry{The stream graph with linear filters highlighted and each node annotated with its I/O rates.}\\ \hline
{\tt linear-simple.dot} & \entry{Same as {\tt linear.dot} but without the I/O rates.}\\ \hline
{\tt after-linear.dot} & \entry{The stream graph after linear transformations are complete.} \\ \hline
\end{tabular}
}
\vspace{-5pt}
\caption{{\tt dot} graphs produced by linear optimizations.\protect\label{fig:dot-linear}}
\vspace{-5pt}
\end{figure}

\bigskip {\bf Compiling as standalone.}  To compile FMRadio to a
standalone file that can execute without the C runtime library, use
the {\tt -standalone} option:
{\small
\begin{verbatim}
% strc -standalone FMRadio.str -o fm
/*
Out of Kopi2SIR.
Out of semantic checker.
*/
Entry to RAW Backend
Moving initializers into init functions... done.
Running Constant Prop and Unroll...
Done Constant Prop and Unroll...
Running Constant Field Propagation...
Done Constant Field Propagation...
Running Partitioning...
  Found 26 tiles.
  Building stream config...
  Calculating partition info...
  Tracing back...
  Work Estimates:
    Fused_Flo_Low_FMD_Low_Pre_E...      10240   (100%)
Done Partitioning...
Flattener Begin...
Filters in Graph: 1
Flattener End.
Simulated Annealing Assignment
Tiles layout.assigned: 1
Initial Cost: 0.0
Assign End.
Switch Code Begin...
FineGrainSimulator Running...
End of init simulation
End of steady-state simulation
sw0.s written
Switch Code End.
Generating Raw Code: 
  Fused_Flo_Low_FMD_Low_Pre_EqS_Pos_Fil_Flo_172 (no buffer)
Tile Code begin...
Optimizing Fused_Flo_Low_FMD_Low_Pre_EqS_Pos_Fil_Flo_172...
Code for Fused_Flo_Low_FMD_Low_Pre_EqS_Pos_Fil_Flo_172 
  written to tile0.c
Tile Code End.
Creating Makefile.
Exiting
\end{verbatim}
} 
%
As is evident in the compiler output above, the standalone option
utilizes the Raw backend and stores the self-contained output file in
{\tt tile0.c} (as well as the binary {\tt fm}).  Also, due to an
implementation detail, it is not possible to control the number of
runtime iterations for standalone programs (they will run forever.)

\subsection{Using the Java Library}

A convenient aspect of the StreamIt compilation toolchain is that all
StreamIt programs are first translated to Java files that can be
executed against a Java runtime library using a normal Java Virtual
Machine.  This is especially useful for testing and debugging
applications, as well as validating the output of the compiler.

The library can be invoked with the {\tt -library} flag.  Since {\tt
strc} will both compile and execute the file in the library, you can
specify the number of iterations to execute with the {\tt -i} flag.
For example, to compile FMRadio and run for 5 iterations in the
library, do as follows\footnote{In this case, the library's output is
marginally different from the compiler's due to numerical precision
issues.}:
%
{\small
\begin{verbatim}
% strc -library -i 5 FMRadio.str
278073.94
278074.75
278075.38
278075.94
278076.4
\end{verbatim}
} 
%
You can also inspect the {\tt FMRadio.java} file, which was generated
for execution in the library.  It can be compiled and run with a
standard Java compiler and JVM.  The library also produces a {\tt dot}
graph of the program; it is given the same name as the StreamIt file,
but with a {\tt dot} extension ({\it i.e.,} it is {\tt FMRadio.dot} in
this case.)

There are a few additional options available in the library.  For
instance, you can direct the library not to execute the program, but
to instead just print the schedule of filter firings:
{\small
\begin{verbatim}
% strc -library -norun -printsched FMRadio.str
init = [
$0 = FloatOneSource@3541984.work
$1 = LowPassFilter@4565111.work
$2 = FMDemodulator@1233730.work
$3 = EqSplit@4689495.duplicate
$4 = BPFCore@6288523.duplicate
$5 = BPFCore@4074853.duplicate
$6 = BPFCore@5058143.duplicate
$7 = BPFCore@2951274.duplicate
$8 = { {379 $0} {64 $1} {63 $2} {63 $3} 
       {63 $4} {63 $5} {63 $6} {63 $7} }
]
steady = [
$9 = LowPassFilter@3738425.work
$10 = LowPassFilter@1042371.work
$11 = BPFCore@6288523.roundrobin
$12 = Subtracter@3144816.work
$13 = EqSplit$2@6700605.work
$14 = LowPassFilter@5188736.work
$15 = LowPassFilter@7510100.work
$16 = BPFCore@4074853.roundrobin
$17 = Subtracter@1467553.work
$18 = EqSplit$2@2671847.work
$19 = LowPassFilter@503498.work
$20 = LowPassFilter@6589979.work
$21 = BPFCore@5058143.roundrobin
$22 = Subtracter@2069821.work
$23 = EqSplit$2@8316668.work
$24 = LowPassFilter@1649037.work
$25 = LowPassFilter@7808535.work
$26 = BPFCore@2951274.roundrobin
$27 = Subtracter@230849.work
$28 = EqSplit$2@4354460.work
$29 = EqSplit@4689495.roundrobin
$30 = Equalizer$1@3615258.work
$31 = FloatPrinter@2964388.work
$32 = { {5 $0} $1 $2 $3 $4 $9 $10 $11 $12 $13 $5 $14 $15 $16 $17 $18
        $6 $19 $20 $21 $22 $23 $7 $24 $25 $26 $27 $28 $29 $30 $31 }
]
!ml sched size = 39
!ml buff size = 1299
\end{verbatim}
%$
} 
%
Currently, the default scheduler is a minimal latency scheduler that
uses phases to compress the code size.  The schedule listed above has
two components: an initialization schedule (to initialize buffers for
filters that peek) and a steady-state schedule (that can loop
infinitely).  Each filter and splitter in the graph is given a number
for easy reference, and then the schedule is printed at the bottom.  A
loop nest in the schedule is denoted by {\tt (N F)}, where the filter
{\tt F} executes {\tt N} times.  The schedule size and buffer size
required are printed at the end of the listing.

Additional options for the library can be found in
Appendix~\ref{ap:options}.

\subsection{Compiling for Raw}

To compile for an {\tt NxN} Raw machine, use the {\tt -raw N}
option\footnote{You can also compile for an NxM machine by using {\tt
-raw N -rawcol M}.}.  In most cases, you will want to use {\tt -raw
4}, since the actual chip has 4 tiles on each side.  When compiling to
Raw, we also recommend using the {\tt -O1} flag to enable common
optimizations; the default is {\tt -O0} (no optimizations), and the
most aggressive is {\tt -O2} (which includes slow and potentially
unstable transformations).  More information about specific
optimizations can be found in Appendix~\ref{ap:options}.

Compiling FMRadio looks like this: {\small
\begin{verbatim}
% strc -raw 4 -O1 FMRadio.str
/*
Out of Kopi2SIR.
Out of semantic checker.
*/
Entry to RAW Backend
Moving initializers into init functions... done.
Running Constant Prop and Unroll...
Done Constant Prop and Unroll...
Running Constant Field Propagation...
Done Constant Field Propagation...
Running Partitioning...
  Found 26 tiles.
  Building stream config...
  Calculating partition info...
  Tracing back...
  Work Estimates:
    LowPassFilter__24                   1444    (10%)
    LowPassFilter__59                   1420    (10%)
    LowPassFilter__80                   1420    (10%)
    LowPassFilter__59                   1420    (10%)
    LowPassFilter__80                   1420    (10%)
    LowPassFilter__59                   1420    (10%)
    LowPassFilter__80                   1420    (10%)
    LowPassFilter__59                   1420    (10%)
    LowPassFilter__80                   1420    (10%)
    Fused_Pre_EqS_Pos_Fil_Flo           386     (2%)
    FMDemodulator__38                   224     (1%)
    FMDemodulator__38                   224     (1%)
    FloatOneSource__3                   110     (0%)
Done Partitioning...
Flattener Begin...
Filters in Graph: 13
Flattener End.
Simulated Annealing Assignment
Tiles layout.assigned: 15
Initial Cost: 60060.0
Final Cost: 29055.0 Min Cost : 21119.0 in  451 iterations.
Assign End.
Cannot perform Rate Matching.
Switch Code Begin...
WorkBasedSimulator Running...
End of init simulation
End of steady-state simulation
sw0.s written
\end{verbatim}
$\dots$
\begin{verbatim}
sw14.s written
Switch Code End.
Generating Raw Code: FloatOneSource__3_96 (Direct Communication)
\end{verbatim}
$\dots$
\begin{verbatim}
Generating Raw Code: FMDemodulator__38_178 (simple)
Tile Code begin...
Optimizing FloatOneSource__3_96...
Code for FloatOneSource__3_96 written to tile0.c
\end{verbatim}
$\dots$
\begin{verbatim}
Optimizing FMDemodulator__38_178...
Code for FMDemodulator__38_178 written to tile2.c
Code  written to tile10.c
Tile Code End.
Creating Makefile.
Exiting
\end{verbatim}
} 
%

\begin{figure}[t]
\hspace{0.25in}\psfig{figure=fm-after-partition.eps,width=4.6in}
\caption{\protect\small Load-balanced stream graph ({\tt after-partition.dot}) that is output by partitioner for executing FMRadio on a 4x4 Raw machine.\protect\label{fig:fm-after-partition}}
\end{figure}

\begin{figure}[t]
{\small
\noindent \begin{tabular}{|l|l|}
\hline
{\bf Filename} & {\bf Description} \\
\hline
{\tt dp-partition-input.dot} & \entry{The stream graph in the format used by the partitioning algorithm.}\\ \hline
{\tt work-before-partition.dot} & \entrybig{The stream graph before partitioning, annotated with estimates of the steady-state work within each node.  Nodes with the same amount of work are given the same color (although the colors themselves are meaningless.)}\\ \hline
{\tt work-before-partition.txt} & \entry{Text listing of the work estimates for filters in the graph, before load balancing.}\\ \hline
{\tt work-after-partition.dot} & \entry{The stream graph after partitioning, annotated with work estimates as above.}\\ \hline
{\tt work-after-partition.txt} & \entry{Text listing of the work estimates for filters in the graph, after load balancing.}\\ \hline
{\tt flatgraph.dot} & \entry{The stream graph with structure eliminated, before it is mapped onto Raw.} \\ \hline
{\tt layout.dot} & \entrymed{The final layout of filters onto Raw tiles, with arrows between communicating filters.  Note that the arrows do NOT indicate the routes that items take.}\\ \hline
{\tt initial-layout.dot} & \entry{The initial layout, before the simulated annealing algorithm.} \\ \hline
\end{tabular}
}
\caption{Files produced by the Raw backend, above and beyond those produced by the uniprocessor backend.\protect\label{fig:dot-raw}}
\end{figure}

A number of {\tt dot} files are produced during the compilation to
Raw; they are listed in Figure~\ref{fig:dot-raw}.  For example, since
there are more filters than Raw tiles, the compiler has to partition
the graph into a set of load-balanced execution units.  The output of
the partitioning stage can be viewed as follows (see
Figure~\ref{fig:fm-after-partition}): 
%
{\small
\begin{verbatim}
% dotty after-partition.dot
\end{verbatim}
} 
%
In this case, the partitioner detected that the LowPassFilter's in the
equalizer were on the critical path, so it allocated a tile for each
one.  The bottom part of the equalizer was fused with the end of the
pipeline.  Also, the FMDemodulator was fissed into two data-parallel
sections.  The steady-state work estimates for before and after
partitioning can be found in {\tt work-} {\tt before-partition.dot}
and {\tt work-after-partition.dot}.  There are also corresponding text
files.

After partitioning, the compiler maps the partitioned stream graph to
the Raw tiles.  The layout can be viewed in {\tt layout.dot}: 
%
\clearpage
%
{\small
\begin{verbatim}
% dotty layout.dot
\end{verbatim}
} 
\begin{figure}[t]
\psfig{figure=fm-layout.eps,width=4.6in}
\caption{\protect\small Final layout ({\tt layout.dot}) for the FMRadio on a 4x4 Raw machine.\protect\label{fig:fm-layout}}
\end{figure}
%
This layout is shown in Figure~\ref{fig:fm-layout}.  Note that the
arrows represent communication channels between filters, but are
unrelated to the routes assigned for these channels.

The final outputs of the Raw backend are: 1) the tile code, which runs
on the compute processors ({\tt tile*.c}), 2) the switch code, which
routes items between processors ({\tt sw*.s}), and 3) {\tt
Makefile.streamit}, which interfaces with the Raw simulation
infrastructure and orchestrates the execution.

\bigskip {\bf Using the Raw simulator.}  To execute the output of the
Raw backend, you will need the Raw simulator and ``starsearch''
infrastructure; for more information, see the Raw website at {\tt
http://cag.lcs.mit.edu/raw}.  The StreamIt compiler makes use of the
cycle-accurate BTL (``Beetle'') simulator for Raw.

To run the simulator, do as follows:
\begin{verbatim}
make -f Makefile.streamit run
\end{verbatim}

This command will cause the simulator to boot up, execute the startup
code and then run for a bunch of cycles. If you want to quit before
the simulation is done, use CTL-C.

Once the simulator is executing the program, the output should should
look as follows:
{\small
\begin{verbatim}
[31: 00001384b]: 278073.937500
[31: 000013d53]: 278074.750000
[31: 000013fc4]: 278075.375000
[31: 000014278]: 278075.937500
[31: 0000144e4]: 278076.406250
[31: 000014798]: 278076.812500
[31: 000014a04]: 278077.156250
[31: 000014cb8]: 278077.468750
[31: 000014f24]: 278077.750000
[31: 0000151d8]: 278078.000000
...
\end{verbatim}
}
The first number (31) represents the fact that the tile at row 3,
column 1 issued the print command. The next number ({\it e.g.},
00001384b) is the cycle count (in hexadecimal) at which the third
number was produced. The third number is the output value that is
produced from FMRadio.

\medskip {\it Running in debug mode.} To run the simulator in interactive debug
mode, you should run:
\begin{verbatim}
make -f Makefile.streamit debug
\end{verbatim}
This will change the terminal window to a text layout of the Raw
tiles being executed, showing the active instruction stream of each.
An extra ``shunt'' window will appear to control the actions of the
debugger; it will look something like this:
{\scriptsize
\begin{verbatim}
// welcome to beetle
// try: 
  help(); help(``help'');

Configuration: 

[THREAD_C THREAD_E DEVICE NAME    RESET ROUTINE          CALC ROUTINE           
PARAM   ]

[081c0f10 00000000 Serial Rom     dev_serial_rom_reset   dev_serial_rom_calc    
0844c9d0]
[0815fcf0 00000000 Print Service  dev_print_service_rese dev_print_service_calc 
0844c410]
\end{verbatim}
$\dots$
\begin{verbatim}
[08205508 00000000 streaming_dram dev_streaming_dram_res dev_streaming_dram_cal 
08444220]

// Use VMShowPositionOfThread(THREAD #); to inspect execution of device 

/*[0] 0*/ 
\end{verbatim}
}

To start the simulator, type {\tt go();}.  This will boot up the Raw
processor, bring the program into memory, and perform some other
initialization tasks.  After initialization, there will be a message
and a prompt such as:
{\small
\begin{verbatim}
running...
\end{verbatim}
$\dots$
\begin{verbatim}
### PASSED: -0000000001 ffffffff      nan [x,y] = [1, 3]
// [ serial rom : finished 
     tile.B79414E0.0004-0004.rbf-15 --> static port 15 ]
// *** interrupted [135033/inf]
stopped.
/*[34576982] 2*/ 
\end{verbatim}
}

You are now ready to start doing useful things with the debugger.  The
following are the most useful commands:

\begin{itemize}

\item {\bf go();} starts the simulator executing, without any limit as
to how many cycles it will run.

If you want to stop the simulator, you can hit CTL-C in the main
window (not the shunt window), which will give you the command prompt
back in the shunt window.

\item {\bf step(N);} steps the simulator forward \texttt{N} cycles. At
the end of {\tt N} cycles, the simulator will stop executing and
return you to a command prompt.

By stepping the simulator \texttt{N} cycles, each processor (of the
16) is stepped forward \texttt{N} cycles.

\item {\bf sv(N);} produces a graphical execution trace over {\tt N}
cycles.  This trace shows the activity of each processor over time; we
call it a ``bloodgraph'' because red indicates that a processor is
blocked and performing no useful work.  For FMRadio, the result of
running {\tt sv(5000);} appears in Figure~\ref{fig:fm-bloodgraph}.

\clearpage

\begin{figure}[t]
\begin{center}
\hspace{0pt}\psfig{figure=fm-bloodgraph.eps,width=4.5in}
\caption{\protect\small Execution trace for FMRadio on a 4x4 Raw
machine.  The vertical axis represents processors, while the
horizontal axis represents time.  Note that the entirely white
processor is not being used by the configuration (you can verify this
by inspecting {\tt layout.dot}, which shows the tile to be
empty).\protect\label{fig:fm-bloodgraph}}
\end{center}
\end{figure}

The complete guide to the colors in the bloodgraph is as follows: \vspace{6pt}

\begin{tabular}{|l|l|}
\hline
{\bf Color} & {\bf Meaning} \\
\hline
{\tt white} & useful work\\ \hline
{\tt purple} & floating point operation\\ \hline
{\tt green} & pipeline stall, {\it e.g.,} for a hazard\\ \hline
{\tt red} & blocked while receiving an item from the switch\\ \hline
{\tt blue} & blocked while sending an item to the switch\\ \hline
\end{tabular}

\item {\bf quit();} will exit the interactive debugger.  Incidentally,
typing CTL-D will close the shunt window.

\end{itemize}

%% {\it The cycle limit.}  By default, there is a limit on the number of
%% cycles that the simulator will execute before halting (so as not to
%% freeze scripts, etc., with an infinite loop.)  If you run the
%% simulator and it finishes before your program produces any outputs,
%% you can edit {\tt Makefile.streamit} and delete the lines which define
%% {\tt LIMIT} and {\tt SIM-CYCLES}.  Then the simulator will run
%% indefinitely.

\bigskip {\bf Gathering numbers.}  The compiler provides automatic
support for gathering throughput, MFLOPS, and utilization numbers, as
well as automated generation of bloodgraphs.  To collect these
performance statistics, use the {\tt -numbers} option, which takes an
argument indicating the number of steady-state cycles to execute:
{\small
\begin{verbatim}
% strc -raw 4 -O1 -numbers 15 FMRadio.str
\end{verbatim}
} 
%
Compilation will proceed as before, except that the code will be
instrumented to gather numbers using hooks in the Raw simulator.  The
program should then be executed in batch mode, and number gathering
messages (one per steady-state) will replace the standard output: 
%
{\small
\begin{verbatim}
% make -f Makefile.streamit run
\end{verbatim}
$\dots$
\begin{verbatim}
running...

### PASSED:  1073741901 4000004d      2.00001836 [x,y] = [0, 0]

### PASSED: -0000000001 ffffffff             nan [x,y] = [0, 0]
Interrupted tile 0, pc = 0x3b8
stopped.
running...
Cycles: 1312,  MFLOPS: 463
Cycles: 1312,  MFLOPS: 463
Cycles: 1312,  MFLOPS: 463
Cycles: 1312,  MFLOPS: 464
Cycles: 1312,  MFLOPS: 460
Cycles: 1312,  MFLOPS: 463
Cycles: 1312,  MFLOPS: 463
Cycles: 1312,  MFLOPS: 463
Cycles: 1312,  MFLOPS: 463
Cycles: 1312,  MFLOPS: 464
Cycles: 1312,  MFLOPS: 461
Cycles: 1312,  MFLOPS: 463
Cycles: 1312,  MFLOPS: 463
Cycles: 1312,  MFLOPS: 463
Cycles: 1312,  MFLOPS: 463
Generating results.out
echo `date` cagfarm-42 'end   running BTL' `pwd` >> /u/thies/researc
h/streams/streams/misc/raw/stardata/logs/cagfarm-42.log; echo `date`
cagfarm-42 'end   running BTL' `pwd` >> /u/thies/research/streams/st
reams/misc/raw/stardata/logs/all.log; rm /u/thies/research/streams/s
treams/misc/raw/stardata/logs/cagfarm-42:BTL::home:bits6:thies:strea
ms:streams:apps:examples:cookbook;rm tile1.s tile8.s tile3.s tile11.
s tile5.s tile13.s tile0.s tile7.s tile15.s tile2.s tile9.s tile10.s
tile4.s tile12.s tile6.s tile14.s 70.540u 18.180s 1:30.55 97.9%   0+
0k 0+0io 58180pf+0w
\end{verbatim}
} 
%
The simulator will terminate naturally, leaving a detailed accounts
summary in the file {\tt results.out}.  Here is an excerpt from the
results file: {\small
\begin{verbatim}
Summmary:
Steady State Executions: 15
Total Cycles: 19680
Total Steady State Outputs: 30
Avg Cycles per Steady-State: 1312
Thruput per 10^5: 152
Total Non-Blocked Cycles: 195438

Instruction Mix:
FPU: 36484
MEM: 37071
BRANCH: 21584
ADMIN: 0
ALU: 100299

workCount* = 195438 / 314880
Avg MFLOPS: 463
\end{verbatim}
}
\noindent Also, a blood graph will be saved in {\tt bloodgraph.ppm}.

\smallskip \noindent More options for the Raw backend are described in
Appendix~\ref{ap:options}.

\clearpage
