\newcommand{\entry}[1]{\raisebox{0pt}[24pt][20pt]{\parbox{2.75in}{#1}}}
\newcommand{\entrymed}[1]{\raisebox{0pt}[36pt][30pt]{\parbox{2.75in}{#1}}}
\newcommand{\entrybig}[1]{\raisebox{0pt}[42pt][36pt]{\parbox{2.75in}{#1}}}

This section walks through a sample session with the compiler and
runtime system.  We will use the {\tt FMRadio} example from the
StreamIt release as a running example.  To get started, change to the
following directory:
{\small
\begin{verbatim}
% cd $STREAMIT_HOME/apps/examples/cookbook
\end{verbatim}
}
\noindent The example is in {\tt FMRadio.str}. The following
sections describe the compilation of {\tt FMRadio} using the
uniprocessor backend, the cluster/multicore backend, and the Java
library.  A summary of the compiler's command-line options can be
found in Appendix~\ref{ap:options}, or by typing {\tt strc -help} at
the command line.

\subsection{Compiling for a Uniprocessor}

There are two ways to compile a StreamIt program for execution on a
general-purpose processor.  The first method (the default) compiles to
a set of C++ files, which are linked against a StreamIt runtime
library.  It uses the same infrastructure as our cluster backend and
supports the full suite of StreamIt features and optimizations.  The
second method (invoked with the {\tt -simpleC} option) emits a
standalone C file in which the entire program is inlined into a single
function.  The simpleC backend is not fully featured\footnote{As of
this release, simpleC lacks support for dynamic rates, teleport
messaging, prework functions, general helper functions,
domain-specific optimizations, cache optimizations, and other
features.} but the output is readable and the C interface may be
useful for some compiler projects.  As we recommend using the default
backend, we focus on it for the remainder of this section.

To compile {\tt FMRadio} using the uniprocessor backend, issue the
following command (the compiler output is shown): 
{\small
\begin{verbatim}
% strc FMRadio.str -o fm
Starting Kopi2SIR... done.
Entry to Cluster Backend (uniprocessor)
Running Constant Prop and Unroll... done.
Running Constant Field Propagation... done.
Estimating Code size of Filters... done.
Estimating Code size of Filters... done.
Running Partitioning... target number of threads: 1
Done Partitioning...
Generating cluster code...
Done generating cluster code.
gcc34 -O3 -I/u/thies/research/streams/streams/library/cluster 
      -c -o combined_threads.o combined_threads.cpp
gcc34 -O3 -o fm combined_threads.o 
      -L/u/thies/research/streams/streams/library/cluster 
      -lpthread -lcluster -lstdc++
\end{verbatim}
}
This will create a number of threadXX.cpp files, one for each filter,
splitter, and joiner in the original program.  The files are
concatenated into a single file (combined\_threads.cpp) and compiled to
create a binary named {\tt fm}.  The binary can be executed for 5
steady-state iterations as follows: 
{\small
\begin{verbatim}
% ./fm -i 5
278073.968750
278074.750000
278075.406250
278075.968750
278076.437500
\end{verbatim}
} 
During the compilation process, several {\tt dot} graphs are
generated.  The {\tt dot} format can be displayed and converted to
other formats using the Graphviz software, which is available
online\footnote{\tt http://www.graphviz.org/}.
For example, we can examine a stream graph for the FM application as
follows: {\small
\begin{verbatim}
% dotty stream-graph-simple.dot
\end{verbatim}
} 
The result appears in Figure~\ref{fig:fm-sir-tree}.  A complete list
of the {\tt dot} graphs that are produced on the normal uniprocessor
path are shown in Figure~\ref{fig:dot-uni}.

\begin{figure}[t]
\hspace{-0.75in}\psfig{figure=fm-sir-tree.eps,width=6.6in}
\caption{{\tt stream-graph-simple.dot} for the FMRadio example.\protect\label{fig:fm-sir-tree}}
\end{figure}

\begin{figure}[t]
{\small
\noindent \begin{tabular}{|l|l|}
\hline
{\bf Filename} & {\bf Description} \\
\hline
{\tt stream-graph-simple.dot} & \entry{Original stream graph, as written by programmer.} \\ \hline
{\tt stream-graph.dot} & \entry{Original stream graph, including I/O rates.} \\ \hline
{\tt after-collapse-sjs.dot} & \entry{Partial canonicalization of stream graph, after collapsing data parallelism in the application.  (The parallelism can be restored if needed.)} \\ \hline
{\tt canonical-graph.dot} & \entry{Canonical version of stream graph, after further eliminating unneeded synchronization.} \\ \hline
%{\tt before-partition.dot} & \entry{Canonical version of stream graph, before any stream transformations are applied.  Nodes are annotated with their I/O rates.}\\ \hline
%{\tt after-partition.dot} & \entry{Canonical version of stream graph, after any stream transformations are applied.  Nodes are annotated with their I/O rates.}\\ \hline
%{\tt schedule.dot} & \entry{Final stream graph, annotated with I/O rates and the number of times each node executes in the initial and steady-state schedule.} \\ \hline
\end{tabular}
}
\vspace{-5pt}
\caption{Notable {\tt dot} graphs produced on the uniprocessor path.\protect\label{fig:dot-uni}}
\vspace{-5pt}
\end{figure}

\medskip {\bf Domain-specific optimizations.}  It turns out that our
version of the FMRadio has a lot of redundant computation the way in
which it is written.  For example, each {\tt BandPassFilter} could be
implemented as a single FIR filter rather than a composition of {\tt
LowPassFilter}'s; in fact, the entire equalizer could be collapsed to
a single FIR filter.  Further, some of these operations are more
efficient if executed in the frequency domain, with an FFT/IFFT being
used to translate to and from the time domain.

The StreamIt compiler includes a set of domain-specific optimizations
that will automatically perform the transformations described above.
The analysis considers all filters that are ``linear''---that is, each
of their outputs is an affine combination of their inputs.  The
compiler automatically detects linear filters by analyzing the code in
their work functions.  Then, it performs algebraic simplification of
adjacent linear filters, as well as automatic translation to the
frequency domain.  Since these transformations can sometimes hamper
performance, the compiler also does a global cost/benefit analysis to
determine the best set of transformations for a given stream graph.

\begin{figure}[t]
\centering
\psfig{figure=fm-linear-simple.eps,width=\textwidth}
\caption{{\tt linear-simple.dot}, which illustrates the linear sections of FMRadio.  Linear filters are shaded blue, while linear containers are shaded pink.\protect\label{fig:fm-linear-simple}}
\end{figure}

\begin{figure}[t]
\vspace{-6pt}
\begin{center}
\mbox{}\psfig{figure=fm-after-linear.eps,width=2.5in}
\vspace{-6pt}
\caption{Final stream graph ({\tt after-linear.dot}) for the FMRadio, compiling with the {\tt -linearpartition} option.\protect\label{fig:fm-after-linear}}
\end{center}
\vspace{-14pt}
\end{figure}

The {\tt linearpartition} option to strc will enable linear analysis
and optimizations\footnote{In contrast, the {\tt linearreplacement}
and {\tt frequencyreplacement} options will perform maximal algebraic
simplification and frequency translation, respectively, even in cases
where it is not beneficial.}:
{\small
\begin{verbatim}
% strc -linearpartition FMRadio.str -o fm
Starting Kopi2SIR... done.
Entry to Cluster Backend (uniprocessor)
Running Constant Prop and Unroll... done.
Running Constant Field Propagation... done.
Estimating Code size of Filters... done.
Running linear analysis... 
WARNING: Assuming method call expression non linear(atan). 
         Also removing all field mappings.
done with linear analysis.
Running linear partitioner...
Linear partitioner took 0 secs to calculate partitions.
Estimating Code size of Filters... done.
Running Partitioning... target number of threads: 1
Done Partitioning...
Generating cluster code...
Done generating cluster code.
gcc34 -O3 -I/u/thies/research/streams/streams/library/cluster 
      -c -o combined_threads.o combined_threads.cpp
gcc34 -O3 -o fm combined_threads.o 
      -L/u/thies/research/streams/streams/library/cluster 
      -lpthread -lcluster -lstdc++ -lsrfftw -lsfftw
\end{verbatim}
} 
%
The linear analysis produces its own set of {\tt dot} files that we
can use to inspect the results of the optimizations.  For example, the
following command will display the stream graph with the linear
sections highlighted: {\small
\begin{verbatim}
% dotty linear-simple.dot
\end{verbatim}
} 
%
As shown in Figure~\ref{fig:fm-linear-simple}, FMRadio contains many
linear components, including the first LowPassFilter and the
equalizer.  To see the stream graph after linear optimizations have
been applied, we can issue the following command:
{\small
\begin{verbatim}
% dotty after-linear.dot
\end{verbatim}
} 
%
As illustrated in Figure~\ref{fig:fm-after-linear}, this stream
graph shows that the equalizer was collapsed into a single filter and
then was translated to the frequency domain (by virtue of the ``Freq''
prefix in the filter's name.)  However, the LowPassFilter at the top
was left unmodified; this is because it has a large pop rate that
degrades the performance of the frequency transformation.  In this
case, the linear optimizations lead to a 6.7X improvement in
throughput.

The linear optimizations produce additional {\tt dot} graphs; see
Figure~\ref{fig:dot-linear} for details.  For more information on the
linear analysis and optimization, please refer to {\tt http://cag.lcs.mit.edu/linear}.

\begin{figure}[t]
\vspace{-6pt}
{\small
\noindent \begin{tabular}{|l|l|}
\hline
{\bf Filename} & {\bf Description} \\
\hline
{\tt linear-simple.dot} & \entry{Stream graph with linear filters highlighted.}\\ \hline
{\tt linear.dot} & \entry{Same as linear-simple, but including I/O rates of each node.}\\ \hline
{\tt linear-partitions.dot} & \entry{Illustration of which nodes are combined by linear optimizations.} \\ \hline
{\tt after-linear.dot} & \entry{The stream graph after linear transformations are complete.} \\ \hline
\end{tabular}
}
\vspace{-5pt}
\caption{{\tt dot} graphs produced by linear optimizations.\protect\label{fig:dot-linear}}
\vspace{-5pt}
\end{figure}

\subsection{Compiling for a Cluster or Multicore}

The {\tt -cluster N} option selects a backend that compiles to N
parallel threads that communicate using sockets.  When targeting a
cluster of workstations, the sockets communicate over the network
using TCP/IP.  When targeting a multicore architecture, the sockets
provide an interface to shared memory.  A hybrid setup is also
possible, in which there are multiple machines and multiple threads
per machine; some threads communicate via memory, while others
communicate over the network.

\subsubsection{Multicores}

By default, the StreamIt compiler will map all of the threads to the
current host (i.e., the one that issued the compile command).  This is
suitable for multicores, as running the resulting executable will
spawn the threads on a single machine.

For example, consider compiling the FMRadio to eight parallel threads:
{\small
\begin{verbatim}
% strc -cluster 8 FMRadio.str -o fm
Starting Kopi2SIR... done.
Entry to Cluster Backend
Running Constant Prop and Unroll... done.
Running Constant Field Propagation... done.
Estimating Code size of Filters... done.
Estimating Code size of Filters... done.
Running Partitioning... target number of threads: 8
Running Partitioning... target number of threads: 8
  Found 0 tiles.
  Building stream config...
Trying 8 tiles.
  Calculating partition info...
  Tracing back...
  Work Estimates:
    Fused_SplitJoin0_EqSplit_81...      1545    (21%)
    Fused_SplitJoin0_EqSplit_81...      1545    (21%)
    Fused_SplitJoin0_EqSplit_81...      1545    (21%)
    Fused_SplitJoin0_EqSplit_81...      1545    (21%)
    LowPassFilter__13                   730     (10%)
    FMDemodulator__17                   221     (3%)
    Fused_Spl_Ano_Flo                   89      (1%)
    FloatOneSource__3                   35      (0%)
  Building stream config...
Trying 8 tiles.
  Calculating partition info...
  Tracing back...
Done Partitioning...
Generating cluster code...
NOTE: Missing or empty $STREAMIT_HOME/cluster-machines.txt file,
  so all threads assigned to cagfarm-49 in cluster-config.txt.
Done generating cluster code.
gcc34 -O3 -I/u/thies/research/streams/streams/library/cluster 
      -c -o combined_threads.o combined_threads.cpp
gcc34 -O3 -o fm combined_threads.o 
      -L/u/thies/research/streams/streams/library/cluster 
      -lpthread -lcluster -lstdc++
\end{verbatim}}

The compiler used a partitioning algorithm to fuse filters in the
graph down to eight load-balanced units.  The stream graph following this
partitioning can be found in {\tt after-partition.dot}:
{\small
\begin{verbatim}
% dotty after-partition.dot
\end{verbatim}}
The result appears in Figure~\ref{fig:after-partition}.  The array of
eight low-pass filters was collapsed to a width of four, and the
bottom half of the application (Subtracter, Amplify, Printer filters)
was fused into a single filter.  The other auto-generated files
provide more information about the distribution of work amongst these
filters; see Figure~\ref{fig:dot-cluster} for details.

\begin{figure}[t!]
{\small
\noindent \begin{tabular}{|l|l|}
\hline
{\bf Filename} & {\bf Description} \\
\hline
{\tt before-partition.dot} & \entry{Stream graph before partitioning into requested number of threads.} \\ \hline
{\tt after-partition.dot} & \entry{Stream graph after partitioning into requested number of threads.} \\ \hline
{\tt work-before-partition.dot} & \entrybig{The stream graph before partitioning, annotated with estimates of the steady-state work within each node.  Nodes with the same amount of work are given the same color (although the colors themselves are meaningless.)}\\ \hline
{\tt work-before-partition.txt} & \entry{Text listing of the work estimates for filters in the graph, before load balancing.}\\ \hline
{\tt work-after-partition.dot} & \entry{The stream graph after partitioning, annotated with work estimates as above.}\\ \hline
{\tt work-after-partition.txt} & \entry{Text listing of the work estimates for filters in the graph, after load balancing.}\\ \hline
{\tt work-estimate.txt} & \entry{Same as above, but indexed by the thread numbers in cluster-config.txt.}\\ \hline
{\tt cluster-config.txt} & \entry{Mapping from threads to machines.}\\ \hline
\end{tabular}
}
\vspace{-5pt}
\caption{Files produced by the cluster/multicore backend, above and beyond those produced by the uniprocessor backend.\protect\label{fig:dot-cluster}}
\vspace{-5pt}
\end{figure}

Running the {\tt fm} binary will spawn all eight threads on the
current host.

\begin{figure}[t]
\centering
\psfig{figure=fm-after-partition.eps,width=\textwidth}
\caption{The FMRadio example partitioned to eight threads ({\tt after-partition.dot}).\protect\label{fig:after-partition}}
\end{figure}

\subsubsection{Cluster of Workstations}

In order to compile for a cluster of workstations, one should create a
list of available machines and store it in the following location:
\begin{verbatim}
$STREAMIT_HOME/cluster-machines.txt
\end{verbatim}
This file should contain one machine name (or IP address) per line.
When the compiler generates N threads, it will assign one thread per
machine (for the first N machines in the file).  If there are fewer
than N machines available, it will distribute the threads across the
machines.

For example, consider that our {\tt cluster-machines.txt} file
contains the following:
{\small
\begin{verbatim}
machine-1
machine-2
machine-3
machine-4
\end{verbatim}}

Let's say that each machine is a dual-processor, so we again compile
FMRadio for eight threads as shown previously.  The resulting mapping
from threads to machines can be found in {\tt cluster-config.txt}:
{\small
\begin{verbatim}
% strc -cluster 8 FMRadio.str -o fm
...
% cat cluster-config.txt
0 machine-1
1 machine-1
2 machine-1
3 machine-2
4 machine-2
5 machine-2
6 machine-3
7 machine-3
8 machine-4
9 machine-4
\end{verbatim}}

This file indicates that threads 0, 1, and 2 are mapped to machine-1;
threads 3, 4, and 5 are mapped to machine-2, and so on.  The
cluster-config file contains 10 threads (rather than eight) because a
thread is also generated for each splitter and joiner in the stream
graph.  However, as these threads rarely do as much work as the
filters, it is not detrimental for a processor to acquire them.

To execute the program on the cluster, one should run the {\tt fm}
executable from each machine that is assigned one or more threads.
Each instance of the program will wait until all of its network
connections are established before starting to process data.  To
measure performance, a built-in timer keeps track of the elapsed time
after the connections are made.

As the cluster-config file is read at application load time, one can
freely modify it to experiment with various layouts or to move the
program from one cluster to another.  Mapping all the threads to a
single machine will have the same effect as compiling to a multicore
(as described previously).

\subsection{Using the Java Library}

A convenient aspect of the StreamIt compilation toolchain is that all
StreamIt programs are first translated to Java files that can be
executed against a Java runtime library using a normal Java Virtual
Machine.  This is especially useful for testing and debugging
applications, as well as validating the output of the compiler.

The library can be invoked with the {\tt -library} flag.  Since {\tt
strc} will both compile and execute the file in the library, you can
specify the number of iterations to execute with the {\tt -i} flag.
For example, to compile FMRadio and run for 5 iterations in the
library, do as follows\footnote{In this case, the library's output is
marginally different from the compiler's due to numerical precision
issues.}:
%
{\small
\begin{verbatim}
% strc -library -i 5 FMRadio.str
278073.94
278074.75
278075.38
278075.94
278076.4
\end{verbatim}
} 
%
You can also inspect the {\tt FMRadio.java} file, which was generated
for execution in the library.  It can be compiled and run with a
standard Java compiler and JVM.  The library also produces a {\tt dot}
graph of the program; it is given the same name as the StreamIt file,
but with a {\tt dot} extension ({\it i.e.,} it is {\tt FMRadio.dot} in
this case.)

There are a few additional options available in the library.  For
instance, you can direct the library not to execute the program, but
to instead just print the schedule of filter firings: \enlargethispage{1\baselineskip}
{\small
\begin{verbatim}
% strc -library -norun -printsched FMRadio.str
init = [
$0 = FloatOneSource@1.work
$1 = LowPassFilter@4.work
$2 = FMDemodulator@5.work
$3 = EqSplit@8.streamit.misc.Pair@1386000
$4 = BPFCore@16.streamit.misc.Pair@a470b8
$5 = BPFCore@24.streamit.misc.Pair@cdedfd
$6 = BPFCore@32.streamit.misc.Pair@116471f
$7 = BPFCore@40.streamit.misc.Pair@12558d6
$8 = { {379 $0} {64 $1} {63 $2} {63 $3} {63 $4} {63 $5} 
       {63 $6} {63 $7} }
]
steady = [
$9 = LowPassFilter@18.work
$10 = LowPassFilter@19.work
$11 = BPFCore@16.streamit.misc.Pair@18e2b22
$12 = Subtracter@17.work
$13 = Amplify@15.work
$14 = LowPassFilter@26.work
$15 = LowPassFilter@27.work
$16 = BPFCore@24.streamit.misc.Pair@bf2d5e
$17 = Subtracter@25.work
$18 = Amplify@23.work
$19 = LowPassFilter@34.work
$20 = LowPassFilter@35.work
$21 = BPFCore@32.streamit.misc.Pair@1ee3914
$22 = Subtracter@33.work
$23 = Amplify@31.work
$24 = LowPassFilter@42.work
$25 = LowPassFilter@43.work
$26 = BPFCore@40.streamit.misc.Pair@12a54f9
$27 = Subtracter@41.work
$28 = Amplify@39.work
$29 = EqSplit@8.streamit.misc.Pair@1662dc8
$30 = AnonFilter_a0@9.work
$31 = FloatPrinter@3.work
$32 = { {5 $0} $1 $2 $3 $4 $9 $10 $11 $12 $13 $5 $14 
        $15 $16 $17 $18 $6 $19 $20 $21 $22 $23 $7 
        $24 $25 $26 $27 $28 $29 $30 $31 }
]
!ml sched size = 39
!ml buff size = 1299
\end{verbatim}
%$
} 
%
Currently, the default scheduler is a minimal latency scheduler that
uses phases to compress the code size.  The schedule listed above has
two components: an initialization schedule (to initialize buffers for
filters that peek) and a steady-state schedule (that can loop
infinitely).  Each filter and splitter in the graph is given a number
for easy reference, and then the schedule is printed at the bottom.  A
loop nest in the schedule is denoted by {\tt (N F)}, where the filter
{\tt F} executes {\tt N} times.  The schedule size and buffer size
required are printed at the end of the listing.

Additional options for the library can be found in
Appendix~\ref{ap:options}.

\clearpage
