\section{Introduction}

We are approaching the juncture where transistors are essentially free
to the designer of a microprocessor.  Designers are now looking for
novel solutions to the wire delay problem. Recently the architecture
community has witnessed the ascendancy of communication-exposed
architectures, examples include Raw
\cite{raw, raw_isca}, SmartMemories \cite{smartmemories}, TRIPS \cite{trips},
WaveScalar \cite{wavescalar}, and RDR \cite{rdr}.  These
machines propose to solve the wire delay problem by replicating
processing units and exposing the interconnect between these units to
a software layer.  For these architectures to gain programmer
acceptance, there must exist a high-level, portable programming
language that can be compiled efficiently to any of the candidate
targets.  


A number of efforts have focused on stream programming as a paradigm
for producing high-level, efficient, and retargetable application code
for wire-exposed architectures \cite{streamit-asplos} (language refs).
In the past, imperative programming languages such as C and FORTRAN
served von-Neumann machines well.  They abstracted away the
idiosyncrasies of a machine while encapsulating the common properties
(such as a single program counter, arithmetic operations, and a
monolithic memory) that are necessary to obtain good performance.
However, for wire-exposed targets that contain multiple instruction
streams and distributed memory banks, a language such as C is
obsolete.  Unlike imperative languages, stream programming is a
natural choice for common idioms of emerging wire-exposed
architectures.

Hitherto, there existed two basic approaches for compiling a stream
program to a communication-exposed architecture.  {\it Time
multiplexing} utilizes the entire chip for each computation unit,
switching between these units over time.  Time multiplexing's efficacy
extends from its freedom from having to balance the workload between
nodes of the computation graph.  Negatively, this technique can lead
to long latencies, lots of memory traffic, and the utilization is
highly dependent upon how effectively each individual computation node
can be parallelized across the machine.

Conversely, {\it space multiplexing} distributes computation units
across the entire chip, running them continuously and in parallel.
Space multiplexing affords $(i)$ no filter swapping, $(ii)$ reduced
memory traffic, $(iii)$ localized communication, and $(iv)$ tighter
latencies.  Due to these properties space multiplexing scales
extremely well.  Unfortunately, this approach is highly dependent on
effective load balancing techniques.  Merging and splitting components
of a coarse-grained computation graph until it is composed of $n$ load
balanced nodes, where $n \le$ the number of processing elements, is
difficult, as the optimization technique is constrained by many
competing factors.

The approach outlined in this paper is to merge the advantages of
space multiplexing and time multiplexing.  This hybrid approach will
time multiplex different groups of filters and space multiplex the
filters within a group.  We call each group a {\it space-time trace}
or just a {\it trace}. Each trace can be considered an atomic
execution unit for scheduling.  Traces can be scheduled using
techniques traditionally limited to individual instructions in a given
loop nest (such as software pipelining). Our approach extends these
techniques to a coarser level of granularity across the whole program.
This technique provides the flexible load balancing of time
multiplexing, while preserving the locality and latency benefits of
space multiplexing.  Furthermore, one can recognize traces that can be
executed in a fine-grained, systolic fashion.  For example, our
compiler identifies traces that compute a linear function of their
inputs and produces parameterized, template assembly code for such
traces.

In this paper we present a compiler for the StreamIt programming
language \cite{streamitcc}.  StreamIt is a high-level stream
programming language that aims to be portable across next-generation
communication-exposed architectures.  StreamIt contains basic
constructs that expose the parallelism and communication of streaming
applications without depending on the topology or granularity of the
target architecture \cite{streamit-asplos}. In StreamIt the basic unit
of computation is a {\it filter}, a single-input, single-output block.
Filters are composed into a communication network using hierarchical,
structured constructs (introduced below).  A {\it stream graph},
composed of filters and uni-directional FIFO channels connecting the
filters, describes the resulting computation. The StreamIt compiler
currently targets the Raw microprocessor, a tiled architecture with
fine-grained, programmable communication between processors.

Neglecting the irrelevant initial passes, the flow of the compiler is
as follows.  The compiler reaches the space-time backend with a
structured, hierarchical stream graph, where all filters of the
application are explicitly represented.  We first convert this stream
graph into to a flat, non-hierarchical graph with unnecessary
communication channels removed.  Next, we identify the linear
sub-components of the stream graph.  Our compiler then extracts the
traces from the stream graph, considering the concurrency,
communication, layout, and type (linear or non-linear) of each filter.
Next, we schedule the traces, producing both a multi-stage initialization
schedule and a steady-state schedule.  Lastly, we generate both
communication and computation code for Raw.  The contributions of this
monograph include:
\begin{itemize}
\item An automated transformation of a structured stream graph into a
unstructured stream graph with unnecessary synchronization removed.
\item An algorithm for extracting traces from a stream graph.
\item Parameterized code generation for traces that compute a
linear function of their inputs.
\item A fully automated implementation of hybrid space-time
partitioning for Raw.
\end{itemize}

The remainder of this paper is organized as follows.  Section 
\ref{sec:streamit} gives an introduction to the StreamIt programming
language, Section \ref{sec:raw} provides an overview of Raw,...,
and Section \ref{sec:results} presents our results.  Section 
\ref{sec:related} considers related work and Section 
\ref{sec:conclusion} concludes the paper.


