\section{The StreamIt Language}
\label{sec:streamit}

StreamIt is a portable programming language for high-performance
signal processing applications.  The current version of StreamIt is
tailored for static-rate streams: it requires that the input and
output rates of each filter are known at compile time.  In this
section, we provide a very brief overview of the syntax and semantics
of StreamIt, version 2.0.  A more detailed description of the design
and rationale for StreamIt can be found in~\cite{streamitcc}, which
describes version 1.0; the most up-to-date syntax specification can
always be found on the StreamIt website~\cite{streamitweb}.

\subsection{Language Constructs}

The basic unit of computation in StreamIt is the {\it filter}.  A
filter is a single-input, single-output block with user-defined
procedures for translating input items to output items.  Each filter
contains an {\tt init} function that is called at initialization time
and a {\tt work} function that defines the most fine grained execution
step of the filter in the steady state.  Within the {\tt work}
function, the filter can communicate with its neighbors via FIFO
queues, termed {\it channels}, using the intuitive operations of {\tt
push(value)}, {\tt pop()}, and {\tt peek(index)}, where {\tt peek}
returns the value at position {\tt index} without dequeuing the item.
The number of items that are pushed, popped, and peeked on each
invocation are declared with the {\tt work} function.

There are three basic constructs for composing filters into a
communicating network: a {\it pipeline}, a {\it splitjoin}, and a {\it
feedbackloop}, see Figure \ref{fig:structures}.  A pipeline behaves as
the sequential composition of all its child streams, which are
specified with successive calls to {\tt add} from within the pipeline.
The {\tt add} statements can be mixed with regular imperative code to
parameterize the construction of the stream graph. A splitjoin is used
to specify independent parallel streams that diverge from a common
{\it splitter} and merge into a common {\it joiner}.  There are two
kinds of splitters: 1) $duplicate$, which replicates each data item
and sends a copy to each parallel stream, and 2) $roundrobin(w_1,
\dots, w_n)$, which sends the first $w_1$ items to the first stream,
the next $w_2$ items to the second stream, and so on. roundrobin is
also the only type of joiner that we support; its function is
analogous to a roundrobin splitter.

The last control construct provides a way to create cycles in the
stream graph: the feedbackloop.  Due to space constraints, we omit a
detailed discussion of the feedbackloop. From now on, we use the word
{\it stream} to refer to any instance of a filter, pipeline,
splitjoin, or feedbackloop.

\begin{figure}[t]
\begin{center}
\begin{minipage}{0.46in}
\centering
\psfig{figure=pipeline.eps,width=0.46in} \\
\end{minipage} 
~
\begin{minipage}{1.3in}
\centering
\psfig{figure=splitjoin.eps,width=1.3in} \\
\end{minipage}
~
\begin{minipage}{1.02in}
\centering
\psfig{figure=feedback.eps,width=1.02in} \\
\end{minipage} 
\\ ~ \\ {\bf \protect\small (a) A pipeline. ~~(b) A splitjoin. ~~(c) A feedbackloop.}
\caption{\protect\small Stream structures supported by StreamIt.
\protect\label{fig:structures}}
\end{center}
\end{figure}

\subsection{Linear Filters}
One far-reaching goal of the StreamIt project is to incorporate the
knowledge of expert DSP programmers into the compiler.  Toward that
end, the StreamIt compiler can recognize sections of the stream graph
that adhere to a certain model, apply targeted transformations and
optimizations, and generate specialized code for these sections.
Currently the StreamIt compiler can recognize {\it linear} sections of
a stream graph. We call a filter linear if its outputs can be
expressed as an affine combination of its inputs.  Many ubiquitous DSP
kernels are linear, including FIR filters, expanders, compressors,
DFTs and DCTs.  In \cite{streamit-linear} a completely automated
framework for extracting, combining, and transforming linear filters
in the StreamIt compiler is presented.  In this paper, linear
components of the stream graph are targeted for specialized code
generation (see Section \ref{sec:linear}).

