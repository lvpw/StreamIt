%% \begin{figure}
%% \centering
%% \psfig{figure=beam-graph.eps,width=3.2in}
%% \caption{Stream graph of the Radar Application consisting of 12
%% channels and 4 beams. The non-linear filters are colored black. 
%% \label{fig:beam-graph}}
%% \end{figure}

\section{Illustrating Example}
\label{sec:example}

As a concrete example of space-time multiplexing, we consider the case
of a simple target detector.  As shown in
Figure~\ref{fig:target-graph}, the target detector duplicates its
input using a splitjoin; each branch of the splitjoin contains a
matched filter (to consider signals in a given range) followed by a
threshold detector.  Our analysis detects that each matched filter
computes a linear function, making it eligible for specialized code
generation in the backend.

Figure~\ref{fig:target-exec} illustrates the execution sequence that
is generated by our compiler.  Each stage in the figure shows the
computation layout for a given time partition; these stages are
executed cyclically in the steady state.  The first stage implements
the duplicate splitter by distributing the input data to distinct
off-chip DRAMs.  Each of the next four stages executes one of the
matched filters, using linear code generation to spread the
computation in a systolic fashion across the entire chip.  Finally,
the last stage executes all of the threshold filters in parallel.

In our terminology, each filter in the target detector is assigned to
its own trace.  That is, in this application, there is never a case
where two filters form a load-balanced pipeline that could execute as
a single unit on the chip.  However, the compiler recognizes the
linear filters and implements them as a 16-element pipeline that fully
utilizes the programmable on-chip network.

In the case of this example, space-time multiplexing performs 7.8X
better than a pure space-multiplexing approach~\cite{streamit-asplos}.
The cause for this dramatic speedup is that each linear trace is
executed as an independent stage.  In this form, it can utilize
template assembly code in which the operation is parallelized across
all tiles, all values are held within the registers and each cycle is
carefully accounted for.  Space-time multiplexing provides the
flexibility for such fine-grained codes to interact with general
application components.

\begin{figure}[t]
\vspace{-18pt}
\centering
\psfig{figure=target_detect.eps,width=2.5in}
\vspace{-6pt}
\caption{Stream graph for a target detector.  Linear filters are indicated in gray.
\protect\label{fig:target-graph}}
\vspace{12pt}
\psfig{figure=td_execute.eps,width=4.5in}
\vspace{-6pt}
\caption{Execution sequence for the target detector.  Each stage
indicates the mapping from filters to Raw tiles during a given time
partition.  Temporary results are buffered in off-chip DRAMs.
\protect\label{fig:target-exec}}
\vspace{-8pt}
\end{figure}
