\section{Initialization Schedules}
\subsection{Peek Initialization Schedule}
The StreamIt compiler is responsible for the automatic scheduling of
the filters of the stream graph. In this context, we use the term
``scheduling'' to refer to the calculation of a steady-state schedule for
a stream graph composed of StreamIt filters.  Calculating a
steady-state schedule is orthogonal to trace scheduling. The
steady-state schedule is calculated before entry to the space-time
backend.  Calculating a steady-state schedule for a StreamIt stream
graph is complicated by the presence of the {\tt peek} operation which
implies that some programs require a separate schedule for
initialization that is distinct from the steady-state schedule.  We
call this stage the {\it peek initialization} stage and its schedule
of execution, the {peek initialization schedule}.

A more detailed discussion of the peek initialization schedule is
beyond the scope of this paper, see \cite{streamitcc} for a more
detailed discussion.  But it suffices to know that there is
need for a peek initialization schedule because the steady-state schedule
must be periodic, that is, it must preserve the number of live items on
each channel in the graph.  The peek initialization is needed if there
is a filter with $peek > pop$ because such a filter leaves $peek -
pop$ items on its input channel after every firing, and thus the
channel could never be emptied.  A separate schedule is needed to
place at least $peek - pop$ items in the input channel to such a filter.

The peek initialization schedule and the steady-state schedule are
both Single Appearance Schedules (SAS) meaning that each filter is
placed in a loop and appears exactly once in the schedule.  The number
of executions of a filter in a schedule is called its {\it
multiplicity} in later sections.  The natural execution order for both
the peek initialization schedule and the steady-state schedule is
given by a topological traversal of the stream graph. Of course, the
trace scheduling phase has some freedom in ignoring the
information-flow dependencies of the trace graph when constructing a
trace schedule, as the traces can be executing from different
iterations of the original program.  The prologue schedule (described
below) orchestrates initial executions so that the data dependences
are satisfied.

%It is the responsibility of the {\it Prologue Schedule} to ensure that the...

\subsection{Prologue Schedule}
\label{sec:prologue}
The prologue schedule is executed before the steady-state of the
application to make sure that each trace that is scheduled to execute
{\it before} its upstream neighbor has input to execute on the first
iteration in the steady-state.  The prologue schedule is calculated as
follows.  We iterate over the steady-state schedule of traces, $S$, as
calculated by the trace scheduler.  For each trace $t$, first set
$\mt{t.prologue} = 0$ (where $\mt{t.prologue}$ represents the
multiplicity of $\mt{t}$ in the prologue schedule).  Then, for each
trace, in the order in which they are scheduled, call {\tt
incrementUpstream(}$t${\tt,}$S${\tt )} as listed below.

\begin{algorithm}
\caption{IncrementUpstream} \label{alg:incrementUpstream} {\tt
incrementUpStream(}$t${\tt ,}$S${\tt )}. Given a trace $t$, and a
trace schedule $S$ that allows us to query whether a trace is
scheduled before another trace, and $\mt{upstream}(t)$ are the
upstream neighbors of $t$ in the trace graph:
\begin{algorithmic}
\FORALL {$u \in \mt{upstream}(t)$}
\IF {$u$ scheduled before $t$ in $S$}
\STATE $u.prologue = t.prologue$
\ELSE
\STATE $u.prologue = t.prologue + 1$ 
\ENDIF 
\STATE {\tt incrementUpStream(}$u${\tt ,}$S${\tt )}
\ENDFOR
\end{algorithmic}
\end{algorithm}

For each trace $t$, {\tt incrementUpstream()} makes sure that $t$ has
enough items to fire by setting the prologue multiplicity of its
upstream filters equal to itself if $t$ is scheduled after its
upstream filters.  If $t$ is scheduled before its upstream traces, set
the multiplicity of the upstream traces to $t$'s prologue multiplicity
plus 1.  This is done so $t$ can fire before its upstream neighbors
for the first iteration of the steady-state.  Then the function
recursively calls itself to make sure that $t$'s upstream neighbors
can fire enough times to feed $t$.
