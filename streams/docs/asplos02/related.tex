\section{Related Work}
\label{sec:related}

The Transputer architecture~\cite{transputer88} shares many
similarities with Raw.  A Transputer system is either an array or a
grid of tiles, where neighbors are interconnected with unbuffered
point-to-point links. The programming language used for the Transputer
is Occam \cite{occammanual}: a streaming language similar to CSP
\cite{Hoare78}.  However, unlike StreamIt filters, Occam concurrent
processes are not statically load-balanced, scheduled and bound to a
processor. Occam processes are run off a very efficient runtime
scheduler implemented in microcode~\cite{may87communicating}.

DSPL is a language with simple filters interconnected in a flat acyclic
graph using unbuffered channels~\cite{Thiel93}.  Unlike the Occam
compiler for the Transputer, the DSPL compiler automatically maps the
graph into the available resources of the Transputer. The DSPL language
does not expose a cyclic schedule, thus the compiler models the
possible executions of each filter to determine the possible cost of
execution and the volume of communication. It uses a search technique
to map multiple filters onto a single processor for load balancing and
communication reduction. 

The Imagine architecture is specifically designed for the streaming
application domain~\cite{rixner98bandwidthefficient}.  It operates on
streams by applying a computation kernel to multiple data items off
the stream register file.  The compute kernels are written in Kernel-C
while the applications stitching the kernels are written in Stream-C.
Unlike StreamIt, with Imagine the user has to manually extract the
computation kernels that fit the machine resources in order to get
good steady state performance for the execution of the
kernel~\cite{kapasi:2001:ss}.  On the other hand, StreamIt uses
fission and fusion transformations to create load-balanced computation
units and filters are replicated to create more data parallelism when
needed.  Furthermore, the StreamIt compiler is able to use global
knowledge of the program for layout and transformations at
compile-time while Stream-C interprets each basic block at runtime and
performs local optimizations such as stream register allocation in
order to map the current set of stream computations onto Imagine.

The iWarp system \cite{iwarp} is a scalable multiprocessor with
configurable communication between nodes.  In iWarp, one can set up
FIFO channels for communicating between non-neighboring tiles.
However, reconfiguring the communication channels is more
coarse-grained and has a higher cost than on Raw, where each cycle can
be route items to a different location.  ASSIGN \cite{assign} is a
tool for building large-scale applications on multiprocessors,
especially iWarp.  ASSIGN starts with a coarse-grained flow graph that
is written as fragments of C code.  Like StreamIt, it performs
partitioning, placement, and routing of the nodes in the graph.
However, ASSIGN is implemented as a runtime system instead of a full
language and compiler such as StreamIt.  Consequently, it has fewer
opportunities for global transformations such as fission and
reordering.

A large number of programming languages have included a concept of a
stream; see \cite{survey97} for a survey. However, the compilers for
these languages have focused only on efficient sequential execution of
the program.
