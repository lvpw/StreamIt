\section{Compiling StreamIt to Raw}
\label{sec:phases}

\begin{table}[t]
\begin{center}
\scriptsize
\begin{tabular}{|l|l|} \hline
{\bf Phase} & {\bf Function} \\
\hline \hline
KOPI Front-end & Parses syntax into a Java-like abstract syntax tree. \\
\hline
SIR Conversion & Converts the AST to the StreamIt IR (SIR). \\
\hline
Graph Expansion & Expands all parameterized structures in the stream graph. \\
\hline
Scheduling & Calculates initialization and steady-state execution orderings for filter firings. \\
\hline
Partitioning & Performs fission and fusion transformations for load balancing. \\
\hline
Layout & Determines minimum-cost placement of filters on grid of Raw tiles. \\
\hline
Communication Scheduling & Orchestrates fine-grained communication between tiles via simulation of the stream graph. \\
\hline
Code generation & Generates code for the tile and switch processors. \\
\hline
\end{tabular}
\vspace{-6pt}
\caption{\protect\small Phases of the StreamIt compiler.
\label{tab:phases}}
\vspace{-12pt}
\end{center}
\end{table}

The phases of the StreamIt compiler are described in
Table~\ref{tab:phases}.  The front end is built on top of KOPI, an
open-source compiler infrastructure for Java~\cite{kopi}.  We
translate the KOPI syntax tree into the StreamIt IR (SIR) that
encapsulates the hierarchical stream graph.  Since the structure of
the graph might be parameterized, we propagate constants and expand
each stream construct to a static structure of known extent.  At this
point, we can calculate an execution schedule for the nodes of the
stream graph.

The automatic scheduling of the stream graph is one of the primary
benefits that StreamIt offers, and the subtleties of scheduling and
buffer management are evident throughout all of the following phases
of the compiler.  The scheduling is complicated by StreamIt's support
for the {\tt peek} operation, which implies that some programs require
a separate schedule for initialization and for the steady state.  The
steady state schedule must be periodic--that is, its execution must
preserve the number of live items on each channel in the graph (since
otherwise a buffer would grow without bound.)  A separate
initialization schedule is needed if there is a filter with $peek >
pop$, by the following reasoning.  If the initialization schedule were
also periodic, then after each firing it would return the graph to its
initial configuration, in which there were zero live items on each
channel.  But a filter with $peek > pop$ leaves $peek-pop$ (a positive
number) of items on its input channel after {\it every} firing, and
thus could not be part of this periodic schedule.  Therefore, the
initialization schedule is separate, and non-periodic.

In the StreamIt compiler, the initialization schedule is constructed
via symbolic execution of the stream graph, until each filter has at
least $peek-pop$ items on its input channel.  For the steady state
schedule, there are many tradeoffs between code size, buffer size, and
latency, and we are developing techniques to optimize different
metrics \cite{streamittech2}.  In this paper, we use a simple
hierarchical scheduler that constructs a Single Appearance Schedule
(SAS) \cite{leesdf} for each filter.  An SAS is one where each node
appears exactly once in the loop nest denoting the schedule.  We
construct one such loop nest for each hierarchical stream construct,
such that each component is executed a set number of times for every
execution of its parent.  In later sections, we refer to the
``multiplicity'' of a filter as the number of times that it executes
in one steady state execution of the entire stream graph.

Following the scheduler, the compiler has stages that are specific for
communication-exposed architectures: partitioning, layout, and
communication scheduling.  The next three sections of the paper are
devoted to these phases.



