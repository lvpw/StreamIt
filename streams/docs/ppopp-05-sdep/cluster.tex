\section{Cluster Backend}

The cluster backend compiles the StreamIt code to a set of threads
that can be executed on a single computer or a networked cluster. In
order to exchange data threads establish TCP/IP connections. A set of
connections is created that represents the flow of data between
filters, splitters and joiners. A separate set of connections is
established between message sender and message receivers in each
portal.

The connections between message sender and receivers are used for both
transmitting the messages and also for sending credits. Credits
represent the number of iterations that a filter is allowed to execute
and this enforces that messages can be executed at given latency.

If a message is sent following data is written to a socket:

{\scriptsize
\begin{verbatim}
int size; // size of message in bytes, including size field
int index; // index of message handler
int iteration_to_execute_at; // target iteration number or
                             // -1 for best effort messages 
int and float parameters;
\end{verbatim}}

Examples:

{\scriptsize
\begin{verbatim}
(16, 0, -1, 1000)
\end{verbatim}}

A best effort message for handler Nr. 0 with one integer parameter set
to 1000.

{\scriptsize
\begin{verbatim}
(16, 0, 8, 1000)
\end{verbatim}}

A message for handler Nr. 0 that has to be executed before its work
function is invoked 8th time. The Message has one integer parameter equal
to 1000.

If a credit is being sent following data is written to a socket:

{\scriptsize
\begin{verbatim}
int -1; 
int credit; 
\end{verbatim}}

Example:


{\scriptsize
\begin{verbatim}
(-1, 8)
\end{verbatim}}

Node can execute only up to first 8 iterations before receiving additional credit.

To calculate the iteration at which to execute the message $\sdep$
function is embedded into the code for the thread sending the
message. Any $\sdep$ function value can be calculated from few
parameters and $\sdep$ values during the first steady state cycle.

Currently in cluster backend each message is scheduled exactly at the 
latest possible
latency and the rest of latency information is discarded. Taking the
latency interval into account would allow creation of a more efficient
schedule for sending credit messages.

If a message is being sent downstream at a negative maximum latency 
or is being sent upstream with a positive maximum latency
then one needs to coordinate the execution of filters by sending
credits to the message receiver threads. Nodes that are receiving 
credits can only execute up to the maximum credit they have received so far.

In the case of a message being sent downstream with negative latency,
$\sdep$ funcition is used to compute following information during compile 
time:

\begin{enumerate}
\item Number of iterations the upstream message sender can execute before sending any credits,
\item The schedule of sending credits during the first steady state cycle after the initial iterations described in 1.
\end{enumerate}

We use the information about credits to send during the first steady state 
cycle to figure out the number of credits to send during subsequent steady
state cycles. This data is embedded into the message sender thread.

In the case of a message being sent upstream, 
the $\sdep$ funcition is used to compute following information during compile 
time:

\begin{enumerate}
\item The initial credit that downstream node sends during initialization,
\item The schedule of sending credits during the first steady state cycle.
\end{enumerate}

We use the information about credits to send during the first steady state 
cycle to figure out number of credits to send during subsequent steady
cycles. This data is embedded into the message sender thread.
