\section{Introduction}


Applications that are structured around streams of data pervade common
computing  practices,  and  there  is evidence  that  streaming  media
applications already consume a substantial fraction of the computation
cycles    on    consumer   machines~\cite{Rix98}.
Examples  of streaming  workloads  can be  found  in embedded  systems
(e.g., sensor nets and mobile  phones), as well as in desktop machines
(e.g., networking, and  multimedia) and high-performance servers (e.g.,
HDTV editing consoles and hyper-spectral imaging). 

The performance of streaming applications is evermore critical, and
programmers often sacrifice the readability, robustness, and
maintainability of their code in order to deliver high-performance
implementations.  One especially difficult aspect of stream
programming---that commands considerable and tedious attention---is
the reconciliation of regular streaming data flow with irregular
control messages. Consider for example a frequency hopping radio (FHR)
which mirrors how CDMA-based cell phone technology works.  In FHR, a
transmitter and a receiver change between a set of known radio
frequencies, and they must do so in synchrony with respect to a stream
boundary. That is, a receiver must change its radio frequency at an
exact point in the stream (as indicated by the transmitter) in order
to follow the incoming signal.  Such a receiver is challenging to
implement in a distributed environment because different processors
might be responsible for the radio frontend and the frequency hop
detection.  When a frequency hop is detected, the detector must send a
message to the frontend that is timed precisely with respect to the
data stream, even though the two components are running on different
processors with independent clocks.

%% In  this  paper, we focus on the 
%% computation paradigm embodied by Synchronous  Dataflow~\cite{LM87-i},
%% a popular  model  that  is well suited for  streaming codes.  
%% In this model, computation is represented  as a structured graph consisting
%% of {\it actors} connected by communication channels.

Our contributions are two-fold, and they are geared toward improving
the programming model for stream programming. First, we  define a
stream dependence function, $\sdep$, 
% which describes the
% ordering constraints of actor firings in an SDF graph.  This
% dependence information is similar to a program slice, which has a rich
% body of work surrounding it~\cite{hrb88pdg,pugh97slice,tip95slice}.
% Like program slicing, $\sdep$ can also facilitate debugging and
% program analysis.  However, unlike program slicing, one can leverage
% the static properties of SDF 
to  provide   an  exact,  complete,  and   compact  representation  of
dependencies between stream processing components.  
Second,  we define  {\it  teleport messaging}  as a  novel language
construct  to provide  simple  and precise  handling of control
messages between actors in stream
programs.
% Our work  is presented  in the context  of Synchronous  Dataflow (SDF)
% which  is a popular  model of  computation~\cite{LM87-i} that  is well
% suited for  streaming codes. In  SDF, computation is represented  as a
% graph consisting of {\it  actors} connected by communication channels;
% the actors consume  and produce a constant number  of items from their
% input and output  channels every time they execute.   SDF is appealing
% because it is ameable to static scheduling and optimization.
% However, the challenge
% comes when there is a dynamic, unpredictable event in the stream; for
% instance, an actor detects a low signal-to-noise ratio and sends a
% signal to the frontend to increase the amplification.  How should the
% control message be delivered?  The problem is further complicated when
% there is a constraint on the timing of the message.  With the abundant
% parallelism in stream programs, how can concurrent actors have a
% common frame of reference with respect to time?
The semantics of teleport  messaging are formalized using $\sdep$, and
we argue  that it is  a  significant  improvement  over  existing
programming practices. Specifically, we describe a case study of
a frequency  hopping radio using  a fully automatic  implementation of
teleport messaging  as   part  of   the   StreamIt   compiler
infrastructure~\cite{streamit-asplos,  streamitcc}. Our implementation
of FHR  in StreamIt using teleport  messaging is 49\%  faster than its
counterpart which does not use messaging. This is preliminary evidence
that
% with a backend that targets a cluster of workstations.  We demonstrate
% an average speedup of 48\% over StreamIt programs that do not utilize
% the messaging feature.  As a result, we believe that 
the $\sdep$  formalism and language support for  messaging enables the
simultaneous improvement of both programmability and performance.

The rest of this paper is organized as follows.  Section~\ref{sec:modelofcomp} describes
our model of computation, Section~\ref{sec:sdep} 
define the stream dependence function, and Section~\ref{sec:calc-sdep}
shows how to calculate it
efficiently.  Section~\ref{sec:language} describes our language support for precise
event handling, including a case study and implementation results.
Other applications for $\sdep$ appear in
Section~\ref{sec:others-apps}, related work in
Section~\ref{sec:related-work}, and conclusions in
Section~\ref{sec:conclusion}.


%% This paper makes two contributions towards this goal.  First, we
%% formulate a stream dependence function, $\sdep$, which describes the
%% ordering constraints of node executions in a concurrent stream graph.
%% This dependence information is similar to a program
%% slice~\cite{tip95slice,hrb88pdg} in procedural programs and carries
%% with it many of the applications of slicing, including debugging and
%% program analysis.  However, unlike slicing, we restrict our input
%% domain to a Synchronous Dataflow (SDF) ~\cite{LM87-i} graph, which is
%% a natural representation for many signal processing applications.  We
%% leverage the static properties of SDF to compute $\sdep$ exactly at
%% compile time and to store the dependence information compactly.

%% The second contribution of this paper is a novel language construct
%% that uses $\sdep$ to provide simple and precise event handling in
%% stream programs.  In addition to the high-bandwidth data flow of
%% streaming applications, there are also low-bandwidth control messages
%% that adjust parameters in the stream graph; for example, toggling the
%% gain to suite the signal-to-noise ratio, or steering a microphone
%% array to follow a moving target.  Control messages are dynamic and
%% irregular, which makes them hard to integrate with a Synchronous
%% Dataflow model.  Most of all, they often have a constraint on the
%% timing of their delivery, which further complicates the programming
%% model because concurrent actors have no common frame of reference with
%% respect to time.
				   
%% We define a messaging construct that utilizes data dependences 
