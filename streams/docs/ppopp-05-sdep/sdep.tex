\newcommand{\la}{$\leftarrow$}
\newcommand{\IND}{\begin{ALC@g}}
\newcommand{\UND}{\end{ALC@g}}
\newcommand{\tup}[2]{\langle{#1}, {#2}\rangle}

\section{Stream Dependence Function}

In this section, we describe our model of computation for streams and
define the stream dependence function, $\sdep$.

Our model of computation is Cyclo-Static Dataflow~\cite{BELP96}.  In
this model, the stream graph is a directed graph where nodes represent
actors and edges represent FIFO communication channels.  Each actor
has a set of execution steps, or phases, which consume some items from
the input channels and produce some items on the output channels.  The
number and ordering of phases is known at compile time, and their
execution is cyclic (after executing the last phase, the first phase
is executed again).  Also, for each phase, the number of items
produced and consumed from the channels is fixed and known at compile
time.
%We also permit actors to ``peek'' at items that are not
%consumed from the channel, and the peek amount is known at compile
%time (note that peeking is not part of CSDF).
Cyclo-Static Dataflow is a generalization of Synchronous
Dataflow~\cite{LM87-i}, which requires each actor to have only a
single phase.

An exection $\phi$ of a dataflow graph is an ordered sequence of actor
firings.  Each firing represents the execution of a single phase of
the actor.  Let $\phi[i]$ denote the $i$th actor appearing in
execution $\phi$, and let $|\phi \wedge A|$ denote the number of times
that actor $A$ appears in $\phi$.  An execution is legal if the
dataflow requirements are respected; that is, for all $i$, the
sequential firing of actors $\phi[0]$ through $\phi[i-1]$ leaves
enough items on the communication channels for $\phi[i]$ to fire its
next phase atomically.  Let $\Phi$ denote the set of legal executions.
Note that while $\Phi$ is an infinite set, each $\phi \in \Phi$ is a
finite sequence.

The stream dependence function, $\sdep$, describes the dependences
between actor firings in the graph.  Informally, $\sdepf{A}{B}(n)$
represents the minimum number of times that actor $A$ must execute to
make it possible for actor $B$ to execute $n$ times.  This dependence
is meaningful only if there is a directed path in the stream graph
from $A$ to $B$; otherwise, $\sdep$ will have a value of zero.
Because the I/O rates of each actor in the stream graph are known at
compile time, $\sdep$ is also a static relation.  The following is a
formal definition of $\sdep$ using the notations from above:
\begin{definition}(SDEP)
\begin{center}
$\sdepf{A}{B}(n)~~ = ~~\mbox{MIN}~~|\phi \wedge A|$ \\
~~~~~~~~~~~~~\raisebox{5pt}[0pt]{$~_{\phi \in \Phi, |\phi \wedge B| = n}$}
\label{eq:sdepdef}
\end{center}
\end{definition}
This equation reads: over all legal executions in which $B$ fires $n$
times, $\sdepf{A}{B}(n)$ is the minimum number of times that $A$
fires.  An example of $\sdep$ for the stream graph in
Figure~\ref{fig:sdep-rates} appears in Figure~\ref{fig:sdep1}.

\begin{figure}[t]
\begin{center}
\psfig{figure=sdep-example-rates3.eps,height=1.5in}
\caption{{\small Example stream graph. Nodes are annotated with their
I/O rates; nodes A and E have two phases. \protect\label{fig:sdep-rates}}}
\end{center}
\vspace{-12pt}
\end{figure}

\begin{figure*}[t]
\begin{center}
\psfig{figure=sdep-example3.eps,width=7in}
\caption{\small Example \figsdep\ calculation for stream graph in
Figure~\ref{fig:sdep-rates}.  The stream graphs illustrate a steady
state cycle of a ``pull schedule''; execution proceeds from left to
right, and channels are annotated with the number of items present.
Because a pull schedule is as fine-grained as possible,
$\figsdepf{X}{Y}(n)$ can be calculated as the number of times that $X$
executes before the $n$th execution of $Y$.
\protect\label{fig:sdep1}}
\end{center}
\vspace{-12pt}
\end{figure*}

\section{Calculating SDEP}

It is straightforward to calculate $\sdepf{A}{B}(n)$ via a
fine-grained simulation of the stream graph.  Our approach is to
construct an execution $\phi$ that provides the minimum value of
$|\phi \wedge A|$ that is selected in Equation~\ref{eq:sdepdef}.  We
construct $\phi$ by simulating a ``pull schedule'' of the stream
graph.
%% \begin{definition}(Pull schedule)
%% An execution $\phi$ follows a {\it pull schedule} at position $i$ if,
%% for all actors $A \ne \phi[i]$:
%% \[
%% A~\mbox{is unable to fire at time i} ~\vee~ {\cal L}(A) \ge {\cal L}(\phi[i])
%% \]
%% where ${\cal L}(A)$ denotes the shortest acyclic path in the stream
%% graph from a source node (a node that consumes no items) to the actor
%% $A$.  An execution $\phi$ is a push schedule if the above property
%% holds for all $i$.
%% \end{definition}

Intuitively, a pull schedule is one that executes nodes only on
demand, propagating the demand upwards through the stream graph.  This
results in a fine-grained interleaving of filter firings.  The
following theorem allows us to use a pull schedule to calculate the
$\sdep$ function.
\begin{theorem}  If $\phi$ is a pull schedule and $B$ is the last element 
of $\phi$, then $|\phi \wedge A| = \sdepf{A}{B}(|\phi \wedge B|)$.
\end{theorem}
\begin{proof}
\end{proof}

naive calculation.

steady state repetition.

reference to figure.

The result of sdepTable should be cached for quick lookups with SDEP.

%% {\scriptsize
%% \begin{verbatim}
%% int SDEP_{A<-B} (n) {
%%   if no path from A to B in G then
%%     return 0
%%   else 
%%     countA = 0
%%     countB = 0
%%     do {
%%       child <- most downstream actor of G that can fire
%%       simulatePhase(child)
%%       if child = A then
%%         countA++;
%%       else if child = B then
%%         countB++;
%%       endif
%%     } loop until (countB = n)
%%   endif
%%   return countA
%% }
%% \end{verbatim}}

%% \begin{figure}[t]
%% {\scriptsize
%% \begin{verbatim}
%% int SDEP_{A<-B} (n) {
%%   if (n <= 0) || (no path from A to B in G) then
%%     return 0
%%   else
%%     cycles = floor(steady(B) / (n-1))
%%     return cycles * steady(A) + steadySDEP_{A<-B}[(n-1) mod steady(B)]
%%   endif
%% }

%% int[] steadySDEP_{A<-B} {
%%   SDEP = { }
%%   countA = 0
%%   do {
%%     child <- most downstream actor of G that can fire
%%     simulatePhase(child)
%%     if child = A then
%%       countA++
%%     else if child = B then
%%       SDEP = SDEP o countA
%%     endif
%%   } loop until |SDEP| = steady(B)
%%   return SDEP
%% }
%% \end{verbatim}}
%% \vspace{-12pt}
%% \caption{\small Algorithm for computing $\figsdepf{A}{B}$ in a
%% dataflow graph $G$.  Because $\figsdep$ information is cyclic, a
%% simulation of a single steady state (the $\mt{steadySDEP}$ table) is
%% sufficient to answer all $\figsdep$
%% queries. \protect\label{fig:sdep1}}
%% \end{figure}

\begin{figure}[t]
{\scriptsize
\begin{verbatim}
int SDEP_{A<-B} (n) {
  if (n <= 0) || (no path from A to B in G) then
    return 0
  else
    cycles = floor(steady(B) / (n-1))
    return cycles * steady(A) + steadySDEP_{A<-B}[(n-1) mod steady(B)]
  endif
}

global targetCount;
global targetActor;
int[] steadySDEP_{A<-B} {
  SDEP = { }
  targetActor = A
  targetCount = 0
  for i = 1 to steady(B)
    pullSchedule(B)
    SDEP = SDEP o { countTarget }
  endfor
  return SDEP
}

pullSchedule(X) {
  for all input channels c_i of X
    while X needs more items on c_i for next phase
      pullSchedule(source(c_i))
  simulatePhase(X)
  if X=targetActor then
    targetCount++
  endif
}
\end{verbatim}}
\vspace{-12pt}
\caption{\small Algorithm for computing $\figsdepf{A}{B}$ in a
dataflow graph $G$.  Because $\figsdep$ information is cyclic, a
simulation of a single steady state (the $\mt{steadySDEP}$ table) is
sufficient to answer all $\figsdep$
queries. \protect\label{fig:sdep1}}
\end{figure}

\todo{Correct pseudocode to handle initialization.}

%% reference code to borrow from to get the init/steady phases right:

%% int SDEP_{A<-B} (n) {
%%   if no path from A to B in G then
%%     return 0
%%   else
%%     <sdepInit, sdepSteady> = sdepTable(A,B)
%%     if n<|sdepInit| then
%%       return sdepInit[n]
%%     else
%%       nAfterInit = n - |sdepInit|
%%       cycles = floor(steady(B) / nAfterInit)
%%       return cycles * steady(A) + sdepSteady[nAfterInit mod steady(B)]
%%     endif
%%   endif
%% }

%% <int[], int[]> sdepTable(A,B) {
%%   sdepInit = { 0 }
%%   sdepSteady = { }
%%   countA = 0
%%   countB = 0
%%   do {
%%     child <- most downstream actor of G that can fire
%%     simulatePhase(child)
%%     if child = A then
%%       countA++
%%     else if child = B then
%%       if (countB<init(B) || countA<init(A)) then
%%         sdepInit = sdepInit o countA
%%       else
%%         sdepSteady = sdepSteady o countA
%%       endif
%%       countB++
%%     endif
%%   } loop until |sdepSteady| = steady(B)
%%   return <sdepInit, sdepSteady>
%% }
