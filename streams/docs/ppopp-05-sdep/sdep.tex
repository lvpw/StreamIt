\newcommand{\la}{$\leftarrow$}
\newcommand{\IND}{\begin{ALC@g}}
\newcommand{\UND}{\end{ALC@g}}
\newcommand{\tup}[2]{\langle{#1}, {#2}\rangle}

\section{Stream Dependence Function}

In this section, we describe our model of computation for streams and
define the stream dependence function, $\sdep$.

Our model of computation is Cyclo-Static Dataflow~\cite{BELP96}.  In
this model, the stream graph is a directed graph where nodes represent
actors and edges represent FIFO communication channels.  Each actor
has a set of execution steps, or phases, which consume some items from
the input channels and produce some items on the output channels.  The
number and ordering of phases is known at compile time, and their
execution is cyclic (after executing the last phase, the first phase
is executed again).  Also, for each phase, the number of items
produced and consumed from the channels is fixed and known at compile
time.
%We also permit actors to ``peek'' at items that are not
%consumed from the channel, and the peek amount is known at compile
%time (note that peeking is not part of CSDF).
Cyclo-Static Dataflow is a generalization of Synchronous
Dataflow~\cite{LM87-i}, which requires each actor to have only a
single phase.

An exection $\phi$ of a dataflow graph is an ordered sequence of actor
firings.  Each firing represents the execution of a single phase of
the actor.  Let $\phi[i]$ denote the $i$th actor appearing in
execution $\phi$, and let $|\phi \wedge A|$ denote the number of times
that actor $A$ appears in $\phi$.  An execution is legal if the
dataflow requirements are respected; that is, for all $i$, the
sequential firing of actors $\phi[0]$ through $\phi[i-1]$ leaves
enough items on the communication channels for $\phi[i]$ to fire its
next phase atomically.  Let $\Phi$ denote the set of legal executions.
Note that while $\Phi$ is an infinite set, each $\phi \in \Phi$ is a
finite sequence.

The stream dependence function, $\sdep$, describes the dependences
between actor firings in the graph.  Informally, $\sdepf{A}{B}(n)$
represents the minimum number of times that actor $A$ must execute to
make it possible for actor $B$ to execute $n$ times.  This dependence
is meaningful only if there is a directed path in the stream graph
from $A$ to $B$; otherwise, $\sdep$ will have a value of zero.
Because the I/O rates of each actor in the stream graph are known at
compile time, $\sdep$ is also a static relation.  The following is a
formal definition of $\sdep$ using the notations from above:
\begin{definition}(SDEP)
\begin{center}
$\sdepf{A}{B}(n)~~ = ~~\mbox{MIN}~~|\phi \wedge A|$ \\
~~~~~~~~~~~~~\raisebox{5pt}[0pt]{$~_{\phi \in \Phi, |\phi \wedge B| = n}$}
\label{eq:sdepdef}
\end{center}
\end{definition}
This equation reads: over all legal executions in which $B$ fires $n$
times, $\sdepf{A}{B}(n)$ is the minimum number of times that $A$
fires.  An example of $\sdep$ for the stream graph in
Figure~\ref{fig:sdep-rates} appears in Figure~\ref{fig:sdep1}.

\begin{figure}[t]
\begin{center}
\psfig{figure=sdep-example-rates.eps,height=1.5in}
\caption{{\small Example stream graph. Nodes are annotated with their
I/O rates; node D has two phases. \protect\label{fig:sdep-rates}}}
\end{center}
\vspace{-12pt}
\end{figure}

\begin{figure*}[t]
\begin{center}
\begin{tabular}{lcr}
\psfig{figure=sdep-example1.eps,width=7in}
\end{tabular}
\caption{\small Example \figsdep\ calculation for stream graph in
Figure~\ref{fig:sdep-rates}.  The stream graphs illustrate a steady
state cycle of a ``push schedule''; execution proceeds from left to
right, and channels are annotated with the number of items present.
Because a push schedule is as fine-grained as possible,
$\figsdepf{A}{B}(n)$ can be calculated as the number of times that $A$
executes before the $n$th execution of $B$.
\protect\label{fig:sdep1}}
\end{center}
\vspace{-12pt}
\end{figure*}

\section{Calculating SDEP}

It is straightforward to calculate $\sdepf{A}{B}(n)$ via a
fine-grained simulation of the stream graph.  Our approach is to
construct an execution $\phi$ that provides the minimum value of
$|\phi \wedge A|$ that is selected in Equation~\ref{eq:sdepdef}.  We
construct $\phi$ by simulating a ``push schedule'' of the stream
graph.
\begin{definition}(Push schedule)
An execution $\phi$ follows a {\it push schedule} at position $i$ if,
for all actors $A \ne \phi[i]$:
\[
A~\mbox{is unable to fire at time i} ~\vee~ {\cal L}(A) \ge {\cal L}(\phi[i])
\]
where ${\cal L}(A)$ denotes the shortest acyclic path in the stream
graph from a source node (a node that consumes no items) to the actor
$A$.  An execution $\phi$ is a push schedule if the above property
holds for all $i$.
\end{definition}
Intuitively, a push schedule is one that always executes the most
downstream node possible.  This results in a fine-grained interleaving
of filter firings.  The following theorem allows us to use a push
schedule to calculate the $\sdep$ function.
\begin{theorem}  If $\phi$ is a push schedule and $B$ is the last element 
of $\phi$, then $|\phi \wedge A| = \sdepf{A}{B}(|\phi \wedge B|)$.
\end{theorem}
\begin{proof}
This is actually FALSE.
\end{proof}

naive calculation.

steady state repetition.

reference to figure.

The result of sdepTable should be cached for quick lookups with SDEP.

%% {\scriptsize
%% \begin{verbatim}
%% int SDEP_{A<-B} (n) {
%%   if no path from A to B in G then
%%     return 0
%%   else 
%%     countA = 0
%%     countB = 0
%%     do {
%%       child <- most downstream actor of G that can fire
%%       simulatePhase(child)
%%       if child = A then
%%         countA++;
%%       else if child = B then
%%         countB++;
%%       endif
%%     } loop until (countB = n)
%%   endif
%%   return countA
%% }
%% \end{verbatim}}

\begin{figure}[t]
{\scriptsize
\begin{verbatim}
int SDEP_{A<-B} (n) {
  if (n <= 0) || (no path from A to B in G) then
    return 0
  else
    cycles = floor(steady(B) / (n-1))
    return cycles * steady(A) + steadySDEP_{A<-B}[(n-1) mod steady(B)]
  endif
}

int[] steadySDEP_{A<-B} {
  SDEP = { }
  countA = 0
  do {
    child <- most downstream actor of G that can fire
    simulatePhase(child)
    if child = A then
      countA++
    else if child = B then
      SDEP = SDEP o countA
    endif
  } loop until |SDEP| = steady(B)
  return SDEP
}
\end{verbatim}}
\vspace{-12pt}
\caption{\small Algorithm for computing $\figsdepf{A}{B}$ in a
dataflow graph $G$.  Because $\figsdep$ information is cyclic, a
simulation of a single steady state (the $\mt{steadySDEP}$ table) is
sufficient to answer all $\figsdep$
queries. \protect\label{fig:sdep1}}
\end{figure}

%% \begin{figure}[t]
%% {\scriptsize
%% \begin{verbatim}
%% int SDEP_{A<-B} (n) {
%%   if (n <= 0) || (no path from A to B in G) then
%%     return 0
%%   else
%%     cycles = floor(steady(B) / (n-1))
%%     return cycles * steady(A) + steadySDEP_{A<-B}[(n-1) mod steady(B)]
%%   endif
%% }

%% global targetCount;
%% global targetActor;
%% int[] steadySDEP_{A<-B} {
%%   SDEP = { }
%%   targetActor = A
%%   targetCount = 0
%%   for i = 1 to steady(B)
%%     pullSchedule(B)
%%     SDEP = SDEP o { countTarget }
%%   endfor
%%   return SDEP
%% }

%% pullSchedule(X) {
%%   for all input channels c_i of X
%%     while X needs more items on c_i for next phase
%%       pullSchedule(source(c_i))
%%   simulatePhase(X)
%%   if X=targetActor then
%%     targetCount++
%%   endif
%% }
%% \end{verbatim}}
%% \vspace{-12pt}
%% \caption{\small Algorithm for computing $\figsdepf{A}{B}$ in a
%% dataflow graph $G$.  Because $\figsdep$ information is cyclic, a
%% simulation of a single steady state (the $\mt{steadySDEP}$ table) is
%% sufficient to answer all $\figsdep$
%% queries. \protect\label{fig:sdep1}}
%% \end{figure}
