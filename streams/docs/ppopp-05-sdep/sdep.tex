\newcommand{\la}{$\leftarrow$}
\newcommand{\IND}{\begin{ALC@g}}
\newcommand{\UND}{\end{ALC@g}}
\newcommand{\tup}[2]{\langle{#1}, {#2}\rangle}

%% \section{Model of Computation}
%% \label{sec:modelofcomp}

%% %In this section, we describe our model of computation and define the
%% %stream dependence function, $\sdep$.

%% Our model of computation is Cyclo-Static Dataflow~\cite{BELP96},
%% a generalization of Synchronous Dataflow (SDF). It  is a popular  model of
%% computation~\cite{LM87-i} that  is well suited for  streaming
%% codes. In this model, computation is represented  as a graph consisting of
%% {\it  actors} connected by FIFO communication channels.
%% Each actor follows a set of execution steps, or phases, that consume
%% a constant number of items from the input channels and produce a
%% constant number of items onto the output channels.  
%% The number and ordering of phases is known at
%% compile time, and their execution is cyclic (that is, after executing
%% the last phase, the first phase is executed again).
%% SDF is appealing because every actor has a fixed input and output rate
%% (I/O rate) thus making the stream graphs  amenable to static
%% scheduling and optimization.

%% Figure~\ref{fig:sdep-rates} illustrates an example stream graph. The
%% nodes represent the actors, and the numbers within the nodes represent
%% the I/O rate of each actor. For example, actor $C$  consumes 3 input
%% items and produces 2 output times with every execution step. Actors
%% with a single input and multiple output channels are known as {\it splitters}, and on
%% every execution step, they can distribute their output to any one of
%% their children. For example, actor $A$ writes the output of its first
%% execution to its left child ($C$), and the output of its second
%% execution to its right child ($D$). This type of a splitter is a
%% round-robin splitter with one I/O rate per output edge. 
%% %A duplicate splitter is also possible but is not illustrated. 
%% A counterpart to splitters
%% are the joiners which have multiple input channels but only one output
%% channel. The joiner assembles the data from their predecessors
%% in a round-robin manner. In Figure~\ref{fig:sdep-rates}, actor $E$ is
%% a joiner which reads one item from $C$ in its first phase, then
%% another from $D$ in its second phase (before cycling back and 
%% repeating the pattern).

%The actors consume
%and produce a constant number  of items from their input and output
%channels every time they execute.  
%In
%this model, the stream graph is a directed graph where nodes represent
%actors and edges represent FIFO communication channels.  
%Also, for each phase, the number of
%items produced and consumed from the channels is fixed and known at
%compile time.
%We also permit actors to ``peek'' at items that are not
%consumed from the channel, and the peek amount is known at compile
%time (note that peeking is not part of CSDF).

\section{Stream Dependence Function}
\label{sec:sdep}

This section defines a stream dependence function, $\sdep$, that
describes how one actor depends on the execution of another actor in
the stream graph.  $\sdep$ is meaningful only for pairs of actors that
are connected by a directed path in the stream graph.  We say that the
{\it upstream} actor is at the start of the path, while the {\it
downstream} actor is at the end.  Dependences between parallel actors
(e.g., parallel branches of a splitjoin) currently fall outside the
scope of this model but could be addressed in future work~(see
Section~\ref{sec:conclusion}).

An execution $\phi$ of a dataflow graph is an ordered sequence of
actor firings.  Each firing represents the execution of a single phase
of the actor.  Let $\phi[i]$ denote the $i$th actor appearing in
execution $\phi$, and let $|\phi \wedge A|$ denote the number of times
that actor $A$ appears in $\phi$.  An execution is legal if the
dataflow requirements are respected; that is, for all $i$, the
sequential firing of actors $\phi[0]$ through $\phi[i-1]$ leaves
enough items on the communication channels for $\phi[i]$ to fire its
next phase atomically.  Let $\Phi$ denote the set of legal executions.
Note that while $\Phi$ is an infinite set, each $\phi \in \Phi$ is a
finite sequence.

%The stream dependence function, $\sdep$, describes the dependences
%between actor firings in the graph.  
Informally, $\sdepf{A}{B}(n)$ represents the minimum number of times
that actor $A$ must execute to make it possible for actor $B$ to
execute $n$ times.  This dependence is meaningful only if $A$ is
upstream of $B$; otherwise, $\sdep$ assumes a value of zero.  Because
the I/O rates of each actor are known at compile time, $\sdep$ is a
static mapping.

A formal definition of $\sdep$ using the notations introduced above is
as follows:
\begin{definition}(SDEP)
\begin{center}
$\sdepf{A}{B}(n)~~ = ~~\min~|\phi \wedge A|$ \\
~~~~~~~~~~~~~{\tiny ~}\raisebox{5pt}[0pt]{$~_{\phi \in \Phi,}$} \\
~~~~~~~~~~~~~~~~~{\tiny ~}\hspace{-1.3pt}\raisebox{8pt}[0pt]{$~_{|\phi \wedge B| = n}$}
\label{eq:sdepdef}
\end{center}
\vspace{-12pt}
\end{definition}
This equation reads: over all legal executions in which $B$ fires $n$
times, $\sdepf{A}{B}(n)$ is the minimum number of times that $A$
fires.  Figure~\ref{fig:sdep1} illustrates an example of $\sdep$ for
the stream graph in Figure~\ref{fig:sdep-rates}.

\section{Calculating SDEP}
\label{sec:calc-sdep}

It is straightforward to calculate $\sdepf{A}{B}(n)$ via a
fine-grained simulation of the stream graph.  Our approach is to
construct an execution $\phi$ that provides the minimum value of
$|\phi \wedge A|$ that is selected in Definition~\ref{eq:sdepdef}.  We
construct $\phi$ by simulating the stream graph's execution of a
``pull schedule'' with respect to actor $B$ (see Algorithm 1).

\begin{figure*}[t]
\begin{center}
\vspace{-12pt}
\psfig{figure=sdep-example3.eps,width=5.5in}
\vspace{-4pt}
\caption{\small Example \figsdep\ calculation for stream graph in
Figure~\ref{fig:sdep-rates}.  The stream graphs illustrate a steady
state cycle of a ``pull schedule''; execution proceeds from left to
right, and channels are annotated with the number of items present.
The second line lists the actors that fire in a pull schedule for
$E$.  The third line counts the number of times that $A$ executes in
the pull schedule, and the fourth line illustrates the computation of
$\figsdepf{A}{E}(n)$: the number of times that $A$ executes before the
$n$th execution of $E$.  The last two lines illustrate the computation
of $\figsdepf{B}{E}$.
\protect\label{fig:sdep1}}
\end{center}
\vspace{-12pt}
\end{figure*}

\begin{figure}[t]
\begin{center}
\framebox{\parbox{3.25in}{
\mbox{} \textsc{Algorithm 1.} {\it (Pull scheduling)} \vspace{6pt}\\
\mbox{} ~~~~// {\it Returns a pull schedule for $n$ executions of $X$} \\
\mbox{} ~~~~{\bf pullSchedule}($X$, $n$) \{\\
\mbox{} ~~~~~~~$\phi = \{ \}$ \\
\mbox{} ~~~~~~~{\bf for} $i$ = 1 to $n$ \{ \\
\mbox{} ~~~~~~~~~~// {\it execute predecessors of $X$ until $X$ can execute} \\
\mbox{} ~~~~~~~~~~{\bf for all} input channels $c_i$ of $X$ \\
\mbox{} ~~~~~~~~~~~~~{\bf while} $X$ needs more items on $c_i$ in order to fire \\
\mbox{} ~~~~~~~~~~~~~~~~// {\it extend schedule ($\circ$ denotes concatenation)} \\
\mbox{} ~~~~~~~~~~~~~~~~$\phi = \phi ~\circ$ {\bf pullSchedule}({\bf source}($c_i$), 1) \\
\mbox{} ~~~~~~~~~~// {\it add $X$ to schedule} \\
\mbox{} ~~~~~~~~~~$\phi = \phi~\circ~X$ \\
\mbox{} ~~~~~~~~~~// {\it update number of items on I/O channels of $X$} \\
\mbox{} ~~~~~~~~~~{\bf simulateExecution}($X$) \\
\mbox{} ~~~~~~~\} \\
\mbox{} ~~~~~~~return $\phi$ \\
\mbox{} ~~~~\}
}}
\end{center}
\vspace{-12pt}
\end{figure}

\begin{figure}[t]
\begin{center}
\psfig{figure=sdep-example-rates3.eps,height=1.5in}
\vspace{9pt}
\caption{{\small Example stream graph.  Nodes are annotated with their
I/O rates.  For example, node C consumes 3 items and produces 2 items
on each execution.  Node A is a round-robin splitter that produces one
item on its left channel during the first phase, and one item on its
right channel during the second phase (similarly for Node E).
\protect\label{fig:sdep-rates}}}
\end{center}
\vspace{-26pt}
\end{figure}

Intuitively, a pull schedule for $X$ is one that executes other nodes
as few times as possible for each firing of $X$.  This is achieved by
calculating the demand for data items on the input channels of $X$,
and then propagating the demand back through the stream graph via pull
scheduling of the actors connected to $X$.  Pull scheduling results in
a fine-grained interleaving of actor firings.  Some stream graphs
admit multiple pull schedules, as actors might be connected to
multiple inputs that can be scheduled in any order; however, the set
of actor executions remains constant even as the order changes.  The
following theorem allows us to use a pull schedule to calculate the
$\sdep$ function.
\begin{theorem} 
\label{thm1}
\[
\sdepf{A}{B}(n) = |{\bf pullSchedule}(B, n) \wedge A|
\]
\end{theorem}
\begin{proof}
By construction, ${\bf pullSchedule}(B, n)$ executes each node in the
graph as few times as possible for $B$ to fire $n$ times.  Thus, there
is no execution containing $n$ executions of $B$ where $A$ executes
fewer times.  The theorem follows from the definition of $\sdep$.
\end{proof}

Some example $\sdep$ calculations appear in Figure~\ref{fig:sdep1}.
The results are summarized in the following table.
\begin{center}
{\small
\begin{tabular}{|c|c|c|}
\hline
$n$ & $\sdepf{A}{E}(n)$ & $\sdepf{B}{E}(n)$ \\
\hline \hline
1 & 5 & 0 \\ \hline
2 & 5 & 2 \\ \hline
3 & 5 & 2 \\ \hline
4 & 6 & 3 \\ \hline
\end{tabular}}
\end{center}
Note that $\sdep$ is non-linear due to mis-matching I/O rates in the
stream graph.  However, for longer execution traces, there is a
pattern in the marginal growth of $\sdep$ (i.e., in $\sdep(n) -
\sdep(n-1)$); this quantity follows a cyclic pattern and has the same
periodicity as the steady state of the stream graph.  A steady state
${\cal S} \in \Phi$ is an execution that does not change the buffering
in the channels---that is, the number of items on each channel after
the execution is the same as it was before the execution.  Calculating
a steady state is well-understood~\cite{LM87-i}.  The execution
simulated in Figure~\ref{fig:sdep1} is a steady state, meaning that
additional entries of the pull schedule will repeat the pattern given
in the figure.  Thus, $\sdep$ will also grow in the same pattern, and
we can calculate $\sdepf{A}{E}(n)$ for $n > 4$ as
follows\footnote{\small Note that for any two actors $X$ and $Y$,
$\sdepf{Y}{X}(0) = 0$.}:
\begin{equation}
\label{eq:sdep-steady}
\nonumber
\hspace{-4.5pt}\begin{array}{rcl}
\sdepf{A}{E}(n) \hspace{-5.5pt}&=&\hspace{-5.5pt} p(n) * |{\cal S} \wedge A| + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\hspace{3.3pt}~~(1)\\[0.2Ex]
~&~&\mbox{~}\hspace{8.5pt} \sdepf{A}{E}(n - p(n) * |{\cal S} \wedge E|) \\[1Ex]
p(n) \hspace{-5.5pt}&=&\hspace{-5.5pt} \lfloor \frac{n}{|{\cal S} \wedge E|} \rfloor~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\hspace{1.3pt}~~~~~~~~~(2) % I can't get the Eq. number to appear here any other way :(
\end{array}
\end{equation}
where ${\cal S}$ is a steady state and $p(n)$ represents the number of
steady states that $E$ has completed by iteration $n$.  The first term
of Equation~1 gives the total number of times that $A$ has fired in
previous steady states, while the second term counts firings of $A$ in
the current steady state.

While Equation~1 is valid for $\sdepf{A}{E}$, it does not work for
certain corner cases.  For example, for $\sdepf{A}{C}(3)$ it detects
exactly 3 steady state executions $(p(3)=3)$ and concludes that each
requires $6$ executions of $A$ ($|{\cal S} \wedge A| = 6$).  However,
as is visible from Figure~\ref{fig:sdep1}, the last firing of $C$
requires only $5$ executions of $A$.  $C$ is unusual in that it
finishes its steady state before $A$, which lies upstream.

To handle the general case, we simulate {\it two} executions of the
steady state, thereby capturing all of the dependences in the
transition from one steady state to another:
%This results in a 2X
%larger $\sdep$ table that can index any execution within a steady
%state without being on the boundary of the table.  The formulation is:
% To encapsulate the dependences across a steady
%state boundary, we need to tabulate two steady state iterations of
%$\sdep$ instead of just one:
\begin{equation*}
\hspace{20pt}\begin{array}{l}
\hspace{-10pt}\sdepf{Y}{X}(n) = ~\hspace{2in}\hspace{2pt}(3)\\[1Ex]
\mbox{~}\hspace{6pt}
\left\{\begin{array}{lr}
\hspace{-3.5pt}|{\bf pullSchedule}(X, n) \wedge Y| & \hspace{-23pt} \mbox{if~} n \le 2*|{\cal S} \wedge X| \\[2.5Ex]
\hspace{-3.5pt}q(n) * |{\cal S} \wedge Y| + & \hspace{-23pt} \mbox{otherwise} \\[0.2Ex] %(\mbox{if~} n > 2*|{\cal S} \wedge X|)\\[1Ex]
\mbox{~}\hspace{12.5pt} \sdepf{Y}{X}(n - q(n) * |{\cal S} \wedge X|)
\end{array}
\right.~\\~\\
\hspace{-10pt}q(n) = \lfloor \frac{n}{|{\cal S} \wedge X|} \rfloor - 1  ~\hspace{1.83in}\hspace{2pt}(4)
\end{array}
\vspace{-2pt}
\end{equation*}
In addition to growing the base $\sdep$ table by $2\times$, this
formulation sets $q(n)$ to be one unit smaller than $p(n)$.  This
causes one steady state iteration to be counted as part of the
``current iteration'' rather than the ``completed'' iteration.  For
example, Equation~3 evaluates $\sdepf{A}{C}(3)$ using $q(3)=2$,
yielding $\sdepf{A}{C}(3) = 2*6 + \sdepf{A}{C}(3-2*1) = 17$ as
desired.  Moreover, this formulation handles more complex
cases\footnote{{\small For example, if within each steady state, the
first firing of $X$ does not depend on the first firing of $Y$, and
the last firing of $X$ does not depend on the last firing of $Y$.}}
that are beyond the scope of this discussion.

%% That is, we use a pull schedule to calculate $\sdep$ through the first
%% two steady states of $X$.  Then we extrapolate $\sdep$ as before,
%% except we use $q(n)$ instead of $p(n)$; $q(n)$ subtracts one so that
%% an extra steady-state iteration is evaluated as part of the second
%% term (in the argument to $\sdep$) rather than in the first term (as
%% the coefficient of $|{\cal S} \wedge Y|$).

%This formulation correctly
%handles a number of dependences on the steady state boundaries that
%are otherwise tricky and problematic.  



%as being in the middle (not the boundary) of the double steady-state
%cycle, thereby avoiding the boundary issues.

%% For example, Equation~2 yields the wrong answer for $\sdepf{A}{C}$ in
%% Figure~\ref{fig:sdep1}; this case is unusual because $C$ finishes its
%% steady state before $A$, even though $C$ is downstream of $A$.  That
%% is, $\sdepf{A}{C}(|{\cal S}
%% \wedge C|) = \sdepf{A}{C}(1) = 5$, but $|{\cal S} \wedge A| = 6$.  

%Another tricky case is when
%$\sdepf{Y}{X}(|{\cal S} \wedge X|) < |{\cal S} \wedge Y|$ and
%$\sdepf{Y}{X}(1) = 0$, in which case $Y$ has executions on both sides
%of the steady state boundary that $X$ does not depend on.  This
%behavior is correctly modeled by Equation~3.

%% This general form is needed when, within a single steady state, both
%% of the following are true: a) the first execution of $X$ does not
%% depend on $Y$, and b) $X$ does not depend on the last execution of
%% $Y$.  An example condition (a) is actor $B$ and $E$ in
%% Figure~\ref{fig:sdep1}, because $\sdepf{B}{E}(1) = 0$.  An example of
%% condition (b) is actor $A$ and $C$: $C$ finishes its steady state
%% before $A$, even though $C$ is downstream of $A$.  That is,
%% $\sdepf{A}{C}(|{\cal \wedge C|) = \sdepf{A}{C}(1) = 5$, but $|{\cal S}
%% \wedge A| = 6$.  If we add a dummy phase (producing no items) to the
%% beginning of $A$'s steady state, then the actors $A$ and $C$ also do
%% meet both conditions.  In such cases, the steady state boundary is
%% blurred, as one cannot tell if $X$ is in the 

%% \begin{equation*}
%% \begin{array}{c}
%% ~~\hspace{0.7in}~~p = \lfloor \frac{n-q}{|{\cal S} \wedge X|}\rfloor~~\hspace{0.7in}~~(3)
%% \end{array}
%% \end{equation*}
%% where $q \in [1,|{\cal S} \wedge X|]$ is chosen such that
%% $\sdepf{Y}{X}(q) > \sdepf{Y}{X}(q-1)$.  

%%  and the original choice of $p$ gives erroneous results.  As
%% Equation~(1) assumes that $p$ steady states have completed, $p$ needs
%% to be chosen on a boundary


%% This choice of $p$ has the following property: for any value of $n$,
%% $Y$ has completed at least $p(n)$ steady state cycles.

%% , then $Y$ has completed at least $p$ steady
%% state cycles.


%% but it was not satisfied by the original choice of $p$
%% (Equation~(2)).  For example, consider

%% That is, $q$ is chosen to
%% represent a transition whereby $Y$ must have fired 

%% Using this value of $p$, Equation~(1) is still used to extrapolate
%% values of $\sdep$, though the base case for $\sdep$ now ranges from
%% $n=1$ to $n=q+|{\cal S}
%% \wedge X|-1$.  


%% Using the general form of $p$ serves to shift the effective steady
%% state boundary so that, on the first execution of $X$ within each
%% steady state, it is guaranteed that $Y$ has finished all of its
%% executions from the previous steady state.


%% 1) , and 2) on the
%% first execution of $X$ within each steady state, it is guaranteed that
%% $Y$ has finished all of its executions from the previous steady state.

Thus, to calculate $\sdepf{Y}{X}(n)$, it is not necessary to simulate
a pull schedule for $n$ iterations of $X$ as described in Algorithm 1.
Instead, one can simulate $2 * |{\cal S} \wedge X|$ iterations as a
pre-processing step and answer all future $\sdep$ queries in constant
time, using Equation~3.  In addition, the pull schedule for $X$ can be
reused to calculate $\sdep$ from $X$ to any other actor (e.g.,
$\sdepf{W}{X}$ in addition to $\sdepf{Y}{X}$).

However, note that the pull schedule for $X$ can {\it not} be used to
calculate $\sdep$ from any actor other than $X$ (e.g.,
$\sdepf{W}{Y}$).  The guarantee provided by ${\bf pullSchedule}(X, n)$
is only with respect to the base actor $X$. For other pairs of actors
in the graph, one actor might execute more than necessary for $n$
executions of the other.  For example, consider what happens if one
calculates $\sdepf{A}{B}$ using the schedule in Figure~\ref{fig:sdep1}
(which is a pull schedule for $E$).  In the schedule, $A$ executes 5
times before the first firing of $B$, so one would conclude that
$\sdepf{A}{B}(1) = 5$.  However, this is incorrect; since $B$ could
have fired after only 2 executions of $A$, the correct value is
$\sdepf{A}{B}(1) = 2$.  Thus, to calculate $\sdepf{Y}{X}$, it is
essential to calculate ${\bf pullSchedule}(X, |{\cal S} \wedge X|)$,
that is, a steady state cycle of a pull schedule with respect to $X$.

It is also possible to calculate $\sdep$ using a compositional
approach.  For example, $\sdepf{A}{E}$ from Figure~\ref{fig:sdep1} can
be expressed as follows: ~\vspace{-3pt}~
\begin{equation*}
\begin{array}{rl}
\sdepf{A}{E}(n) = \max \left\{\begin{array}{l}
\sdepf{A}{B} ( \sdepf{B}{E}(n) ) \\
\sdepf{A}{C} ( \sdepf{C}{E}(n) )
\end{array}\right.
\end{array}
\end{equation*}
That is, to determine the minimum number of times that $A$ must
execute to enable $n$ executions of $E$, first calculate the minimum
number of times each of $A$'s successors in the stream graph must
execute for $n$ executions of $E$.  Then $A$ must execute enough to
enable all of these children to complete the given number of
executions, which translates to the $\max$ operation shown above.  Our
implementation exploits this compositional property to tabulate
$\sdep$ in a hierarchical manner, rather than simulating a pull
schedule.

%% It is also possible to calculate $\sdep$ using a compositional
%% approach.  Suppose there is a path in the stream graph from $A$ to $B$
%% to $C$.  Then $\sdep$ has the following property, which follows from
%% Theorem~\ref{thm1}:
%% \[
%% \sdepf{A}{C}(n) = \sdepf{A}{B} ( \sdepf{B}{C}(n) )
%% \]
%% That is, to calculate the minimum number of executions of $A$ that
%% enables $n$ executions of $C$, one first calculates the minimum number
%% of executions of an intermediate actor $B$ for $n$ executions of $C$,
%% and then finds the minimum number of executions of $A$ for the given
%% execution count of $B$.  One can utilize this property to tabulate
%% $\sdep$ values hierarchically, starting with adjacent actors and then
%% composing successively longer paths through the stream graph.

%% {\scriptsize
%% \begin{verbatim}
%% int SDEP_{A<-B} (n) {
%%   if no path from A to B in G then
%%     return 0
%%   else 
%%     countA = 0
%%     countB = 0
%%     do {
%%       child <- most downstream actor of G that can fire
%%       simulatePhase(child)
%%       if child = A then
%%         countA++;
%%       else if child = B then
%%         countB++;
%%       endif
%%     } loop until (countB = n)
%%   endif
%%   return countA
%% }
%% \end{verbatim}}

%% \begin{figure}[t]
%% {\scriptsize
%% \begin{verbatim}
%% int SDEP_{A<-B} (n) {
%%   if (n <= 0) || (no path from A to B in G) then
%%     return 0
%%   else
%%     cycles = floor(steady(B) / (n-1))
%%     return cycles * steady(A) + steadySDEP_{A<-B}[(n-1) mod steady(B)]
%%   endif
%% }

%% int[] steadySDEP_{A<-B} {
%%   SDEP = { }
%%   countA = 0
%%   do {
%%     child <- most downstream actor of G that can fire
%%     simulatePhase(child)
%%     if child = A then
%%       countA++
%%     else if child = B then
%%       SDEP = SDEP o countA
%%     endif
%%   } loop until |SDEP| = steady(B)
%%   return SDEP
%% }
%% \end{verbatim}}
%% \vspace{-12pt}
%% \caption{\small Algorithm for computing $\figsdepf{A}{B}$ in a
%% dataflow graph $G$.  Because $\figsdep$ information is cyclic, a
%% simulation of a single steady state (the $\mt{steadySDEP}$ table) is
%% sufficient to answer all $\figsdep$
%% queries. \protect\label{fig:sdep1}}
%% \end{figure}

%% \begin{figure}[t]
%% {\scriptsize
%% \begin{verbatim}
%% int SDEP_{A<-B} (n) {
%%   if (n <= 0) || (no path from A to B in G) then
%%     return 0
%%   else
%%     cycles = floor(steady(B) / (n-1))
%%     return cycles * steady(A) + steadySDEP_{A<-B}[(n-1) mod steady(B)]
%%   endif
%% }

%% global targetCount;
%% global targetActor;
%% int[] steadySDEP_{A<-B} {
%%   SDEP = { }
%%   targetActor = A
%%   targetCount = 0
%%   for i = 1 to steady(B)
%%     pullSchedule(B)
%%     SDEP = SDEP o { countTarget }
%%   endfor
%%   return SDEP
%% }

%% pullSchedule(X) {
%%   for all input channels c_i of X
%%     while X needs more items on c_i for next phase
%%       pullSchedule(source(c_i))
%%   simulatePhase(X)
%%   if X=targetActor then
%%     targetCount++
%%   endif
%% }
%% \end{verbatim}}
%% \vspace{-12pt}
%% \caption{\small Algorithm for computing $\figsdepf{A}{B}$ in a
%% dataflow graph $G$.  Because $\figsdep$ information is cyclic, a
%% simulation of a single steady state (the $\mt{steadySDEP}$ table) is
%% sufficient to answer all $\figsdep$
%% queries. \protect\label{fig:sdep1}}
%% \end{figure}

%% \todo{Correct pseudocode to handle initialization.}

%% reference code to borrow from to get the init/steady phases right:

%% int SDEP_{A<-B} (n) {
%%   if no path from A to B in G then
%%     return 0
%%   else
%%     <sdepInit, sdepSteady> = sdepTable(A,B)
%%     if n<|sdepInit| then
%%       return sdepInit[n]
%%     else
%%       nAfterInit = n - |sdepInit|
%%       cycles = floor(steady(B) / nAfterInit)
%%       return cycles * steady(A) + sdepSteady[nAfterInit mod steady(B)]
%%     endif
%%   endif
%% }

%% <int[], int[]> sdepTable(A,B) {
%%   sdepInit = { 0 }
%%   sdepSteady = { }
%%   countA = 0
%%   countB = 0
%%   do {
%%     child <- most downstream actor of G that can fire
%%     simulatePhase(child)
%%     if child = A then
%%       countA++
%%     else if child = B then
%%       if (countB<init(B) || countA<init(A)) then
%%         sdepInit = sdepInit o countA
%%       else
%%         sdepSteady = sdepSteady o countA
%%       endif
%%       countB++
%%     endif
%%   } loop until |sdepSteady| = steady(B)
%%   return <sdepInit, sdepSteady>
%% }
