\documentclass[11pt]{article}

\usepackage{palatino}
\usepackage{streamit}

\title{StreamIt Semantic Checks}

\begin{document}

\maketitle

This document contains a list of semantic checks that should be
performed on StreamIt programs after they have been parsed.  These
assume the program is syntactically correct; it must pass through the
parser correctly.

\section{Statement Placement}

\subsection{Init, Work, and Phase Functions}

\begin{enumerate}
\item \lstinline|add| statements can only appear in init functions in
  split-joins and pipelines;
\item \lstinline|split| and \lstinline|join| statements can only
  appear in init functions in split-joins and feedback loops;
\item \lstinline|loop|, \lstinline|body|, and \lstinline|enqueue|
  statements can only appear in init functions in feedback loops;
\item \lstinline|push| statements can only appear in work and phase
  functions in filters.
\item \lstinline|pop| and \lstinline|peek| expressions can only appear
  in work and phase functions in filters.
\item If a work function does not declare I/O rates, it may not use
  \lstinline|push|, \lstinline|pop|, or \lstinline|peek|.  If it
  declares a push rate, though, it must call
  \lstinline|push|.\footnote{Declaring a nonzero peek rate affects the
    scheduling but not correctness, so you're not obligated to peek;
    if you don't pop, you automatically pop your pop rate at the end
    of the work function.}
\item Every filter must have a work function.
\item Every stream object that is not a filter must have an init
  function, but may have no other functions.\footnote{This is
    currently implicit in the language syntax.  The constraint and
    syntax could both change due to reinitialization, or by adding
    message handlers to composite streams.}
\end{enumerate}

\subsection{Control Flow and Initialization Code}

Several statements may only be executed once per function; other
statements are sensitive to the order in which they are executed.

\begin{enumerate}
\item \lstinline|split|, \lstinline|join|, \lstinline|body|, and
  \lstinline|loop| statements must be executed exactly once if they
  are allowed at all.  Every path of control through the
  initialization code must result in exactly one execution.
\item A data-flow analysis must be able to determine the number and
  sequence of phases, along with any intermediate code, for a phased
  filter.
\item Nothing other than a work function which does not declare I/O
  rates may call a phase function.
\end{enumerate}

\section{Typing}

\subsection{Stream Connections}

``Match'' within this section means an \emph{exact} match in type;
there is no implicit type promotion across tapes.

\begin{enumerate}
\item For a pipeline, the input type must match the input type of the
  first child and the output type of the last child must match the
  output type of the pipeline.
\item Within a pipeline, the output type of one child must match the
  input type of the next child.
\item The input type of each of a split-join's children must be either
  the input type of the split-join or \lstinline|void|.  Identical
  constraints hold for the output.
\item The output type of a feedback loop's loop stream must match the
  input type of its body stream.  The input type of the feedback loop
  must be either the same type as the body input or \lstinline|void|.
  Identical constraints hold for the output side of the feedback loop.
\item Exactly one stream in the program has the stream type
  \lstinline|void->void|.  This stream must be named.
\end{enumerate}

\subsection{Implications of Stream Types}

\begin{enumerate}
\item The splitter of a split-join must be
  \lstinline|roundrobin(0)| if the input type of the stream is
  \lstinline|void|; it may not be \lstinline|roundrobin(0)| otherwise.
  Identical constraints hold for the output.
\item If a split-join has some children with \lstinline|void| inputs and
  some children with non-\lstinline|void| inputs, the splitter must be
  a round-robin splitter with a declared weight of 0 for each of the
  \lstinline|void| children.  Identical constraints hold for the
  output and the joiner.
\item The splitter and joiner of a feedback loop must accomodate
  exactly two children.  If the body and loop children have
  non-\lstinline|void| input and output types, then the joiner must be
  equivalent to \lstinline|roundrobin(0,1)| if the input of the loop
  is \lstinline|void|, and similarly for the splitter and the output.
\item If the input type of a feedback loop's body child is
  \lstinline|void|, then the loop input type and loop child output
  type must also be \lstinline|void|, and the joiner must be
  \lstinline|roundrobin(0)|.  Identical constraints hold for the loop
  output and splitter.
\item If the input type of a filter is \lstinline|void|, all of its
  work functions must declare peek and pop rates of 0; if its output
  type is \lstinline|void|, all of its work functions must have a push
  rate of 0.
\end{enumerate}

\subsection{Statements and Expressions}

\begin{enumerate}
\item Types can be promoted: a \lstinline|bit| can be implicitly
  converted to an \lstinline|int|, an \lstinline|int| can be promoted
  to a \lstinline|float|, and a \lstinline|float| can be promoted to
  \lstinline|complex|.
\item Every referenced variable must have a declared type.
\item Every expression has a type:
\begin{enumerate}
\item The type of a variable reference is the type of the variable;
\item The type of a literal is the lowest type that can contain the
  literal (the type of \lstinline|1| is \lstinline|bit|, the type of
  \lstinline|2| is \lstinline|int|, the type of \lstinline|2.0| is
  \lstinline|float|, and the type of \lstinline|2i| is
  \lstinline|complex|);
\item The type of a unary expression is the type of the child
  expression.  The type of a binary expression is the join of the
  types of the child expression, possibly promoted to a type the
  operator can accept.  The type of the first part of the ternary
  expression must be promotable to \lstinline|int|, and the second and
  third parts must be promotable to a common type; the resulting type
  is the common type.  In all cases, the types of child expressions
  must conform to the acceptable types for the operator listed in the
  language specification.
\item For a field reference \lstinline|a.b|, \lstinline|a| must be of
  some structure type \lstinline|A|, which must have a field named
  \lstinline|b|.  The type of the expression is the type of
  \lstinline|b| in the structure declaration.
\item For an array access \lstinline|a[i]|, \lstinline|a| must be of
  some array type \lstinline|T[n]|, and the type of the expression is
  \lstinline|T|.
\item The type of a \lstinline|peek()| or \lstinline|pop()| expression
  is the input type of the filter.
\item The parameter of a \lstinline|peek()| expression and the index
  of an array must both be of type \lstinline|int|.
\item The type of a call to a helper function is the return type of
  that function.
\end{enumerate}
\item The type of the parameter of a \lstinline|push()| statement must
  be the output type of the filter.
\item The type of the parameter of an \lstinline|enqueue()| statement
  must be the output type of the feedback loop's loop stream.
\item The type of the right-hand side of an assignment statement must
  be promotable to the type of the left-hand side of the statement.
\end{enumerate}

\subsection{Using Names As Types}

\begin{enumerate}
\item A bare name may be used as a type in a variable declaration,
  parameter list, stream type, and elsewhere.  The name must match the
  name of a declared structure type.
\item A bare name may be used as the target type of a
  \lstinline|Portal| type.  The name must match the name of a declared
  stream type; the target of a portal may not be a primitive type or
  structure.
\end{enumerate}

\section{Naming}

\subsection{Object Names}

\begin{enumerate}
\item No two streams or structures may have the same name.
\item Within a single structure, no two member fields may have the
  same name.  Field names must also be distinct from all stream and
  structure names.
\item Stream parameters within a single stream must have distinct
  names from each other and from all stream and structure names.
\item Functions declared within a filter must have unique names; these
  include phase functions, message handlers, and helper functions.
  The name of a function must be distinct from stream and structure
  names.
\item A variable may not be declared with the same name as a stream
  parameter.  (Other variable hiding is legal.)  The name of a
  variable must be distinct from stream, structure, and function
  names within the current filter.
\end{enumerate}

\subsection{Using Names}

\begin{enumerate}
\item A stream constructor (the parameter to \lstinline|add|,
  \lstinline|body|, and \lstinline|loop| statements) must be an
  anonymous stream declaration, or must have a name matching the name
  of a stream object with a parameter list matching the parameter list
  of  the the stream.
\item A variable must be declared before it is used.
\item A stream parameter may not be assigned to or otherwise modified.
\item A function call must have a name matching a phase or helper
  function in the current filter, and a parameter list matching the
  parameter list of the target function.
\item A message-sending statement must name a portal variable on the
  left-hand side of the ``.'', and a message name on the right-hand
  side.  The message name must match a message in the target type of
  the portal, and the statement must have a parameter list matching
  the parameter list of the message target.
\end{enumerate}

\section{Warnings}

Things in this section are technically legal, but indicate
questionable code:

\begin{enumerate}
\item Some things in StreamIt are counted; these include split-join
  children (with fixed-length weighted round-robin splitters or
  joiners), and work function pushes, pops, and peeks.  It should be a
  warning if the compiler cannot statically confirm that these numbers
  are not met exactly (or, for peeks, that the peek rate is not
  exceeded).   For feedback loops, the compiler can also issue a
  warning if it cannot confirm that enough items are enqueued to cause
  the joiner to be fired at the start of the program.
\item The compiler may need to guess at the I/O types of anonymous
  streams.  If the type isn't clear from context a warning should be
  issued.
\item A warning should be issued if a phase function is declared which
  is not used.
\item A warning may be issued if the compiler cannot verify that
  splitters and joiners for split-joins can accomodate the exact
  number of children present.  Note that this may only be possible
  with pattern-matching program text, or by fully unrolling init
  functions, since the following code is legitimate but data-flow
  wouldn't find an exact number of children:

\begin{lstlisting}{}
float->float splitjoin FiveChildren {
  split roundrobin(1,2,3,4,5);
  for (int i = 0; i < 5; i++)
    add float->float filter { ... };
  join roundrobin(5,4,3,2,1);
}
\end{lstlisting}
\end{enumerate}

\section{Temporary Checks}

These checks are necessary due to current constraints in the StreamIt
compiler.  They should be able to be removed when the compiler is
improved.

\begin{enumerate}
\item All child-constructing statements in initialization code must
  have consistent types.  While the front-end can perform minimal
  data-flow analysis to check that the types of pipelines, control
  flow like the following is presently illegal:

\begin{lstlisting}{}
int->int filter IntIntBody { ... }
int->int filter IntIntLoop { ... }
float->int filter FloatIntBody { ... }
int->float filter IntFloatLoop { ... }

void->int feedbackloop SketchyLoop(int p) {
  join roundrobin(0, 1);
  if (p) {
    body IntIntBody();
    loop IntIntLoop();
  } else {
    body FloatIntBody();
    loop IntFloatLoop();
  }
  split duplicate;
  enqueue(1);
}
\end{lstlisting}

  The types of the loop and all of its components are consistent
  regardless of the value of \lstinline|p|, but if \lstinline|p| is
  zero, the \lstinline|enqueue| statement takes a \lstinline|float|
  parameter.  Presently the front-end should reject this construction
  since it is unclear if the types around the joiner are consistent or
  not.  This check can be removed if the compiler does stream
  type-checking after constant propagation.
\item None of the names listed in the ``Implementation Limits''
  section of the language specification should be used.  These include
  the capitalized names \lstinline|SplitJoin|,
  \lstinline|FeedbackLoop|, \lstinline|Filter|, \lstinline|Pipeline|,
  \lstinline|StreamIt|, and \lstinline|Complex|.
\end{enumerate}

\end{document}