\section{Notation}
\label{sec:pcg}

%% \begin{table}[t]
%% \small
%% \begin{center}
%% \begin{tabular}{|c|c|c|c|c|c|} \hline
%% Model of Computation & Items on Channels & Nodes with & Nodes with & Cyclic Steady \\
%%                      & at Start & Push $\ne$ Pop & Peek $>$ Pop & State Phases \\
%% \hline \hline
%% Synchronous Dataflow~\cite{LM87-i} & X & X & & \\
%% \hline
%% Cyclo-Static Dataflow~\cite{BELP96} & X & X & & X \\
%% \hline
%% Computation Graphs~\cite{KM66} & X & X & X & \\
%% \hline
%% Phased Computation Graphs & X & X & X & X \\
%% \hline
%% \end{tabular}
%% \vspace{-6pt}
%% \caption{\protect\small Models of Computation for Dataflow Graphs.}
%% \label{tab:models}
%% \vspace{-12pt}
%% \end{center}
%% \end{table}

In this section we give our notation for representing programs in the
framework of Cyclo-Static Dataflow.

\subsection{Cyclo-Static Dataflow Graph}
Formally, a Cyclo-Static Dataflow Graph is a directed graph with the
following components:
\begin{itemize}

\item Nodes $n_1 \dots n_{m_n}$.

\item Channels $c_1 \dots c_{m_c}$, where each channel is directed
from a given node $n_a$ to a given node $n_b$.

\item The number of phases $\mt{num}(n)$ that node $n$ exhibits.  For
all $n$, $\mt{num}(n) \ge 1$.

\item Non-negative integers $U(c, p)$ and $O(c, p)$, which give the
number of items pushed and popped, respectively, over channel $c$
during the $p$'th phase.

%% % NOTE that this is overly cautious within loops... could have smaller A(c)
%% \item A non-negative integer $A(c)$ indicating the number of items
%%   that are initially present on channel $c$.  There must be enough
%%   items present on $c$ to ensure a node can execute all of its phases
%%   during a steady-state schedule.  This constraint can be posed
%%   conservatively\footnote{A more precise formulation is as follows.
%%   For a given channel $c$, set $Emax_0 = 0$ and $Emax_{p+1} =
%%   max(maxE_p, E(c,p) + \sum_{i=0}^{p} O(c,p))$ for all $p \in [0,
%%   num(c) - 1]$.  Then $A(c) \ge Emax_{num(c)-1} -
%%   \sum_{i=0}^{num(c)-1} O(c,p)$.} as $A(t) \ge max_p (E(c,p) -
%%   o(c,p))$.

\end{itemize}

\subsubsection{Execution Model}

We give an informal description of the execution semantics of a
CSDG.An execution consists of a sequence of atomic {\it firings} of
nodes in the graph.  The effect of firing a given node depends on its
phase, which is a local state of the node.  At the start of execution,
each node is in phase 0, and each channel $c$ contains 0 items.

Let us consider a node $n$ that is in phase $p$.  It is legal for $n$
to fire if $p \in [0, \mt{num}(n)-1]$ and, for each channel $c_{in}$
directed into $n$, there are at least $O(c_{in}, p)$ items on
$c_{in}$.  The effect of this firing is to consume $O(c_{in}, p)$
items from each channel $c_{in}$ directed into $n$; to produce
$U(c_{out}, p)$ new items on each channel $c_{out}$ directed out of
$n$; and to advance the phase $p$ of $n$ to $(p +
1)~\mt{mod}~\mt{num}(n)$.

From the starting state of the graph, execution proceeds via an
infinite sequence of node firings.  The order of node firings is
constrained only by the conditions given above.

\subsection{Cyclo-Static Dataflow Program}

The CSDG described above is a representation for a graph, treating
each node and channel as a black box.  Here we introduce some notation
for the internals of the nodes, as well as the ordering of items on
the channels.  We refer to the aggregate model as a Cyclo-Static
Dataflow Program (CSDP).  Before describing a CSDP, we will need some
additional notation:
\begin{itemize}

\item We assume that all items passed over channels are drawn from the
same domain of values ${\cal V}$.

\item An array type\footnote{To simplify the presentation, we allow
ourselves a slight abuse of notation by sometimes using arrays instead
of enumerating individual elements.  Our definitions could be expanded
into strict element-wise SARE's without any fundamental change to the
technique.} of length $n$ and element type $\tau$ is denoted by
$\tau[n]$.  Given a two-dimensional array $A$ of type $\tau[n][m]$,
$A[i][*]$ denotes the $m$-element array comprising the $i$'th row of
$A$.

\item $\mt{num\_in}(n)$ (resp. $\mt{num\_out}(n)$) denotes the number of
channels that are directed into (resp. out of) node $n$.

\item $\mt{chan\_in}(n)$ (resp. $\mt{chan\_out}(n)$) denotes the list of
channels that are directed into (resp. out of) node $n$.

\item $\mt{pos\_in}(n, c)$ (resp. $\mt{pos\_out}(n, c)$) denotes the
position of channel $c$ in $\mt{chan\_in}(n)$
(resp. $\mt{chan\_out}(n)$.  That is, $\mt{chan\_out}(n)[\mt{pos\_out(n,
c)}] = c$.

\end{itemize}

\noindent A Cyclo-Static Dataflow Program (CSDP) consists of the
following:
\begin{itemize}

\item A Cyclo-Static Dataflow Graph $G = (\{n_1$ $\dots$ $n_{m_n}\},$
$\{c_1$ $\dots$ $c_{m_c}\},$ $\mt{num},$ $U,$ $O)$ describing the
nodes, channels, and I/O rates of the program (see
Section~\ref{sec:pcg}).  Each channel $c = (n_a, n_b)$ is a FIFO
queue; $n_a$ pushes items onto the back of $c$ and $n_b$ consumes
items from the front of $c$.

%% \item The initial values $I(c)$ that are enqueued onto channel $c$ at
%% the start of execution.  Since there are $A(c)$ initial values on
%% channel $c$, $I(c)$ has type ${\cal V}[A(c)]$.
%An initialization function $I(c)$ that returns an array of
%length $A(c)$, the elements of which are enqueued onto channel $c$ at
%the start of execution.  The procedure $I(c)$ takes no arguments; its
%signature is $\mt{void} {\small \rightarrow} {\cal V}[A(c)]$.
%
\item A work function $W(n, p)$ that represents the computation of
node $n$ in phase $p$.  The signature of $W(n, p)$ is:
{\scriptsize
\begin{equation*}
[{\cal V}[O(\mt{chan\_in}(n)[1], p)], \dots, {\cal V}[O(\mt{chan\_in}(n)[\mt{num\_in}(n)], p)]] \rightarrow
\vspace{-11pt}
\end{equation*}
\begin{equation*}
[{\cal V}[U(\mt{chan\_out}(n)[1], p)], \dots, {\cal V}[U(\mt{chan\_out}(n)[\mt{num\_out}(n)], p)]]
\end{equation*}}
That is, the function inputs a list of arrays, each of which
corresponds to an incoming channel $c_{in}$ and contains the
$O(c_{in},p)$ values that $n$ reads from $c_{in}$ in a given firing.
The procedure returns a list of arrays, each of which corresponds to
an outgoing channel $c_{out}$ and contains the $U(c_{out},p)$ values
that $n$ writes to $c_{out}$ in a given firing.

\end{itemize}

%The components $I$ and $W$ above are referred to as ``procedures''
%rather than mathematical functions because we expect them to be
%represented as blocks of source code for an actual procedure
%declaration, thereby allowing a straightforward conversion to a CSDP
%from a dataflow program.  However, 

