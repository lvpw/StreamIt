\begin{figure}[t]
\centering
\psfig{figure=FMRadio2.bloodgraph.spacetime_8_80_vs_raw.eps,width=3.0in}
\vspace{-6pt}
\caption{Execution trace of FMRadio 7x64 using (a) space multiplexing and (b) space-time multiplexing.
\protect\label{fig:bloodgraph}}
\end{figure}

\section{Results}
\label{sec:results}

\begin{figure*}[t]
\centering
\psfig{figure=benchmarks.eps,width=3in,angle=-90}
\vspace{-6pt}
\caption{Benchmark characteristics, performance evaluation and
comparison to space-multiplexing. 
\protect\label{fig:results}}
\end{figure*}
\begin{figure}[t]
\centering
\hspace{-0.1in}\psfig{figure=utilization.eps,width=2.15in, angle=-90}
\vspace{-6pt}
\caption{Processor utilization.
\protect\label{fig:util}}
\end{figure}

\begin{figure}[t]
\centering
\hspace{-0.1in}\psfig{figure=speedup.eps,width=2.15in, angle=-90}
\vspace{-6pt}
\caption{SpaceTime speedup over space-multiplexing.
\protect\label{fig:speedup}}
\end{figure}


We have completed a fully-automated SpaceTime compiler implementing
the execution model and algorithms as detailed in the previous
sections. Our current backend is for the Raw microprocessor. The
results of this paper were generated using btl, a cycle-accurate
simulator that models arrays of Raw tiles identical to those in the
.15 micron 16-tile Raw prototype ASIC chip.  With a target clock rate
of 450 MHz, the tile employs as compute processor an 8-stage, single
issue, in-order MIPS-style pipeline that has a 32 KB data cache, 32 KB
of instruction memory, and 64 KB of static router memory.

We evaluate the SpaceTime compiler for the set of benchmarks given in
\ref{fig:results}.  This benchmark set includes 5 different StreamIt
benchmarks, some with multiple configurations for a total of 25 data
points.  We gather throughput numbers for the benchmarks (in cycles
per output), utilization percentage (the percentage of time that an
{\it occupied tile} is not blocked on a send or receive), and we
compare the SpaceTime performance to the performance of a
space-multiplexing StreamIt compiler targeting Raw.  

We compile without code optimization for each compiler, so that we can
compiler the load balancing is prominent.  Furthermore, for the
SpaceTime compiler, we hand tune the work threshold described in
\ref{sec:extraction}.  We compile the code produced by each compiler
with GCC 3.3 with optimization level O3.

An example execution trace for the FMRadio with 7 equalizer ways and
64 taps.  In Figure \ref{fig:util} we show the processor utilization
graph for each benchmark. For these benchmarks roughly half the tiles
are utilized during steady-state; this number is uniformly consistent
across the benchmark suite.  Considering processor and communication
stalls over 16 tiles, these numbers are favorable.

In comparing to the space-multiplexing, over the benchmark suite we
have improved the load-balancing thus significantly reducing
communication stalls.  Note that our slice extractor creates many
small slices which helps the load balancing but increasing
communication to off-chip DRAM.  Over the benchmark suite the average
speedup over space-multiplexing is 1.38 with a maximum speed up of
2.67. The throughput comparison to space-multiplexing is given in
Figure \ref{fig:speedup}.
