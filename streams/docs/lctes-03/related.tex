\section{Related Work}
\label{chpt:related}

There has been a wealth of research on various stream languages
and projects.  This section will introduce some of the other
projects.

A large number of programming languages have included a concept of
a stream; see \cite{survey97} for a survey.  Synchronous languages
such as LUSTRE~\cite{lustre}, Esterel~\cite{esterel92}, and
Signal~\cite{signal} also target the embedded domain, but they are
more control-oriented than StreamIt and are not aggressively
optimized for performance.  Sisal (Stream and Iteration in a
Single Assignment Language) is a high-performance, implicitly
parallel functional language~\cite{sisal}.  The Distributed
Optimizing Sisal Compiler~\cite{sisal} considers compiling Sisal
to distributed memory machines, although it is implemented as a
coarse-grained master/slave runtime system instead of a
fine-grained static schedule.

Ptolemy \cite{ptolemyoverview} is a simulation environment for
heterogenous embedded systems, including Synchronous Data Flow,
the method used for {\StreamIt}. {\SDF} programs, however, do not
include the peeking constructs of {\StreamIt}.  In {\SDF} languages,
actors are the active computational elements ({\filters}).  {\SDF}
computation model does not impose structure on the program.  All
actors are allowed to have multiple input and output channels.
\cite{benveniste93dataflow} provides an overview of dataflow
synchronous languages.

There are many results of scheduling {\SDF} programs
\cite{leesdf}. Many of these results concentrate on reducing
buffering requirements. Many of the systems inline all actor code
into a single function, and try to minimize the code and buffer
size at once \cite{bhattacharyya99synthesis}.  This approach leads
to a strong preference for single appearance schedules.
{\StreamIt} scheduler stores the schedule and {\filter} code
separately, thus allowing for more efficient schedule storage.

Other publications focus on synthesis of software for embedded
systems. \cite{bhat1999x1} recognizes that non single-appearance
schedules which inline actor invocations have problems with code
growth.  A hybrid model is introduced, where actor invocations are
inlined unless the resulting code grow too large. If inlining is
not performed, actors are invoked through a function call.

Other approaches to reducing the buffering requirements use buffer
merging \cite{murthy99buffer}, a technique which will be explored
for {\StreamIt} in the future.

Many publications focus on synthesis for hardware systems.  Such
systems can execute multiple actors at once
\cite{govindarajan-minimizing}.  Currently {\StreamIt} compiler
produces code for uniprocessor architectures \cite{streamittech2}
and for the RAW processor \cite{gordo-thesis}.  RAW processor can
execute multiple {\filters} in parallel, but every parallel
execution is given its own separate set of resources like memory.

There are some streaming computation models which are less
constrained than {\SDF}. Most popular is Cyclic Synchronous Data Flow
CSDF computation model \cite{parks95comparison}.  CSDF actors have
multiple {\work} functions, with each one being allowed to
consume/produce different number of data items. The current
{\StreamIt} phased scheduler is able to accommodate this model of
computation, but the {\StreamIt} language does not support this
feature yet. \cite{streamittech3} provides an elegant solution to
scheduling CSDF programs using Systems of Affine Recurrence
Equations, which provides a closed-form solution scheduling for
any valid CSDF graph.

\cite{wauters96cyclodynamic} proposes a model where the flow of
data is not static, but may depend on data being processed. The
model is called Cyclo-Dynamic Data Flow (CDDF). This greatly helps
flexibility of programming, but prevents fully static scheduling
of programs. The U.S. Navy Processing Graph Method (PGM) uses a
version of {\SDF} with an equivalent of peeking \cite{goddard00navy}.
The paper is focused on real-time execution and provides analysis
and verification of latency of data flow through their system.
