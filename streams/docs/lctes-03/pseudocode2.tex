struct Phase {
  Stream str
  int push, pop, peek
  Phase child[]
}

// s: the stream to build schedule for
// maxPhases:  the maximum number of phases to build for <s>
// execCount:  how many times each child stream should execute
// initOrSteady:  the stage of the schedule we're building
void schedule (Stream s, int maxPhases, Stream->int execCount, int initOrSteady) {
  if (s is feedbackloop and maxPhases < phasesForFeedback(s, execCount))
    fail()
  top = getEntrance(s)
  bot = getExit(s)
  phasesLeft = maxPhases
  do {
    phase = Phase(s, 0, 0, 0, {})
    for c in {top, bot}, start[c] = execCount[c]
    do {
      // simulate top node
      childPhase = top.currentPhase()
      top.advancePhase()
      simulate(childPhase)
      execCount[top]--
      phase.child = insertSorted (phase.child, childPhase)
      phase.peek = max (phase.peek, phase.pop + childPhase.peek)
      phase.pop += childPhase.pop
      // execute other nodes as much as possible
      while (exists c \in s, c != top and canFire(c) ) {
        childPhase = c.currentPhase()
        c.advancePhase()
        simulate(childPhase)
        execCount[c]--
        phase.child = insertSorted (phase.child, childPhase)
        if (c==bot)
          phase.push += childPhase.push
      }
    } while (exists c \in {top, bot}, start[c] - execCount[c] < max(1, floor(start[c] / phasesLeft)))
    phasesLeft--
    s.addPhase(phase, initOrSteady)
  } while (exists c \in s, execCount[c] > 0)
}

Phase[] insertSorted (Phase[N] list, Phase child) {
  for i = N-1 downto 0
    if (list[i].str==child.str)
      return list[0...i] o child o list[i+1...N-1]
  return list o child
}
