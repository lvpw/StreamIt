\subsection{The {\StreamIt} Language}
\label{sec:streamit}

{\StreamIt} is an architecture-independent programming language for
high-performance streaming applications.  This section contains a very
brief overview of the semantics of {\StreamIt}.  We do not conncern
ourselves with the syntax of the language, as it is not relevant to
scheduling stream graphs. A more detailed description of the design
and rationale for {\StreamIt} can be found in~\cite{thies02streamit}
or on our website~\cite{streamitweb}.

\subsubsection{Language Constructs}

The basic unit of computation in {\StreamIt} is the {\filter}. A
{\filter} is a single-input, single-output block with a user-defined
procedure for translating input items to output items.  Every
{\filter} contains a {\work} function, which is comprised of one or
more atomic phases that the filter cycles through during its
steady-state execution. A filter can optionally declare a {\tt
prework} function that executes instead of {\tt work} on the first
invocation of the filter, if special startup behavior is desired.
Filters communicate with their neighbors via FIFO queues, called
{\Channels}, using the intuitive operations of {\tt push(value)}, {\tt
pop()}, and {\tt peek(index)}, where {\tt peek} returns the value at
position {\tt index} without dequeuing the item.  The number of items
that are pushed, popped, and peeked\footnote{{\small We define $peek$
as the total number of items read, including the items popped.  Thus,
we always have that $peek \ge pop$.}} on each invocation are declared
with each phase of the {\work} function.

%% {\StreamIt}'s representation of a filter is an improvement over
%% general-purpose languages.  In a procedural language, the analog of a
%% filter is a block of statements in a complicated loop nest.  There is
%% no clear abstraction barrier between one filter and another, and
%% high-volume stream processing is muddled with global variables and
%% control flow. The loop nest must be re-arranged if the input or output
%% ratios of a filter changes, and scheduling optimizations further
%% inhibit the readability of the code.

%% In an object-oriented language, one could implement a stream
%% abstraction as a library.  This avoids some of the problems associated
%% with a procedural loop nest, but the programming model is complicated
%% by efficiency concerns--to optimize cache performance, the entire
%% application processes blocks of data that complicate and obscure the
%% underlying algorithm.

%% In contrast to these alternatives, {\StreamIt} places the filter in its
%% own independent unit, making explicit the parallelism and inter-filter
%% communication while hiding the grungy details of scheduling and
%% optimization from the programmer.

{\StreamIt} provides three primitives for composing {\filters} into
hierarchical streams (see Figure~\ref{fig:steady-state}).  The
{\pipeline} construct cascades a set of filters in sequence, with the
output of one connected to the input of the next.  The {\splitjoin}
construct is used to specify independent parallel streams that diverge
from a common {\splitter} and merge into a common {\joiner}--for
example, in the Equalizer of Figure~\ref{fig:radio-ascoded}.  Within a
{\splitjoin}, a {\splitter} collects $o_s$ data from its {\Input}
{\Channel} and pushes $w_{s,i}$ data to its $i$th {\Output}
{\Channel}.  Likewise, a {\joiner} collects $w_{j,i}$ items from its
$i$th input {\Input}{\Channel} and pushes $u_j$ data to its
{\Output}{\Channel}.  {\StreamIt} currently supports two types of
{\splitters} ({\duplicate} and {\roundrobin}) and one type of
{\joiner} (\roundrobin).

The last control construct provides a means for creating cycles in the
stream graph: the {\feedbackloop}. A {\feedbackloop} contains a
{\joiner}, a body operator, a {\splitter}, and a loop operator.  A
{\feedbackloop} has an additional feature required to allow it to
begin computation: since at first there is no data on any {\Channels},
the program inserts data from a special function defined by the
{\feedbackloop} onto the {\Channel} connecting the loop child and the
{\joiner}. The amount of data pushed onto the feedback path is called
delay amount, denoted $delay_{fl}$, for a {\feedbackloop} $fl$.

\subsubsection{Design Rationale}

{\StreamIt} differs from other stream languages in the single-input,
single-output hierarchical structure that it imposes on streams.  This
structure aims to help the programmer by defining clean, composable
modules that admit a linear textual representation.  In addition, it
helps the compiler by restricting certain analyses to a local level
rather than dealing with global properties of a graph.

In the context of scheduling, hierarchy is also useful because it
allows for the separate compilation of program componenets.  This
enables creation of standardized libraries and their distribution in
binary form, rather than source code.  This ability may become
important as streaming languages become more widely used for larger
applications.

\begin{figure}[t]
\begin{center}
\hspace{0.1in} \psfig{figure=radio-ascoded.eps, width=2.8in}
\vspace{-36pt} \caption{\protect\small Block diagram of an FM
Radio. \protect\label{fig:radio-ascoded}}
%% \begin{minipage}{0.46in}
%% \centering
%% \psfig{figure=pipeline.eps,width=0.46in} \\
%% \end{minipage}
%% ~
%% \begin{minipage}{1.0in}
%% \centering
%% \psfig{figure=splitjoin.eps,width=0.57in} \\
%% \end{minipage}
%% ~
%% \begin{minipage}{1.02in}
%% \centering
%% \psfig{figure=feedback.eps,width=1.02in} \\
%% \end{minipage}
%% \\ ~ \\ {\bf \protect\small (a) \pipeline ~~~~ (b) \splitjoin ~~~~ (c) \feedbackloop}
%% \caption{\protect\small Stream structures supported by {\StreamIt}.
%% \protect\label{fig:structures}} \vspace{-12pt}
\end{center}
\end{figure}

%% \subsection{Messages}

%% {\StreamIt} provides a dynamic messaging system for passing irregular,
%% low-volume control information between filters and other stream
%% operators.  Messages
%% are sent from within the body of a filter's {\tt work} function,
%% perhaps to change a parameter in another filter.  The central aspect
%% of the messaging system is a sophisticated timing mechanism that
%% allows filters to specify when a message will be received relative to
%% the flow of data items between the sender and the receiver.  With the
%% messaging system, {\StreamIt} is equipped to support full application
%% development--not just high-bandwidth data channels, but also events,
%% control, and re-initialization.
