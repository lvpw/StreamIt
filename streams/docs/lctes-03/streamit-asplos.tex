\subsection{The {\StreamIt} Language}
\label{sec:streamit}

The source language for our scheduler is {\StreamIt}: an
architecture-independent programming language for high-performance
streaming applications.  This section contains a very brief overview
of the semantics of {\StreamIt}.  We do not concern ourselves with the
syntax of the language, as it is not relevant to scheduling stream
graphs. A more detailed description of the design and rationale for
{\StreamIt} can be found in~\cite{thies02streamit} or on our
website~\cite{streamitweb}.

\subsubsection{Language Constructs}

The basic unit of computation in {\StreamIt} is the {\filter}. A
{\filter} is a single-input, single-output block with a user-defined
procedure for translating input items to output items.  Every
{\filter} contains a {\work} function, which is comprised of one or
more atomic phases that the filter cycles through during its
steady-state execution. A filter can optionally declare a {\tt
prework} function that executes instead of {\tt work} on the first
invocation of the filter, if special startup behavior is desired.
Filters communicate with their neighbors via FIFO queues, called
{\Channels}, using the intuitive operations of {\tt push(value)}, {\tt
pop()}, and {\tt peek(index)}, where {\tt peek} returns the value at
position {\tt index} without dequeuing the item.  The number of items
that are pushed, popped, and peeked\footnote{{\small We define $peek$
as the total number of items read, including the items popped.  Thus,
we always have that $peek \ge pop$.}} on each invocation are declared
with each phase of the {\work} function.

\begin{figure}
\begin{center}

\begin{minipage}{0.7in}
\centering \psfig{figure=pipeline-buffers.eps,width=0.4049in}
\end{minipage}
~~~~~~
\begin{minipage}{0.8in}
\centering \psfig{figure=splitjoin-steady-state.eps,width=0.6in}
\end{minipage}
~~~~~~
\begin{minipage}{0.8in}
\centering \psfig{figure=feedback-steady-state.eps,width=0.79in}
\end{minipage}

\vspace{0.1in}

{\small ~~~~(a) a pipeline ~~~~~~~ (b) a splitjoin ~~~~ (c) a feedbackloop~~~~}

\caption{\small Sample {\StreamIt} operators.  Each node is labeled
with its peek, pop rates (at top) and push rate (at bottom).  The $L$
{\filter} has been flipped upside-down for clarity.
\label{fig:steady-state}}
\vspace{-18pt}
\end{center}
\end{figure}

%% {\StreamIt}'s representation of a filter is an improvement over
%% general-purpose languages.  In a procedural language, the analog of a
%% filter is a block of statements in a complicated loop nest.  There is
%% no clear abstraction barrier between one filter and another, and
%% high-volume stream processing is muddled with global variables and
%% control flow. The loop nest must be re-arranged if the input or output
%% ratios of a filter changes, and scheduling optimizations further
%% inhibit the readability of the code.

%% In an object-oriented language, one could implement a stream
%% abstraction as a library.  This avoids some of the problems associated
%% with a procedural loop nest, but the programming model is complicated
%% by efficiency concerns--to optimize cache performance, the entire
%% application processes blocks of data that complicate and obscure the
%% underlying algorithm.

%% In contrast to these alternatives, {\StreamIt} places the filter in its
%% own independent unit, making explicit the parallelism and inter-filter
%% communication while hiding the grungy details of scheduling and
%% optimization from the programmer.

{\StreamIt} provides three primitives for composing {\filters} into
hierarchical streams (see Figure~\ref{fig:steady-state}).  The
{\pipeline} construct cascades a set of filters in sequence, with the
output of one connected to the input of the next.  The {\splitjoin}
construct is used to specify independent parallel streams that diverge
from a common {\splitter} and merge into a common {\joiner}--for
example, in the Equalizer of Figure~\ref{fig:radio-ascoded}.  StreamIt
currently supports two types of splitters: duplicate, which broadcasts
its input items to each parallel stream, and round-robin, which
distributes items cyclically to one child after another according to
an array of weights.  The joiner node must be a roundrobin.

The last control construct provides a means for creating cycles in the
stream graph: the {\feedbackloop}. A {\feedbackloop} contains a
{\joiner}, a body operator, a {\splitter}, and a loop operator.  A
{\feedbackloop} has an additional feature to allow it to begin
computation: since there are no data items on the feedback path at
first, the stream needs to enqueue initial values onto the channel.
The number of items pushed onto the feedback path is called the delay,
denoted $delay_{fl}$, for a {\feedbackloop} $fl$.

\subsubsection{Design Rationale}

{\StreamIt} differs from other stream languages in the single-input,
single-output hierarchical structure that it imposes on streams.  This
structure aims to help the programmer by defining clean, composable
modules that admit a linear textual representation.  In addition, it
helps the compiler by restricting certain analyses to a local level
rather than dealing with global properties of the graph.  In the
context of scheduling, hierarchy is also useful because it allows for
the separate compilation of program components.  This enables
creation of standardized libraries and their distribution in binary
form, rather than source code.  This ability may become important as
streaming languages become more widely used for larger applications.

Another important feature of StreamIt---and one that requires special
support from the scheduler---is the peek construct.  By using the peek
command, a filter can examine input items at a given index without
dequeuing them from the channel.  This exposes to the compiler the
reuse of input items between successive invocations of a filter's work
function.  A primary example is an FIR filter, which pops 1 item but
peeks N items.  Without the capability to peek, the programmer would
have to maintain a persistent circular buffer within the filter to
retain previous input items.  Apart from being difficult to program,
this would greatly complicate compiler analysis.  In particular, the
linear analysis and optimization passes within the StreamIt compiler
benefit greatly from analyzing peek statements directly instead of
reverse-engineering internal filter state~\cite{lamb03}.

\begin{figure}[t]
\begin{center}
\hspace{0.1in} \psfig{figure=radio-ascoded.eps, width=2.8in}
\vspace{-24pt} \caption{\protect\small Block diagram of an FM
Radio. \protect\label{fig:radio-ascoded}}
\vspace{-18pt}
%% \begin{minipage}{0.46in}
%% \centering
%% \psfig{figure=pipeline.eps,width=0.46in} \\
%% \end{minipage}
%% ~
%% \begin{minipage}{1.0in}
%% \centering
%% \psfig{figure=splitjoin.eps,width=0.57in} \\
%% \end{minipage}
%% ~
%% \begin{minipage}{1.02in}
%% \centering
%% \psfig{figure=feedback.eps,width=1.02in} \\
%% \end{minipage}
%% \\ ~ \\ {\bf \protect\small (a) \pipeline ~~~~ (b) \splitjoin ~~~~ (c) \feedbackloop}
%% \caption{\protect\small Stream structures supported by {\StreamIt}.
%% \protect\label{fig:structures}} \vspace{-12pt}
\end{center}
\end{figure}

%% \subsection{Messages}

%% {\StreamIt} provides a dynamic messaging system for passing irregular,
%% low-volume control information between filters and other stream
%% operators.  Messages
%% are sent from within the body of a filter's {\tt work} function,
%% perhaps to change a parameter in another filter.  The central aspect
%% of the messaging system is a sophisticated timing mechanism that
%% allows filters to specify when a message will be received relative to
%% the flow of data items between the sender and the receiver.  With the
%% messaging system, {\StreamIt} is equipped to support full application
%% development--not just high-bandwidth data channels, but also events,
%% control, and re-initialization.
