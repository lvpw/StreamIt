\section{Layout}
\label{sec:layout}

The goal of the layout phase is to assign nodes in the stream graph to
computation nodes in the target architecture while minimizing the
communication and synchronization present in the final layout.  The
layout assigns exactly one node in the stream graph to one computation
node in the target.  The layout phase assumes that the given stream
graph will fit onto the computation fabric of the target and that the
filters are load balanced.  These requirements are satisfied by the
partitioning phase described above.

%Classically, layout (or placement) algorithms have fallen into two
%categories: constructive initial placement and iterative improvement
%\cite{layout}.  Both try to minimize a predetermined cost
%function.  In constructive initial placement, the algorithm calculates
%a solution from scratch, using the first complete placement
%encountered.  Iterative improvement starts with an initial random
%layout and repeatedly perturbs the placement in order to minimize the
%cost function.

%The layout phase of the StreamIt compiler is implemented using
%simulated annealing \cite{simanneal}, a type of
%iterative improvement.  A detailed explanation of simulated annealing
%is beyond the scope of this paper, but we will mention the following.
%Simulated annealing is a form of stochastic hill-climbing. Unlike most
%5other methods for cost function minimization, simulated annealing is
%suitable for problems where there are many local minima.  Simulated
%annealing achieves its success by allowing the system to go uphill
%with some probability as it searches for the global minima.  As the
%simulation proceeds, the probability of climbing uphill decreases.

The layout phase of the StreamIt compiler is implemented using
simulated annealing \cite{simanneal}.  We choose simulated annealing
for its combination of performance and flexibility.  To adapt the
layout phase for a given architecture, we supply the simulated
annealing algorithm with three architecture-specific parameters: a
cost function, a perturbation function, and the set of legal layouts.
To change the compiler to target one tiled architecture instead of
another, these parameters should require only minor modifications.

% To retarget the layout phase of the compiler, we simply supply the
% annealing algorithm with three elements: the cost function, a
% perturbation function, and the set of legal layouts.  Furthermore, for
% most tiled targets these three functions could be reused.

%Clearly, the choice of cost function will greatly determine the
%performance of the generated layout. 
The cost function should accurately measure the added communication
and synchronization generated by mapping the stream graph to the
communication model of the target.  Due to the static qualities of
StreamIt, the compiler can provide the layout phase with exact
knowledge of the communication properties of the stream graph.  The
terms of the cost function can include the counts of how many items
travel over each channel during an execution of the steady state.
Furthermore, with knowledge of the routing algorithm, the cost
function can infer the intermediate hops for each channel.  For
architectures with non-uniform communication, the cost of certain hops
might be weighted more than others.  In general, the cost function can
be tailored to suit a given architecture.

% Depending on the communication model of the target architecture, these
% metrics can be extremely important in generating a good layout.  For
% architectures with non-uniform communication, the layout phase can use
% this knowledge to take advantage of the specific properties of the
% architecture.

%For example, in a Smart Memories architecture
%\cite{smartmemories}, we would like to place the nodes that
%communicate over an expensive channel on the same quad.

\subsection{Layout for Raw}

For Raw, the layout phase maps nodes in the stream graph to the tile
processors.  Each filter is assigned to exactly one tile, and no tile
holds more than one filter.  However, the ends of a splitjoin
construct are treated differently; each splitter node is folded into
its upstream neighbor, and neighboring Joiner nodes are collapsed into
a single tile (see Section \ref{sec:rawcommunic}).  Thus, Joiners
occupy their own tile, but splitters are integrated into the tile of
another filter or Joiner.

Due to the properties of the static network and the communication
scheduler (Section \ref{sec:rawcommunic}), the layout phase does not
have to worry about deadlock.  All assignments of nodes to tiles are
legal.  This gives simulated annealing the flexibility to search many
possibilities and simplifies the layout phase.  The perturbation
function used in simulated annealing simply swaps the assignment of
two randomly chosen tile processors.

After some experimentation, we arrived at the following cost function
to guide the layout on Raw.  We let $channels$ denote the pairs of
nodes $\{(src_1, dst_1) \dots (src_N, dst_N)\}$ that are connected by
a channel in the stream graph; $layout(n)$ denote the placement of
node $n$ on the Raw grid; and \\ $route(src, dst)$ denote the path of
tiles through which a data item is routed in traveling from tile $src$
to tile $dst$.  In our implementation, the $route$ function is a
simple dimension-ordered router that traces the path from $src$ to
$dst$ by first routing in the X dimension and then routing in the Y
dimension.  Given fixed values of $channels$ and $route$, our cost
function evaluates a given layout of the stream graph:
\begin{align*}
& cost(layout) = & ~ \\ 
& ~~~~~~~~~\sum ~ {\bf items}(src,dst) \cdot \left( {\bf hops}(\mt{path})
   + 10 \cdot {\bf sync}(\mt{path}) \right) \\
  & \raisebox{4pt}[4pt]{\scriptsize {\it (src,dst)} $\in$ {\it channels}} \\
  & ~~~~~~~~~~~~\mbox{where } \mt{path} = route(layout(src), layout(dst))
\end{align*}

\begin{figure}
\centering
\psfig{figure=joiner-buffer-dead.eps,width=1.55in}
\vspace{-6pt}
\caption{\protect\small Example of deadlock in a splitjoin.  As the
joiner is reading items from the stream on the left, items accumulate
in the channels on the right.  On Raw, senders will block once a
channel has four items in it.  Thus, once 10 items have passed through
the joiner, the system is deadlocked, as the joiner is trying to read
from the left, but the stream on the right is blocked.  
%The Identity
%filter is blocking on the send of item \#10, and the splitter is
%blocking on the send of item \#20.  If the weights on the joiner were
%(10, 10), the system would be deadlock-free.
\protect\label{fig:joiner-dead}}
\vspace{28pt}
\psfig{figure=joiner-buffer-live.eps,width=2.99in}
\vspace{-6pt}
\caption{\protect\small Fixing the deadlock with a buffering joiner.
The buffering\_roundrobin is an internal StreamIt construct (it is not
part of the language) which reads items from its input channels in the
order in which they arrive, rather than in the order specified by its
weights.  The order of arrival is determined by a simulation of the
stream graph's execution; thus, the system is guaranteed to be
deadlock-free, as the order given by the simulation is feasible for
execution on Raw.  To preserve the semantics of the joiner, the items
are written to the output channel from the internal buffers in the
order specified by the joiner's weights.  The ordered items are sent
to the output as soon as they become available.
\protect\label{fig:joiner-live}}
\vspace{-12pt}
\end{figure}

In this equation, ${\bf items}(src, dst)$ gives the number of data
words that are transfered from $src$ to $dst$ during each steady state
execution, ${\bf hops}(p)$ gives the number of intermediate tiles
traversed on the path $p$, and ${\bf sync}(p)$ estimates the cost of
the synchronization imposed by the path $p$.  We calculate ${\bf
sync}(p)$ as the number of tiles along the route that are assigned a
stream node plus the number of tiles along the route that are involved
in routing {\it other} channels.

With the above cost function, we heavily weigh the added
synchronization imposed by the layout.  For Raw, this metric is far
more important than the length of the route because neighbor
communication over the static network is cheap.  If a tile that is
assigned a filter must route data items through it, then it must
synchronize the routing of these items with the execution of its {\tt
work} function.  Also, a tile that is involved in the routing of many
channels must serialize the routes running through it.  Both limit the
amount of parallelism in the layout and need to be avoided.

%% \begin{figure}
%% \centering
%% \psfig{figure=anneal-cost.eps,width=4in}
%% \parbox{4in}{\caption{\protect\small Estimated cost for successive
%% configurations of the load-balanced \Radar layout as evaluated by
%% the simulated annealing algorithm. \protect\label{fig:anneal-cost}}}
%% \end{figure}

%% Figure~\ref{fig:anneal-cost} illustrates how the cost metric varies
%% over time during a run of the simulated annealing algorithm for the
%% \Radar application.  The figure illustrates that the cost
%% converges to a value that is significantly lower than a random layout.
%% For the \Radar application, the layout determined by our
%% algorithm has a throughput that exceeds that of a random layout by a
%% factor of two.
