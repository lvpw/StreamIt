\section{Generalized Fission of Sliding Window Filters}

This section describes our technique for the fission of sliding window
filters. A key design goal for the implementation of fission 
was that communication between levels of the stream graph be efficient
(see Section~\ref{sec:levels} for the description of a level).  Often
when data parallelism is applied, the producer filters in level $l$ are
fissed at the same width as the consumer filters in level $l + 1$.  To
make this common case efficient, general graph fission communicates a
large number of items between disjoint producer-consumer pairs from the
levels.  Next, a small number of items (the number of items inspected by
the consumer filter) is duplicated and communicated from consumer to a
producer in a different pair.  

Our technique for filter fission employs an optimization termed {\it
  synchronization removal}.  This transformation is applied to nodes
calculating the identity function in the general graph such that they
can be removed, but their communication patterns remain embedded in
the general graph. A description of synchronization removal is beyond
the scope of this paper, for a complete exposition, please
see~\cite{mgordon-phd}.

Before we describe the fission transformation, we need to list the
preconditions that must hold before fission of $f$ by $P$ in the general
graph can be performed:
\begin{itemize}
\item $C(f) < (M(S,f) / P) \cdot o(W, f)$. The items remaining of
  the input buffer of the original filter after initialization must be
  less than the number of items dequeued by each fission product.

\item $M(S,f) \mod P = 0$. In this version of the algorithm we create
  fission products with equal work, an equal division of the original
  steady-state multiplicity of $f$.  This restriction can be relaxed
  via simple modifications to the algorithm.
\end{itemize}
\noindent All the multiplicities of the steady-state can be multiplied
by the same constant $c$, and the result will still be a valid
steady-state.  We call this process {\it increasing} the steady-state
of the graph by $c$.  Each of these preconditions can be enforced by
increasing the steady-state of the graph.

\begin{figure*}
\centering
\includegraphics[width=\textwidth]{figures/general-fission.pdf}
\caption[Fission of a node in the general stream graph.]{Fission of a
  node $f$ by $P$ in the general stream
  graph.\label{fig:general-fission}}
\end{figure*}

The details of fission on a filter of the general stream graph are
given in Figure~\ref{fig:general-fission}. 

To understand the transformation, we first need to understand the item
distribution and sharing that is required by fission on a filter $f$
that adheres to the preconditions above.
Figure~\ref{fig:fission-sharing2} gives another example of the input
items required by fission products.  In this example, both:

\[ C(f) = \mt{dup}_f < (M(S,f) / p) \cdot o(W, f) \]
\[ M(S, f) \mod P = 0\]

\noindent so $f$ adheres to the preconditions stipulated above for
general fission.  In the example, the items read for $f$ plus its
fission products for $P=4$ are shown for the initialization plus two
steady-states.  After the initialization stage, $C(f) = 2$ items are
enqueued to the input buffer by the producer(s) to $f$, and $M(S,f)
\cdot o(W, f) = 16$ items are enqueued by the producer(s) for each
steady-state.  Examining the sharing requirement for fission products of
the second steady-state, we can see a pattern emerge with the following
features:

\begin{itemize}
\item No item is read by more than 2 fission products.
\item  A fission product does not need to remember items across
  steady-state executions of itself.
\item Only the first fission product $f_1$ is required to receive the $C(f)$
  initialization  items because $C(F) < (M(S,f) / p) \cdot o(W, f)$,
  and it will consume the $C(f)$ items on its first invocation.
\item The presence of the $C(f)$ items in the input buffer after
  initialization must be accounted for by shifting the read pattern
  for the fission products.  The first fission product $f_1$ is offset by
  $C(f)$ items in that it reads its first $C(f)$ items from the
  previous execution stage.  In the steady-state, $f_1$ executing at
  steady-state iteration $i$ shares items with $f_P$ executing at
  steady-state iteration $i-1$.
\end{itemize}


\begin{figure*}
\centering
\includegraphics[width=\textwidth]{figures/split-pattern.pdf}
\caption[The output distribution required for general
fission.]{
The steady-state output distribution installed for identity node
$ID_I$ by general fission.  Red edges denote items that are shared
across fission products via duplication.  Though not demonstrated in
the example of Figure~\ref{fig:fission-sharing2}, in the general
case, if $C(f) > dup$, $C(f) - dup$ items at the end of the
steady-state input are distributed to $f_1$. \label{fig:split-pattern}}
\end{figure*}

The general fission transformation creates two identity nodes ($ID_I$
and $ID_O$) that are encoded to implemented the data distribution for
the fission products.  The pattern seen in
Figure~\ref{fig:fission-sharing2} and described above is common to the
transformation for all filters we seek to fiss that meet the
preconditions of the transformation.  This sharing pattern is encoded
in the output distribution pattern for the identity filter $ID_I$.
Figure~\ref{fig:split-pattern} shows the weights for the output
distribution and how these weights are distributed to the fission
products.

The input distribution of $ID_I$ is set to the input distribution of
$f$.  Thus, $ID_I$ joins data as described by $f$'s input
distribution, and splits data according to the fission output pattern
for sharing between at most 2 filters.  The output identity $ID_O$
collects the output items of the fission products in a weighted round
robin, and the distributes them according to $f$'s output distribution.

Since a fission product, does not need to remember items across
firing, a fission product's peek rate equals its pop rate in the
steady-state.  This rate equals the division of $f$'s dequeued
items plus the number of items inspected but not dequeued by $f$ for
each firing:   

\[ o(S,f_i) = e(S, f_i) = \frac{M(S, f)}{P} \cdot o(W, f) + \mt{dup} \]

\noindent The peeking of the original filter $f$ is now encoded in
the sharing across fission products achieved via the duplication
pattern.

The computation and communication performed by $f$ during the
initialization stage is transferred completely to the first fission
product, $f_1$.  Since, by construction, only $f_1$ requires the items
remaining after the initialization stage.  The other fission products
are idle during this stage.

The final steps of the general fission transformation applies
\textsc{SynchRemove} to remove the identity filters, and stitch the
communication directly between the fission products and $f$'s
producer(s) and consumer(s).
 

%  The process includes the
% following steps (Figure~\ref{fig:general-fission} illustrates steps
% 1-9): 
% \begin{enumerate}
% \item Create $P$ copies of $f$ and set their rates
% and work functions according to Figure~\ref{fig:general-fission}.
% \item Create two identity nodes, $ID_I$ and $ID_O$, that will encode
%   the distribution for the fission.
% \item Move the initialization stage computation of $f$ to $f_1$
%   according to Figure~\ref{fig:general-fission}. 
% \item Move input distribution of $f$ to $ID_I$
% replacing occurrences of $f$ with $ID_I$ in edges.
% \item Move output distribution of $f$ to $ID_O$, replacing
% occurrences of $f$ with $ID_O$ in edges.
% \item Create the fission duplication pattern in the
% output distribution of $ID_I$.
% \item Create a round robin joining pattern for the output identity
%   filter $ID_O$ to receive from each fission product.
% \item For each node $p$ that is a producer of $f$, replace the
%  occurrences of $f$ with $O_I$ in the edges of the dupsets of $p$'s
%  output distribution.
% \item For each node $c$ that is a consumer of $f$, replace the
%  occurrences of $f$ with $O_O$ in incoming edges $c$'s input
%  distribution.
% \item \textsc{SynchRemove}($ID_I$)
% \item \textsc{SynchRemove}($ID_O$)
% \end{enumerate}