Stream programs represent an important class of high-performance
computations.  Defined by their regular processing of sequences of
data, stream programs appear most commonly in the context of audio,
video, and digital signal processing, though also in networking,
encryption, and other areas.  Stream programs can be naturally
represented as a graph of independent actors that communicate
explicitly over data channels.  In this work we focus on programs
where the input and output rates of actors are known at compile time,
enabling aggressive transformations by the compiler; this model is
known as synchronous dataflow.

We develop a new programming language, StreamIt, that empowers both
programmers and compiler writers to leverage the unique properties of
the streaming domain.  StreamIt offers several new abstractions,
including hierarchical single-input single-output streams, composable
primitives for data reordering, and a mechanism called {\it teleport
messaging} that enables precise event handling in a distributed
environment.  We demonstrate the feasibility of developing
applications in StreamIt via a detailed characterization of our
34,000-line benchmark suite, which spans from MPEG-2 encoding/decoding
to GMTI radar processing.  We also present a novel dynamic analysis
for migrating legacy C programs into a streaming representation.

The central premise of stream programming is that it enables the
compiler to perform powerful optimizations.  We support this premise
by presenting a suite of new transformations.  We describe the first
translation of stream programs into the compressed domain, enabling
programs written for uncompressed data formats to automatically
operate directly on compressed data formats (based on LZ77).  This
technique offers a median speedup of 15x on common video editing
operations.  We also review other optimizations developed in the
StreamIt group, including automatic parallelization (offering an 11x
mean speedup on the 16-core Raw machine), optimization of linear
computations (offering a 5.5x average speedup on a Pentium~4), and
cache-aware scheduling (offering a 3.5x mean speedup on a StrongARM
1100).  While these transformations are beyond the reach of compilers
for traditional languages such as C, they become tractable given the
abundant parallelism and regular communication patterns exposed by the
stream programming model.
