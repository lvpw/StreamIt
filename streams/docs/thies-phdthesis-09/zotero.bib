@inbook{ellson_graphviz_2002,
	title = {Graphviz—-Open Source Graph Drawing Tools},
	journal = {Graph Drawing},
	author = {John Ellson and Emden Gansner and Lefteris Koutsofios and Stephen North and Gordon Woodhull},
	year = {2002},
	pages = {594--597}
},
@inproceedings{fisher_pads:domain-specific_2005,
	title = "{PADS: A Domain-Specific Language for Processing Ad Hoc Data}",
	booktitle = "{Conference on Programming Language Design and Implementation (PLDI)}",
	author = {Kathleen Fisher and Robert Gruber},
	year = {2005},
}
@inproceedings{barton_streaming_2003,
	title = "{Streaming XPath Processing with Forward and Backward Axes}",
	booktitle = "{International Conference on Data Engineering}",
	author = {C. Barton and P. Charles and Deepak  Goyal and Mukund  Raghavachari and M. Fontoura and V. Josifovski},
	year = {2003},
},
@article{medford_microsoft/yahoo_2008,
	title = "{Microsoft/Yahoo is Mobile Equal of Google}",
	url = {http://www.redherring.com/Home/23680},
	journal = {Red Herring},
	author = {Cassimir Medford},
	month = feb,
	year = {2008}
},
@article{watkins_mash_2006,
	title = "{Mash Hits}",
	journal = {The Guardian},
	author = {David Watkins},
	month = apr,
	year = {2006}
}
@book{stroustrup_design_1994,
	title = "{The Design and Evolution of C++}",
	publisher = {Addison-Wesley Professional},
	author = {Bjarne Stroustrup},
	month = apr,
	year = {1994},
},
@article{ashcroft_lucidnonprocedural_1977,
	title = "{Lucid, a Nonprocedural Language with Iteration}",
	volume = {20},
	number = {7},
	journal = "{Communications of the ACM}",
	author = {E. A. Ashcroft and W. W. Wadge},
	year = {1977},
	pages = {519--526}
},
@inproceedings{henderson_lazy_1976,
	title = "{A lazy evaluator}",
	booktitle = "{Symposium on Principles on Programming Languages (POPL)}",
	author = {Peter Henderson and James H. Morris},
	year = {1976},
},

@misc{nikhil_id_1991,
	title = "{ID Language Reference Manual, Version 90.1}",
	howpublished = "{Computation Structures Group Memo 284-2, Masscahusetts Institute of Technology}",
	author = {Rishiyur S.  Nikhil},
	month = jul,
	year = {1991},
},
@techreport{mcgraw_sisal:_1985,
	type = "{Language Reference Manual, Version 1.2}",
	title = "{SISAL: Streams and Iteration in a Single Assignment Language}",
	institution = "{Lawrence Livermore National Laboratory}",
	author = {J. McGraw and S. Skedzielewski and S. Allan and R. Oldhoeft and J. Glauert and C.C. Kirkham and B. Noyce and R. Thomas},
	month = mar,
	year = {1985}
},
@book{press_numerical_1992,
	edition = {2},
	title = "{Numerical Recipes in C: The Art of Scientific Computing}",
	publisher = "{Cambridge University Press}",
	author = {William H. Press and Brian P. Flannery and Saul A. Teukolsky and William T. Vetterling},
	month = oct,
	year = {1992},
},
@article{maraninchi_argos:automaton-based_2001,
	title = "{Argos: an Automaton-Based Synchronous Language}",
	volume = {27},
	number = {1-3},
	journal = "{Computer Languages}",
	author = {Florence Maraninchi and Yann Remond},
	month = oct,
	year = {2001},
	pages = {61--92}
},
@article{landin_correspondence_1965,
	title = "{Correspondence between ALGOL 60 and Church's Lambda-notation: Part I}",
	volume = {8},
	number = {2},
	journal = "{Communications of the ACM}",
	author = {P. J. Landin},
	year = {1965},
	pages = {89--101}
},
@article{le_guernic_signal--data_1986,
	title = "{Signal--A Data Flow-Oriented Language for Signal Processing}",
	volume = {34},
	number = {2},
	journal = {Acoustics, Speech and Signal Processing, IEEE Transactions on},
	author = {P. Le Guernic and A. Benveniste and P. Bournai and T. Gautier},
	year = {1986},
	pages = {362--374}
},

@inproceedings{gorlick_using_1991,
	title = {Using weaves for software construction and analysis},
	doi = {10.1109/ICSE.1991.130620},
	abstract = {The authors discuss the architectural features of weaves, their implementation, and their use in a variety of applications. Weaves are networks of concurrently executing tool fragments that communicate by passing objects. Weaves are distinguished from other dataflow styles by their emphasis on instrumentation, continuous observability, and dynamic rearrangement: basic low-overhead instrumentation is inserted automatically, executing weaves can be observed at any time by means of sophisticated analysis agents, without degrading the performance of the weave, and weaves can be dynamically snipped and spliced without interrupting the data flow},
	booktitle = {Software Engineering, 1991. Proceedings., 13th International Conference on},
	author = {M.M. Gorlick and R.R. Razouk},
	year = {1991},
	keywords = {analysis agents,concurrently executing tool fragments,continuous observability,dataflow styles,dynamic rearrangement,instrumentation,networks,object passing,parallel programming,software analysis,software construction,software engineering,weaves},
	pages = {23--34}
},

@article{buck_brook_2004,
	title = {Brook for GPUs: stream computing on graphics hardware},
	volume = {23},
	url = {http://portal.acm.org/citation.cfm?id=1015706.1015800\&coll=portal\&dl=ACM\&idx=J778\&part=transaction\&WantType=Transactions\&title=ACM\%20Transactions\%20on\%20Graphics\%20(TOG)},
	abstract = {In this paper, we present Brook for GPUs, a system for general-purpose computation on programmable graphics hardware. Brook extends C to include simple data-parallel constructs, enabling the use of the GPU as a streaming co-processor. We present a compiler and runtime system that abstracts and virtualizes many aspects of graphics hardware. In addition, we present an analysis of the effectiveness of the GPU as a compute engine compared to the CPU, to determine when the GPU can outperform the CPU for a particular algorithm. We evaluate our system with five applications, the SAXPY and SGEMV BLAS operators, image segmentation, FFT, and ray tracing. For these applications, we demonstrate that our Brook implementations perform comparably to hand-written GPU code and up to seven times faster than their CPU counterparts.},
	number = {3},
	journal = {ACM Trans. Graph.},
	author = {Ian Buck and Tim Foley and Daniel Horn and Jeremy Sugerman and Kayvon Fatahalian and Mike Houston and Pat Hanrahan},
	year = {2004},
	keywords = {brook,data parallel computing,gpu computing,programmable graphics hardware,stream computing},
	pages = {777--786}
},

@article{stephens_survey_1997,
	title = {A survey of stream processing},
	volume = {34},
	url = {http://dx.doi.org/10.1007/s002360050095},
	doi = {10.1007/s002360050095},
	abstract = {Abstract.    Stream processing is a term that is used widely in the literature to describe a variety of systems. We present an overview of the historical development of stream processing and a detailed discussion of the different languages and techniques for programming with streams that can be found in the literature. This includes an analysis of dataflow, specialized  functional and logic programming with streams, reactive systems, signal processing systems, and the use of streams in the design and verification of hardware. The aim of this survey is an analysis of the development of each of these specialized topics to determine if a general theory of stream processing has emerged. As such, we discuss and classify the different classes of stream processing systems found in the literature from the perspective of programming primitives, implementation techniques, and computability issues, including a comparison of the semantic models that are used to formalize stream based computation. },
	number = {7},
	journal = {Acta Informatica},
	author = {Robert Stephens},
	month = jul,
	year = {1997},
	pages = {491--541}
},

@book{nikhil_implicit_2001,
	edition = {1st},
	title = {Implicit Parallel Programming in pH},
	isbn = {1558606440},
	publisher = {Morgan Kaufmann},
	author = {Rishiyur Nikhil and Arvind},
	month = may,
	year = {2001},
	pages = {400}
},

@phdthesis{petri_communication_1962,
	type = {Ph.D. Thesis},
	title = {Communication with Automata},
	school = {Darmstadt Institue of Technology},
	author = {C.A. Petri},
	year = {1962}
},

@inproceedings{caspi_lustre:declarative_1987,
	address = {Munich, West Germany},
	title = {LUSTRE: a declarative language for real-time programming},
	isbn = {0-89791-215-2},
	url = {http://portal.acm.org/citation.cfm?id=41625.41641\&coll=ACM\&dl=ACM\&type=series\&idx=SERIES317\&part=series\&WantType=Proceedings\&title=POPL},
	abstract = {LUSTRE is a synchronous data-flow language for programming systems which interact with their environments in real-time. After an informal presentation of the language, we describe its semantics by means of structural inference rules. Moreover, we show how to use this semantics in order to generate efficient sequential code, namely, a finite state automaton which represents the control of the program. Formal rules for program transformation are also presented.},
	booktitle = {Proceedings of the 14th ACM SIGACT-SIGPLAN symposium on Principles of programming languages},
	publisher = {ACM},
	author = {P. Caspi and D. Pilaud and N. Halbwachs and J. A. Plaice},
	year = {1987},
	pages = {178--188}
},

@article{chen_convergence_2008,
	title = {Convergence of Recognition, Mining, and Synthesis Workloads and Its Implications},
	volume = {96},
	issn = {0018-9219},
	doi = {10.1109/JPROC.2008.917729},
	abstract = {This paper examines the growing need for a general-purpose ldquoanalytics enginerdquo that can enable next-generation processing platforms to effectively model events, objects, and concepts based on end-user input, and accessible datasets, along with an ability to iteratively refine the model in real-time. We find such processing needs at the heart of many emerging applications and services. This processing is further decomposed in terms of an integration of three fundamental compute capabilities-recognition, mining, and synthesis (RMS). The set of RMS workloads is examined next in terms of usage, mathematical models, numerical algorithms, and underlying data structures. Our analysis suggests a workload convergence that is analyzed next for its platform implications. In summary, a diverse set of emerging RMS applications from market segments like graphics, gaming, media-mining, unstructured information management, financial analytics, and interactive virtual communities presents a relatively focused, highly overlapping set of common platform challenges. A general-purpose processing platform designed to address these challenges has the potential for significantly enhancing users' experience and programmer productivity.},
	number = {5},
	journal = {Proceedings of the IEEE},
	author = {Yen-Kuang  Chen and J. Chhugani and P. Dubey and C.J. Hughes and Daehyun Kim and S. Kumar and V.W. Lee and A.D. Nguyen and M. Smelyanskiy},
	year = {2008},
	keywords = {Algorithms,data mining,data structures,emerging applications,financial analytics,gaming,general-purpose analytics engine,graphics,interactive virtual communities,mathematical models,media mining,numerical algorithms,parallel architectures,pattern recognition,synthesis workloads,unstructured information management},
	pages = {790--807}
},

@article{ashcroft_common_1980,
	title = {Some common misconceptions about Lucid},
	volume = {15},
	url = {http://portal.acm.org.libproxy.mit.edu/citation.cfm?id=947727.947728\&coll=GUIDE\&dl=GUIDE},
	doi = {10.1145/947727.947728},
	abstract = {This paper attempts to clear up several misconceptions about the language Lucid. In the process we claim that Lucid is in fact a real programming language, and indicate various ways in which implementations might be feasible.},
	number = {10},
	journal = {SIGPLAN Not.},
	author = {Ed Ashcroft and Bill Wadge},
	year = {1980},
	pages = {15--26}
},

@techreport{arvind_asynchronous_1978,
	title = {An asynchronous programming language and computing machine},
	number = {TR 114a},
	institution = {University of California, Irvine},
	author = {Arvind and K.P. Gostelow and W. Plouffe},
	year = {1978}
},

@inproceedings{consel_spidle:dsl_2003,
	address = {Erfurt, Germany},
	title = {Spidle: a DSL approach to specifying streaming applications},
	isbn = {3-540-20102-5},
	url = {http://portal.acm.org/citation.cfm?id=954187\&dl=GUIDE\&coll=GUIDE\&CFID=36821696\&CFTOKEN=74967313},
	abstract = {Multimedia stream processing is a rapidly evolving domain which requires much software development and expects high performance. Developing a streaming application often involves low-level programming, critical memory management, and finely tuned scheduling of processing steps.To address these problems, we present a domain-specific language (DSL) named {\textless}i{\textgreater}Spidle{\textless}/i{\textgreater}, for specifying streaming applications. Spidle offers high-level and declarative constructs; compared to general-purpose languages (GPL), it improves robustness by enabling a variety of verifications to be performed.To assess the expressiveness of Spidle in practice, we have used it to specify a number of standardized and special-purpose streaming applications. These specifications are up to 2 times smaller than equivalent programs written in a GPL such as C.We have implemented a compiler for Spidle. Preliminary results show that compiled Spidle programs are roughly as efficient as the compiled, equivalent C programs.},
	booktitle = {Proceedings of the 2nd international conference on Generative programming and component engineering},
	publisher = {Springer-Verlag New York, Inc.},
	author = {Charles Consel and Hedi Hamdi and Laurent Réveillère and Lenin Singaravelu and Haiyan Yu and Calton Pu},
	year = {2003},
	pages = {1--17}
},

@inproceedings{halbwachs_synchronous_1998,
	title = {Synchronous Programming of Reactive Systems},
	isbn = {3-540-64608-6},
	url = {http://portal.acm.org/citation.cfm?id=647767.733784\&coll=GUIDE\&dl=GUIDE\&CFID=827015\&CFTOKEN=22989611},
	booktitle = {Proceedings of the 10th International Conference on Computer Aided Verification},
	publisher = {Springer-Verlag},
	author = {Nicolas Halbwachs},
	year = {1998},
	pages = {1--16}
},

@misc{_streamit_2006,
	title = {StreamIt Language Specification, Version 2.1},
	url = {http://cag.csail.mit.edu/streamit/papers/streamit-lang-spec.pdf},
	month = sep,
	year = {2006}
},

@techreport{asanovic_landscape_2006,
	title = {The Landscape of Parallel Computing Research: A View from Berkeley},
	url = {http://www.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-183.html},
	number = {UCB/EECS-2006-183},
	institution = {EECS Department, University of California, Berkeley},
	author = {Krste Asanovic and Ras Bodik and Bryan Christopher Catanzaro and Joseph James Gebis and Parry Husbands and Kurt Keutzer and David A Patterson and William Lester Plishker and John Shalf and Samuel Webb Williams and Katherine A Yelick},
	month = dec,
	year = {2006}
},

@misc{mattson_streaming_2003,
	address = {Dedham, MA},
	title = {"Streaming" as a Pattern},
	url = {http://cag.csail.mit.edu/wss03/},
	author = {Peter Mattson and Richard Lethin},
	month = aug,
	year = {2003}
},

@article{dijkstra_go_1968,
	title = {Go to statement considered harmful},
	volume = {11},
	url = {http://portal.acm.org/citation.cfm?id=362929.362947},
	doi = {10.1145/362929.362947},
	abstract = {Note: OCR errors may be found in this Reference List extracted from the full text article. ACM has opted to expose the complete List rather than only correct and linked references.},
	number = {3},
	journal = {Commun. ACM},
	author = {Edsger W. Dijkstra},
	year = {1968},
	keywords = {alternative clause,branch instruction,conditional clause,go to statement,jump instruction,program intelligibility,program sequencing,repetitive clause},
	pages = {147--148}
},

@article{berry_esterel_1992,
	title = {The ESTEREL synchronous programming language: design, semantics, implementation},
	volume = {19},
	url = {http://portal.acm.org/citation.cfm?id=147276.147279},
	number = {2},
	journal = {Sci. Comput. Program.},
	author = {Gérard Berry and Georges Gonthier},
	year = {1992},
	pages = {87--152}
},

@article{johnston_advances_2004,
	title = {Advances in dataflow programming languages},
	volume = {36},
	url = {http://portal.acm.org/citation.cfm?id=1013208.1013209},
	doi = {10.1145/1013208.1013209},
	abstract = {Many developments have taken place within dataflow programming languages in the past decade. In particular, there has been a great deal of activity and advancement in the field of dataflow visual programming languages. The motivation for this article is to review the content of these recent developments and how they came about. It is supported by an initial review of dataflow programming in the 1970s and 1980s that led to current topics of research. It then discusses how dataflow programming evolved toward a hybrid von Neumann dataflow formulation, and adopted a more coarse-grained approach. Recent trends toward dataflow visual programming languages are then discussed with reference to key graphical dataflow languages and their development environments. Finally, the article details four key open topics in dataflow programming languages.},
	number = {1},
	journal = {ACM Comput. Surv.},
	author = {Wesley M. Johnston and J. R. Paul Hanna and Richard J. Millar},
	year = {2004},
	keywords = {component software,co-ordination languages,data flow visual programming,dataflow,graphical programming,multithreading,software engineering},
	pages = {1--34}
},

@inproceedings{colao_towardshigher-order_2004,
	address = {Pisa, Italy},
	title = {Towards a higher-order synchronous data-flow language},
	isbn = {1-58113-860-1},
	url = {http://portal.acm.org/citation.cfm?id=1017792\&dl=GUIDE\&coll=GUIDE},
	doi = {10.1145/1017753.1017792},
	abstract = {The paper introduces a higher-order synchronous data-flow language in which communication channels may themselves transport programs. This provides a mean to dynamically reconfigure data-flow processes. The language comes as a natural and strict extension of both lustre and lucy. This extension is conservative, in the sense that a first-order restriction of the language can receive the same semantics.We illustrate the expressivity of the language with some examples, before giving the formal semantics of the underlying calculus. The language is equipped with a polymorphic type system allowing types to be automatically inferred and a clock calculus rejecting programs for which synchronous execution cannot be statically guaranteed. To our knowledge, this is the first higher-order synchronous data-flow language where stream functions are first class citizens.},
	booktitle = {Proceedings of the 4th ACM international conference on Embedded software},
	publisher = {ACM},
	author = {Jean-Louis Colaço and Alain Girault and Grégoire Hamon and Marc Pouzet},
	year = {2004},
	keywords = {dynamic reconfiguration,functional programming,kahn processes,stream functions,synchronous data-flow programming language,type system},
	pages = {230--239}
},

@article{halbwachs_synchronous_1991,
	title = {The synchronous data flow programming language LUSTRE},
	volume = {79},
	issn = {0018-9219},
	doi = {10.1109/5.97300},
	abstract = {The authors describe LUSTRE, a data flow synchronous language designed for programming reactive systems-such as automatic control and monitoring systems-as well as for describing hardware. The data flow aspect of LUSTRE makes it very close to usual description tools in these domains (block-diagrams, networks of operators, dynamical sample-systems, etc.), and its synchronous interpretation makes it well suited for handling time in programs. Moreover, this synchronous interpretation allows it to be compiled into an efficient sequential program. The LUSTRE formalism is very similar to temporal logics. This allows the language to be used for both writing programs and expressing program properties, which results in an original program verification methodology},
	number = {9},
	journal = {Proceedings of the IEEE},
	author = {N. Halbwachs and P. Caspi and P. Raymond and D. Pilaud},
	year = {1991},
	keywords = {description tools,LUSTRE,parallel languages,program verification,program verification methodology,reactive systems,sequential program,synchronous data flow programming language,temporal logic,temporal logics},
	pages = {1305--1320}
},

@inproceedings{mark_cg:system_2003,
	address = {San Diego, California},
	title = {Cg: a system for programming graphics hardware in a C-like language},
	isbn = {1-58113-709-5},
	url = {http://portal.acm.org/citation.cfm?id=882362},
	doi = {10.1145/1201775.882362},
	abstract = {The latest real-time graphics architectures include programmable floating-point vertex and fragment processors, with support for data-dependent control flow in the vertex processor. We present a programming language and a supporting system that are designed for programming these stream processors. The language follows the philosophy of C, in that it is a hardware-oriented, general-purpose language, rather than an application-specific shading language. The language includes a variety of facilities designed to support the key architectural features of programmable graphics processors, and is designed to support multiple generations of graphics architectures with different levels of functionality. The system supports both of the major 3D graphics APIs: OpenGL and Direct3D. This paper identifies many of the choices that we faced as we designed the system, and explains why we made the decisions that we did.},
	booktitle = {ACM SIGGRAPH 2003 Papers},
	publisher = {ACM},
	author = {William R. Mark and R. Steven Glanville and Kurt Akeley and Mark J. Kilgard},
	year = {2003},
	pages = {896--907}
}
@article{bilsen_cycle-static_1996,
	title = {Cycle-static dataflow},
	volume = {44},
	issn = {1053-587X},
	doi = {10.1109/78.485935},
	abstract = {We present cycle-static dataflow (CSDF), which is a new model for the specification and implementation of digital signal processing algorithms. The CSDF paradigm is an extension of synchronous dataflow that still allows for static scheduling and, thus, a very efficient implementation of an application. In comparison with synchronous dataflow, it is more versatile because it also supports algorithms with a cyclically changing, but predefined, behavior. Our examples show that this capability results in a higher degree of parallelism and, hence, a higher throughput, shorter delays, and less buffer memory. Moreover, they indicate that CSDF is essential for modelling prescheduled components, like application-specific integrated circuits. Besides introducing the CSDF paradigm, we also derive necessary and sufficient conditions for the schedulability of a CSDF graph. We present and compare two methods for checking the liveness of a graph. The first one checks the liveness of loops, and the second one constructs a single-processor schedule for one iteration of the graph. Once the schedulability is tested, a makespan optimal schedule on a multiprocessor can be constructed. We also introduce the heuristic scheduling method of our graphical rapid prototyping environment (GRAPE) },
	number = {2},
	journal = {Signal Processing, IEEE Transactions on},
	author = {G. Bilsen and M. Engels and R. Lauwereins and J. Peperstraete},
	year = {1996},
	keywords = {application specific integrated circuits,application-specific integrated circuits,buffer memory,CSDF graph,CSDF paradigm,cycle-static dataflow,data flow graphs,digital signal processing algorithms,graph liveness,graph schedulability,graphical rapid prototyping environment,heuristic scheduling method,iteration,loops,makespan optimal schedule,multiprocessor,necessary conditions,parallel algorithms,processor scheduling,programming environments,signal processing,single-processor schedule,software prototyping,specification,static scheduling,sufficient conditions,synchronous dataflow,throughput},
	pages = {397--408}
},

@inproceedings{bilsen_cyclo-static_1995,
	title = {Cyclo-static data flow},
	volume = {5},
	isbn = {1520-6149},
	doi = {10.1109/ICASSP.1995.479579},
	abstract = {The high sample-rates involved in many DSP-applications, require the use of static schedulers wherever possible. The construction of static schedules however is classically limited to applications that fit in the synchronous data flow model. In this paper we present cyclo-static data flow as a model to describe applications with a cyclically changing behaviour. We give both a necessary and sufficient condition for the existence of a static schedule for a cyclo-static data flow graph and show how such a schedule can be constructed. The example of a video encoder is used to illustrate the importance of cyclo-static data flow for real-life DSP-systems},
	booktitle = {Acoustics, Speech, and Signal Processing, 1995. ICASSP-95., 1995 International Conference on},
	author = {G. Bilsen and M. Engels and R. Lauwereins and J.A. Peperstraete},
	year = {1995},
	keywords = {cyclically changing behaviour,cyclo-static data flow graph,data flow graphs,DSP systems,DSP-applications,high sample-rates,necessary condition,processor scheduling,signal sampling,static schedule,static schedulers,sufficient condition,synchronous data flow model,video coding,video encoder,video equipment},
	pages = {3255--3258 vol.5}
},

@article{karp_properties_1966,
	title = {Properties of a Model for Parallel Computations: Determinacy, Termination, Queueing},
	volume = {14},
	url = {http://link.aip.org/link/?SMM/14/1390/1},
	number = {6},
	journal = {SIAM Journal on Applied Mathematics},
	author = {Richard M. Karp and Rayamond E. Miller},
	year = {1966},
	pages = {1390--1411}
},

@article{murata_petri_1989,
	title = {Petri nets: Properties, analysis and applications},
	volume = {77},
	issn = {0018-9219},
	doi = {10.1109/5.24143},
	abstract = {Starts with a brief review of the history and the application areas considered in the literature. The author then proceeds with introductory modeling examples, behavioral and structural properties, three methods of analysis, subclasses of Petri nets and their analysis. In particular, one section is devoted to marked graphs, the concurrent system model most amenable to analysis. Introductory discussions on stochastic nets with their application to performance modeling, and on high-level nets with their application to logic programming, are provided. Also included are recent results on reachability criteria. Suggestions are provided for further reading on many subject areas of Petri nets},
	number = {4},
	journal = {Proceedings of the IEEE},
	author = {T. Murata},
	year = {1989},
	keywords = {behavioural properties,concurrent system model,high-level nets,logic programming,marked graphs,performance modeling,Petri nets,reachability criteria,stochastic nets,stochastic processes,structural properties,subclasses},
	pages = {541--580}
},

@phdthesis{greif_semantics_1975,
	type = {Ph.D. Thesis},
	title = {Semantics of Communicating Parallel Processes},
	school = {Massachusetts Insitute of Technology},
	author = {Irene Greif},
	year = {1975},
	keywords = {actors}
},

@article{hoare_communicating_1978,
	title = {Communicating sequential processes},
	volume = {21},
	url = {http://portal.acm.org/citation.cfm?id=359585},
	doi = {10.1145/359576.359585},
	abstract = {This paper suggests that input and output are basic primitives of programming and that parallel composition of communicating sequential processes is a fundamental program structuring method. When combined with a development of Dijkstra's guarded command, these concepts are surprisingly versatile. Their use is illustrated by sample solutions of a variety of a familiar programming exercises.},
	number = {8},
	journal = {Commun. ACM},
	author = {C. A. R. Hoare},
	year = {1978},
	keywords = {classes,concurrency,conditional critical regions,coroutines,data representations,guarded commands,input,iterative arrays,monitors,multiple entries,multiple exits,nondeterminacy,output,parallel programming,procedures,program structures,programming,programming languages,programming primitives,recursion},
	pages = {666--677}
},

@phdthesis{clinger_foundations_1981,
	type = {Ph.D. Thesis},
	title = {Foundations of Actor Semantics},
	school = {Massachusetts Insitute of Technology},
	author = {William Douglas Clinger},
	year = {1981},
	keywords = {actors}
},

@article{lee_static_1987,
	title = {Static scheduling of synchronous data flow programs for digital signal processing},
	volume = {36},
	url = {http://portal.acm.org/citation.cfm?id=22812.22814},
	number = {1},
	journal = {IEEE Trans. Comput.},
	author = {Edward Ashford Lee and David G. Messerschmitt},
	year = {1987},
	pages = {24--35}
},

@article{murthy_multidimensional_2002,
	title = {Multidimensional synchronous dataflow},
	volume = {50},
	issn = {1053-587X},
	doi = {10.1109/TSP.2002.800830},
	abstract = {Signal flow graphs with dataflow semantics have been used in signal processing system simulation, algorithm development, and real-time system design. Dataflow semantics implicitly expose function parallelism by imposing only a partial ordering constraint on the execution of functions. One particular form of dataflow called synchronous dataflow (SDF) has been quite popular in programming environments for digital signal processing (DSP) since it has strong formal properties and is ideally suited for expressing multirate DSP algorithms. However, SDF and other dataflow models use first-in first-out (FIFO) queues on the communication channels and are thus ideally suited only for one-dimensional (1-D) signal processing algorithms. While multidimensional systems can also be expressed by collapsing arrays into 1-D streams, such modeling is often awkward and can obscure potential data parallelism that might be present. SDF can be generalized to multiple dimensions; this model is called multidimensional synchronous dataflow (MDSDF). This paper presents MDSDF and shows how MDSDF can be efficiently used to model a variety of multidimensional DSP systems, as well as other types of systems that are not modeled elegantly in SDF. However, MDSDF generalizes the FIFO queues used in SDF to arrays and, thus, is capable only of expressing systems sampled on rectangular lattices. This paper also presents a generalization of MDSDF that is capable of handling arbitrary sampling lattices and lattice-changing operations such as nonrectangular decimation and interpolation. An example of a practical system is given to show the usefulness of this model. The key challenge in generalizing the MDSDF model is preserving static schedulability, which eliminates the overhead associated with dynamic scheduling, and preserving a model where data parallelism, as well as functional parallelism, is fully explicit},
	number = {8},
	journal = {Signal Processing, IEEE Transactions on},
	author = {P.K. Murthy and E.A. Lee},
	year = {2002},
	keywords = {algorithm development,communication channels,data flow computing,data flow graphs,data parallelism,dataflow semantics,digital signal processing,FIFO queues,first-in first-out queues,functional parallelism,graphical programming model,interpolation,lattice-changing operations,multidimensional DSP systems,multidimensional signal processing,multidimensional synchronous dataflow,multirate DSP algorithms,nonrectangular decimation,partial ordering constraint,programming environments,queueing theory,real-time system design,rectangular lattices,sampling lattices,signal flow graphs,signal processing system simulation,signal sampling,static scheduling},
	pages = {2064--2079}
},

@phdthesis{agha_actors:model_1985,
	type = {Ph.D. Thesis},
	title = {Actors:  A Model of Concurrent Computation in Distributed Systems},
	school = {Massachusetts Insitute of Technology},
	author = {Gul Agha},
	year = {1985},
	keywords = {actors}
},

@inproceedings{parks_comparison_1995,
	title = {A comparison of synchronous and cycle-static dataflow},
	url = {http://csdl2.computer.org/persagen/DLAbsToc.jsp?resourcePath=/dl/proceedings/\&toc=comp/proceedings/asilomar/1995/7370/00/7370toc.xml\&DOI=10.1109/ACSSC.1995.540541},
	abstract = {We compare synchronous dataflow (SDF) and cyclo-static dataflow (CSDF), which are each special cases of a model of computation we call dataflow process networks. In SDF actors have static firing rules: they consume and produce a fixed number of data tokens in each firing. This model is well suited to multirate signal processing applications and lends itself to efficient static scheduling, avoiding the run-time scheduling overhead incurred by general implementations of process networks. In CSDF which is a generalization of SDF actors have cyclically changing firing rules. In some situations, the added generality of CSDF can unnecessarily complicate the scheduling. We show how higher-order functions can be used to transform a CSDF graph into a SDF graph, simplifying the scheduling problem. In other situations, CSDF has a genuine advantage over SDF: simpler precedence constraints. We show how this makes it possible to eliminate unnecessary computations and expose additional parallelism. We use digital sample rate conversion as an example to illustrate these advantages of CSDF. },
	booktitle = {Asilomar Conference on Signals, Systems, and Computers},
	author = {Thomas M Parks and Jose Luis Pino and Edward A Lee},
	month = oct,
	year = {1995},
	keywords = {data flow computing; scheduling; data flow graphs; signal sampling; cycle-static dataflow; synchronous dataflow; computation model; dataflow process networks; static firing rules; data tokens; multirate signal processing applications; static scheduling; higher-order functions; CSDF graph; SDF graph; scheduling problem; precedence constraints; parallelism; digital sample rate conversion}
},

@article{kahn_semantics_1974,
	title = {The semantics of a simple language for parallel programming},
	journal = {Information Processing},
	author = {G Kahn},
	year = {1974},
	pages = {471--475}
},

@inproceedings{hewitt_universal_1973,
	title = {A Universal Modular ACTOR Formalism for Artificial Intelligence},
	booktitle = {IJCAI},
	author = {Carl Hewitt and Peter Bishop and Richard Steiger},
	year = {1973},
	keywords = {actors},
	pages = {235--245}
}
@inproceedings{ceng_maps:integrated_2008,
	title = {MAPS: An integrated framework for MPSoC application parallelization},
	isbn = {0738-100X},
	abstract = {In the past few years, MPSoC has become the most popular solution for embedded computing. However, the challenge of programming MPSoCs also comes as the biggest side-effect of the solution. Especially, when designers have to face the legacy C code accumulated through the years, the tool support is mostly unsatisfactory. In this paper, we propose an integrated framework, MAPS, which aims at parallelizing C applications for MPSoC platforms. It extracts coarse-grained parallelism on a novel granularity level. A set of tools have been developed for the framework. We will introduce the major components and their functionalities. Two case studies will be given, which demonstrate the use of MAPS on two different kinds of applications. In both cases the proposed framework helps the programmer to extract parallelism efficiently.},
	booktitle = {Design Automation Conference, 2008. DAC 2008. 45th ACM/IEEE},
	author = {J. Ceng and J. Castrillon and W. Sheng and H. Scharwachter and R. Leupers and G. Ascheid and H. Meyr and T. Isshiki and H. Kunieda},
	year = {2008},
	keywords = {coarse-grained parallelism,Embedded,embedded computing,embedded systems,integrated framework,legacy C code,MAPS,MPSoC application parallelization,MPSoC Programming,multiprocessing systems,multiprocessor system-on-chip,parallel programming,Parallelization,Software,system-on-chip,toread},
	pages = {754--759}
}
@inproceedings{buck_heterogeneous_2000,
	title = {Heterogeneous modeling and simulation of embedded systems in El Greco},
	abstract = {This paper describes the functional specification and verification portions of El Greco, a system for high-level, heterogeneous functional specification, efficient compiled simulation, and software and hardware implementation. Specifications in the form of dataflow graphs, hierarchical finite state machines, or a mixture, are supported. These specifications can be arbitrarily nested, as in Ptolemy. When dataflow graphs are placed in a control context, the graph execution is fully controllable; its execution can be restarted or suspended and parameters can be changed. We describe system modeling and simulation generation in El Greco and compare to other approaches.},
	booktitle = {Hardware/Software Codesign, 2000. CODES 2000. Proceedings of the Eighth International Workshop on},
	author = {J. Buck and R. Vaidyanathan},
	year = {2000},
	keywords = {compiled simulation,data flow graphs,dataflow graphs,digital simulation,El Greco,embedded systems,finite state machines,formal specification,formal verification,functional specification,hardware-software codesign,simulation generation,verification},
	pages = {142--146}
},

@techreport{lee_overview_2003,
	title = {Overview of the Ptolemy Project},
	number = {UCB/ERL M03/25},
	institution = {University of California, Berkeley},
	author = {Edward A Lee},
	year = {2003}
},

@inproceedings{murthy_system_2001,
	address = {Copenhagen, Denmark},
	title = {System canvas: a new design environment for embedded DSP and telecommunication systems},
	isbn = {1-58113-364-2},
	url = {http://portal.acm.org/citation.cfm?id=371675},
	doi = {10.1145/371636.371675},
	abstract = {We present a new design environment, called System Canvas, targeted at DSP and telecommunication system designs. Our environment uses an easy-to-use block-diagram syntax to specify systems at a very high level of abstraction. The block diagram syntax is based on formal semantics, and uses a number of different models of computation including cyclo-static dataflow, dynamic dataflow, and a discrete-event model. A key feature of our tool is that the user does not need to have an awareness of which model is being used; the models can be freely mixed and matched and a simulation can consist of an arbitrary combination of models. The blocks are written in `C'or `C++' and it is straightforward to write custom blocks and incorporate them into custom libraries. Other key features include the ability to control simulations via language-neutral scripts, and a powerful optimization engine that enables optimization of the system over arbitrarily specified parameters, constraints, and cost functions. Fixed-point analysis capability allows any signal or variable in the system to be set to any type of number system before the simulation proceeds. The tool is available on the Windows NT platform and incorporates modern and ubiquitous Windows GUI look and feel.},
	booktitle = {Proceedings of the ninth international symposium on Hardware/software codesign},
	publisher = {ACM},
	author = {Praveen K. Murthy and Etan G. Cohen and Steve Rowland},
	year = {2001},
	pages = {54--59}
},

@inproceedings{liu_perts:prototyping_1993,
	title = {PERTS: A prototyping environment for real-time systems},
	doi = {10.1109/REAL.1993.393502},
	abstract = {PERTS is a prototyping environment for real-time systems. It contains schedulers and resource access protocols for time-critical applications, together with a comprehensive set of tools for the analysis, validation, and evaluation of real-time systems built on the scheduling paradigms supported by these building blocks. This paper describes the underlying models of real-time systems supported by PERTS, as well as its capabilities and intended use. A key component is the schedulability analyzer. The basic version of this system of tools supports the validation and evaluation of real-time systems built on the framework of the periodic-task model. This system of tools is now available},
	booktitle = {Real-Time Systems Symposium, 1993., Proceedings.},
	author = {J.W.S. Liu and J.L. Redondo and Z. Deng and T.S. Tia and R. Bettati and A. Silberman and M. Storch and R. Ha and W.K. Shih},
	year = {1993},
	keywords = {analysis,evaluation,performance evaluation,periodic-task model,PERTS,program verification,prototyping environment,real-time systems,resource access protocols,schedulability analyzer,schedulers,scheduling,software prototyping,software tools,time-critical applications,validation},
	pages = {184--188}
},

@article{eker_taming_2003,
	title = {Taming heterogeneity - the Ptolemy approach},
	volume = {91},
	issn = {0018-9219},
	doi = {10.1109/JPROC.2002.805829},
	abstract = {Modern embedded computing systems tend to be heterogeneous in the sense of being composed of subsystems with very different characteristics, which communicate and interact in a variety of ways-synchronous or asynchronous, buffered or unbuffered, etc. Obviously, when designing such systems, a modeling language needs to reflect this heterogeneity. Today's modeling environments usually offer a variant of what we call amorphous heterogeneity to address this problem. This paper argues that modeling systems in this manner leads to unexpected and hard-to-analyze interactions between the communication mechanisms and proposes a more structured approach to heterogeneity, called hierarchical heterogeneity, to solve this problem. It proposes a model structure and semantic framework that support this form of heterogeneity, and discusses the issues arising from heterogeneous component interaction and the desire for component reuse. It introduces the notion of domain polymorphism as a way to address these issues.},
	number = {1},
	journal = {Proceedings of the IEEE},
	author = {J. Eker and J.W. Janneck and E.A. Lee and Jie Liu and Xiaojun Liu and J. Ludvig and S. Neuendorffer and S. Sachs and Yuhong Xiong},
	year = {2003},
	keywords = {component reuse,component-based design,domain polymorphism,embedded computing systems,embedded systems,heterogeneous modeling,hierarchical heterogeneity,modeling environments,models of computation,object-oriented programming,programming environments,Ptolemy,Ptolemy II,software architecture,software environment,software reusability},
	pages = {127--144}
},

@article{lauwereins_grape-ii:system-level_1995,
	title = {Grape-II: a system-level prototyping environment for DSP applications},
	volume = {28},
	issn = {0018-9162},
	doi = {10.1109/2.347998},
	abstract = {We propose a rapid-prototyping setup to minimize development cost and a structured-prototyping methodology to reduce programming effort. The general-purpose hardware consists of commercial DSP processors, bond-out versions of core processors, and field-programmable gate arrays (FPGAs) linked to form a powerful, heterogeneous multiprocessor, such as the Paradigm RP developed within the Retides (Real-Time DSP Emulation System) Esprit project. Our Graphical Rapid Prototyping Environment (Grape-II) automates the prototyping methodology for these hardware systems by offering tools for resource estimation, partitioning, assignment, routing, scheduling, code generation, and parameter modification. Grape-II has been used successfully in three real-world DSP applications},
	number = {2},
	journal = {Computer},
	author = {R. Lauwereins and M. Engels and M. Ade and J.A. Peperstraete},
	year = {1995},
	keywords = {assignment,code generation,commercial DSP processors,configuration management,core processors,development cost,development systems,DSP applications,Esprit project,field-programmable gate arrays,general purpose computers,general purpose reusable hardware,general-purpose hardware,Grape-II,Graphical Rapid Prototyping Environment,heterogeneous multiprocessor,multiprocessing systems,partitioning,programming environments,rapid-prototyping,Real-Time DSP Emulation System,resource estimation,Retides,routing,scheduling,signal processing,software prototyping,software tools,structured-prototyping methodology,system-level prototyping environment},
	pages = {35--43}
},

@article{lee_gabriel:design_1989,
	title = {Gabriel: a design environment for DSP},
	volume = {37},
	issn = {0096-3518},
	doi = {10.1109/29.46557},
	abstract = {Gabriel is a software system intended to manage the complete development of real-time digital signal processing (DSP) applications, from conception and experimentation to implementation in real-time hardware. It performs non-real-time simulations as well as code synthesis for real-time hardware. It is intended to ease code development for architectures that are not easy targets for conventional compilers, such as multiprocessor systems built with very high-performance microcoded DSPs. The system is designed to be retargetable in two ways. First, it can synthesize code for a variety of multi-DSP architectures where the user specifies the salient features of the architecture. Second, it can target different DSPs. The authors have concentrated on code generation for the Motorola DSP56001, although code generation for the AT\&T DSP32 has been demonstrated. At the highest level, an algorithm is described using a hierarchical block diagram. At the lowest level, the user can either simulate the algorithm locally on the workstation, simulate the target architecture running the generated code, or download the code into hardware and run it in real time. Gabriel is capable of handling multiple sample rates, iteration, and recurrences},
	number = {11},
	journal = {Acoustics, Speech and Signal Processing, IEEE Transactions on},
	author = {E.A. Lee and W.-H. Ho and E.E. Goei and J.C. Bier and S. Bhattacharyya},
	year = {1989},
	keywords = {AT\&,code synthesis,computerised signal processing,digital signal processing chips,DSP,Gabriel,hierarchical block diagram,Motorola DSP56001,multi-DSP architectures,programming environments,real-time digital signal processing,real-time hardware,software system,T DSP32},
	pages = {1751--1762}
},

@inproceedings{buck_multirate_1991,
	title = {Multirate signal processing in Ptolemy},
	isbn = {1520-6149},
	doi = {10.1109/ICASSP.1991.150620},
	abstract = {The use of two models of computation, synchronous dataflow (SDF) and dynamic dataflow (DDF), to design and implement signal processing applications with multiple sample rates is discussed. The SDF model is used for synchronous applications. SDF is amenable to compile-time scheduling, and hence is much more efficient at runtime. The design environment, Ptolemy, can simultaneously support multiple models of computation, so SDF and DDF can be combined in a single application. Hence, the implementation will incur the run-time cost of DDF only for those asynchronous portions that absolutely must incur such cost. As an illustration, the authors detail a synchronous application, sample-rate conversion using polyphase filters, and an asynchronous application, timing recovery for an amplitude-shift-keyed signal},
	booktitle = {Acoustics, Speech, and Signal Processing, 1991. ICASSP-91., 1991 International Conference on},
	author = {J. Buck and S. Ha and E.A. Lee and D.G. Messerschmitt},
	year = {1991},
	keywords = {amplitude-shift-keyed signal,asynchronous application,circuit CAD,circuit simulation,compile-time scheduling,computer aided design,design environment,digital simulation,dynamic dataflow,multiple sample rates,polyphase filters,Ptolemy,run-time cost,sample-rate conversion,signal processing,signal processing applications,software tools,synchronisation,synchronous dataflow,timing recovery},
	pages = {1245--1248 vol.2}
}
@inproceedings{bhattacharyya_self-timed_1996,
	title = {Self-Timed Resynchronization: A Post-Optimization for Static Multiprocessor Schedules},
	isbn = {0-8186-7255-2},
	url = {http://portal.acm.org.libproxy.mit.edu/citation.cfm?id=645606.660850\&coll=GUIDE\&dl=GUIDE},
	abstract = {In a shared-memory multiprocessor system, it is possible that certain synchronization operations are redundant - that is, their corresponding sequencing requirements are enforced completely by other synchronizations in the system - and can be eliminated without compromising correctness. This paper addresses the problem of adding new synchronization operations in a multiprocessor implementation in such a way that the number of original synchronizations that consequently become redundant significantly exceeds the number of new synchronizations. We refer to this approach to reducing synchronization overhead as resynchronization. In this paper we formally define the resynchronization problem, we show that optimal resynchronization is NP-hard, and we propose a family of heuristics for this problem. Finally we present a practical example where resynchronization is useful.},
	booktitle = {Proceedings of the 10th International Parallel Processing Symposium},
	publisher = {IEEE Computer Society},
	author = {Shuvra S. Bhattacharyya and Sundararajan Sriram and Edward A. Lee},
	year = {1996},
	keywords = {embedded systems,inter-processor communication overhead,multiprocessors,scheduling,static schedules,synchronization},
	pages = {199--205}
},

@article{murthy_shared_2001,
	title = {Shared buffer implementations of signal processing systems using lifetime analysis techniques},
	volume = {20},
	issn = {0278-0070},
	abstract = {There has been a proliferation of block-diagram environments for specifying and prototyping digital signal processing (DSP) systems. These include tools from academia such as Ptolemy and commercial tools such as DSPCanvas from Angeles Design Systems, signal processing work system (SPW) from Cadence, and COSSAP from Synopsys. The block diagram languages used in these environments are usually based on dataflow semantics because various subsets of dataflow have proven to be good matches for expressing and modeling signal processing systems. In particular, synchronous dataflow (SDF) has been found to be a particularly good match for expressing multirate signal processing systems. One of the key problems that arises during synthesis from an SDF specification is scheduling. Past work on scheduling from SDF has focused on optimization of program memory and buffer memory under a model that did not exploit sharing opportunities. In this paper, we build on our previously developed analysis and optimization framework for looped schedules to formally tackle the problem of generating optimally compact schedules for SDF graphs. We develop techniques for computing these optimally compact schedules in a manner that also attempts to minimize buffering memory under the assumption that buffers will be shared. This results in schedules whose data memory usage is drastically lower than methods in the past have achieved. The method we use is that of lifetime analysis; we develop a model for buffer lifetimes in SDF graphs and develop scheduling algorithms that attempt to generate schedules that minimize the maximum number of live tokens under the particular buffer lifetime model. We develop several efficient algorithms for extracting the relevant lifetimes from the SDF schedule. We then use the well-known first-fit heuristic for packing arrays efficiently into memory. We report extensive experimental results on applying these techniques to several practical SDF systems and show improvements that average 50\% over previous techniques, with some systems exhibiting up to an 83\% improvement over previous techniques },
	number = {2},
	journal = {Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on},
	author = {P.K. Murthy and S.S. Bhattacharyya},
	year = {2001},
	keywords = {block-diagram environments,buffer lifetime model,buffer lifetimes,buffer storage,data flow computing,data memory usage,dataflow semantics,digital signal processing chips,digital signal processing systems,dynamic programming,first-fit heuristic,graph colouring,lifetime analysis techniques,live tokens,multirate signal processing,optimally compact schedules,program compilers,scheduling,shared buffer implementations,shared memory systems,storage allocation,synchronous dataflow},
	pages = {177--198}
},

@inproceedings{stuijk_exploring_2006,
	address = {San Francisco, CA, USA},
	title = {Exploring trade-offs in buffer requirements and throughput constraints for synchronous dataflow graphs},
	isbn = {1-59593-381-6},
	url = {http://portal.acm.org/citation.cfm?id=1146909.1147138},
	doi = {10.1145/1146909.1147138},
	abstract = {Multimedia applications usually have throughput constraints. An implementation must meet these constraints, while it minimizes resource usage and energy consumption. The compute intensive kernels of these applications are often specified as Synchronous Dataflow Graphs. Communication between nodes in these graphs requires storage space which influences throughput. We present exact techniques to chart the Pareto space of throughput and storage trade-offs, which can be used to determine the minimal storage space needed to execute a graph under a given throughput constraint. The feasibility of the approach is demonstrated with a number of examples.},
	booktitle = {Proceedings of the 43rd annual conference on Design automation},
	publisher = {ACM},
	author = {Sander Stuijk and Marc Geilen and Twan Basten},
	year = {2006},
	keywords = {buffering,optimization,synchronous dataflow,throughput},
	pages = {899--904}
},

@inproceedings{murthy_minimizing_1994,
	title = {Minimizing memory requirements for chain-structured synchronous dataflow programs},
	volume = {ii},
	doi = {10.1109/ICASSP.1994.389625},
	abstract = {This paper addresses trade-offs between the minimization of program memory and data memory requirements in the compilation of dataflow programs for multirate signal processing. Our techniques are specific to the synchronous dataflow (SDF) model of Lee and Messerschmitt (1987), which has been used extensively in software synthesis environments for DSP. We focus on programs that are represented as chain-structured SDF graphs. We show that there is an O(n 3) dynamic programming algorithm for determining a schedule that minimizes data memory usage among the set of schedules that minimize program memory usage. A practical example to illustrate the efficacy of this approach is given. Some extensions of this algorithm are also given; for example, we show that the algorithm applies to the more general class of well-ordered graphs},
	booktitle = {Acoustics, Speech, and Signal Processing, 1994. ICASSP-94., 1994 IEEE International Conference on},
	author = {P.K. Murthy and S.S. Bhattacharyya and E.A. Lee},
	year = {1994},
	keywords = {chain-structured SDF graphs,chain-structured synchronous dataflow programs,data flow computing,data flow graphs,data memory,digital storage,DSP,dynamic programming,dynamic programming algorithm,memory requirements minimisation,minimisation,multirate signal processing,program memory,signal processing,software synthesis environments,well-ordered graphs},
	pages = {II/453--II/456 vol.2}
},

@inproceedings{bhattacharyya_optimal_1995,
	title = {Optimal parenthesization of lexical orderings for DSP block diagrams},
	doi = {10.1109/VLSISP.1995.527489},
	abstract = {Minimizing memory requirements for program and data are critical objectives when synthesizing software for embedded DSP applications. Previously, it has been demonstrated that for graphical programs based on the widely-used synchronous dataflow model an important class of minimum code size implementations can be viewed as parenthesizations of lexical orderings of the computational blocks. Such a parenthesization corresponds to the hierarchy of loops in the software implementation. In this paper, we present a dynamic programming technique for constructing a parenthesization that minimizes data memory cost from a given lexical ordering of a synchronous dataflow graph. For graphs that do not contain delays, this technique always constructs a parenthesization that has minimum data memory cost from among all parenthesizations for the given lexical ordering. When delays are present, the technique may make refinements to the lexical ordering while it is computing the parenthesization, and the data memory cost of the result is guaranteed to be less than or equal to the data memory cost of all valid parenthesizations for the initial lexical ordering},
	booktitle = {VLSI Signal Processing, VIII, 1995. IEEE Signal Processing Society [Workshop on]},
	author = {S.S. Bhattacharyya and P.K. Murthy and E.A. Lee},
	year = {1995},
	keywords = {code size,data flow graphs,data memory,delays,digital signal processing chips,DSP block diagrams,dynamic programming,lexical orderings,microprogramming,optimal parenthesization,software synthesis,synchronous dataflow graph},
	pages = {177--186}
},

@inproceedings{teich_3d_1999,
	address = {Rome, Italy},
	title = {3D exploration of software schedules for DSP algorithms},
	isbn = {1-58113-132-1},
	url = {http://portal.acm.org/citation.cfm?id=301177.301522\&type=series},
	doi = {10.1145/301177.301522},
	abstract = {Note: OCR errors may be found in this Reference List extracted from the full text article. ACM has opted to expose the complete List rather than only correct and linked references.},
	booktitle = {Proceedings of the seventh international workshop on Hardware/software codesign},
	publisher = {ACM},
	author = {J. Teich and E. Zitzler and S. S. Bhattacharyya},
	year = {1999},
	pages = {168--172}
},

@inproceedings{ad_data_1997,
	address = {Anaheim, California, United States},
	title = {Data memory minimisation for synchronous data flow graphs emulated on DSP-FPGA targets},
	isbn = {0-89791-920-3},
	url = {http://portal.acm.org/citation.cfm?id=266036\&coll=portal\&dl=ACM},
	doi = {10.1145/266021.266036},
	abstract = {The paper presents an algorithm to determine the close-to-smallestpossible data buffer sizes for arbitrary synchronous dataflow (SDF) applications, such that we can guarantee the existenceof a deadlock free schedule. The presented algorithm fits inthe design flow of GRAPE, an environment for the emulation andimplementation of digital signal processing (DSP) systems onarbitrary target architectures, consisting of programmable DSPprocessors and FPGAs. Reducing the size of data buffers is ofhigh importance when the application will be mapped on FieldProgrammable Gate Arrays (FPGA), since register resources arerather scarce.},
	booktitle = {Proceedings of the 34th annual conference on Design automation},
	publisher = {ACM},
	author = {Marleen AdÃ© and Rudy Lauwereins and J. A. Peperstraete},
	year = {1997},
	pages = {64--69}
},

@article{ko_beyond_2007,
	title = {Beyond single-appearance schedules: Efficient DSP software synthesis using nested procedure calls},
	volume = {6},
	url = {http://portal.acm.org.libproxy.mit.edu/citation.cfm?doid=1234675.1234681},
	doi = {10.1145/1234675.1234681},
	abstract = {Synthesis of digital signal-processing (DSP) software from dataflow-based formal models is an effective approach for tackling the complexity of modern DSP applications. In this paper, an efficient method is proposed for applying subroutine call instantiation of module functionality when synthesizing embedded software from a dataflow specification. The technique is based on a novel recursive decomposition of subgraphs in a cluster hierarchy that is optimized for low buffer size. Applying this technique, one can achieve significantly lower buffer sizes than what is available for minimum code size inlined schedules, which have been the emphasis of prior work on software synthesis. Furthermore, it is guaranteed that the number of procedure calls in the synthesized program is polynomially bounded in the size of the input dataflow graph, even though the number of module invocations may increase exponentially. This recursive decomposition approach provides an efficient means for integrating subroutine-based module instantiation into the design space of DSP software synthesis. The experimental results demonstrate a significant improvement in buffer cost, especially for more irregular multirate DSP applications, with moderate code and execution time overhead.},
	number = {2},
	journal = {Trans. on Embedded Computing Sys.},
	author = {Ming-Yung Ko and Praveen K. Murthy and Shuvra S. Bhattacharyya},
	year = {2007},
	keywords = {block diagram compiler,design methodology,embedded systems,hierarchical graph decomposition,memory optimization,procedural implementation,synchronous dataflow},
	pages = {14}
},

@article{zitzler_multidimensional_2000,
	title = {Multidimensional Exploration of Software Implementationsfor DSP Algorithms},
	volume = {24},
	url = {http://portal.acm.org/citation.cfm?id=342496.342522},
	abstract = {When implementing software for programmable digital signal processors (PDSPs), the design space is defined by a complex range of constraints and optimization objectives. Three implementation metrics that are crucial in many PDSP applications are the program memory requirement (code size), data memory requirement, and execution time. This paper addresses the problem of exploring the 3-dimensional space of trade-offs that is defined by these crucial metrics. Given a software library for a target PDSP, and a dataflow-based block diagram specification of a DSP application in terms of this library, our objective in this paper is to compute a full range of Pareto-optimal solutions. For solving this multi-objective optimization problem, an evolutionary algorithm based approach is applied. We illustrate our techniques by analyzing the trade-off fronts of a practical application for a number of well-known, commercial PDSPs.},
	number = {1},
	journal = {J. VLSI Signal Process. Syst.},
	author = {Eckart Zitzler and JÃ¼rgen Teich and Shuvra S. Bhattacharyya},
	year = {2000},
	pages = {83--98}
},

@inproceedings{bhattacharya_quasi-static_2000,
	title = {Quasi-Static Scheduling of Reconfigurable Dataflow Graphs for DSP Systems},
	isbn = {0-7695-0668-2},
	url = {http://portal.acm.org/citation.cfm?id=827261.828219},
	abstract = {Dataflow programming has proven to be popular for representing applications in rapid prototyping tools for digital signal processing (DSP); however, existing dataflow design tools are limited in their ability to effectively handle dynamic application behavior. In this paper, we develop efficient quasi-static scheduling techniques for a broad class of dynamically reconfigurable dataflow specifications. We use a CD to DAT sample rate conversion system and a speech compression application to illustrate the efficacy of our scheduling techniques in real life DSP systems.},
	booktitle = {Proceedings of the 11th IEEE International Workshop on Rapid System Prototyping (RSP 2000)},
	publisher = {IEEE Computer Society},
	author = {Bishnupriya Bhattacharya and Shuvra S. Bhattacharyya},
	year = {2000},
	keywords = {cd-dat,configurable computing,dataflow,digital signal processing,rapid prototyping,software synthesis},
	pages = {84}
},

@inproceedings{geilen_minimising_2005,
	address = {Anaheim, California, USA},
	title = {Minimising buffer requirements of synchronous dataflow graphs with model checking},
	isbn = {1-59593-058-2},
	url = {http://portal.acm.org/citation.cfm?id=1065579.1065796},
	doi = {10.1145/1065579.1065796},
	abstract = {Signal processing and multimedia applications are often implemented on resource constrained embedded systems. It is therefore important to find implementations that use as little resources as possible. These applications are frequently specified as synchronous dataflow graphs. Communication between actors of these graphs requires storage capacity. In this paper, we present an exact method to determine the minimum storage capacity required to execute the graph using model-checking techniques. This can be done for different measures of storage capacity. The problem is known to be NP-complete and because of this, existing buffer minimisation techniques are heuristics and hence not exact. Modern model-checking tools are quite efficient and they have been successfully applied to scheduling-related problems. We study the feasibility of this approach with examples.},
	booktitle = {Proceedings of the 42nd annual conference on Design automation},
	publisher = {ACM},
	author = {Marc Geilen and Twan Basten and Sander Stuijk},
	year = {2005},
	keywords = {buffering,model-checking,optimization,synchronous dataflow},
	pages = {819--824}
},

@book{bhattacharyya_software_1996,
	title = {Software Synthesis from Dataflow Graphs},
	isbn = {0792397223},
	url = {http://portal.acm.org/citation.cfm?id=547038},
	abstract = {From the Publisher:Software Synthesis from Dataflow Graphs addresses the problem of generating efficient software implementations from applications specified as synchronous dataflow graphs for programmable digital signal processors (DSPs) used in embedded real-time systems. Software Synthesis from Dataflow Graphs reviews the state-of-the-art in constructing static, memory-optimal schedules for programs expressed as SDF graphs. Code size reduction is obtained by the careful organization of loops in the target code. Data buffering is optimized by constructing the loop hierarchy in provably optimal ways for many classes of SDF graphs. The central result is a uniprocessor scheduling framework that provably synthesizes the most compact looping structures, called single appearance schedules, for a certain class of SDF graphs. In addition, algorithms and heuristics are presented that generate single appearance schedules optimized for data buffering usage. Numerous practical examples and extensive experimental data are provided to illustrate the efficacy of these techniques.},
	publisher = {Kluwer Academic Publishers},
	author = {Shuvra S. Bhattacharyya and Praveen K. Murthy and Edward A. Lee},
	year = {1996},
	pages = {192}
},

@article{govindarajan_minimizing_2002,
	title = {Minimizing Buffer Requirements under Rate-Optimal Schedule in Regular Dataflow Networks},
	volume = {31},
	url = {http://dx.doi.org/10.1023/A:1015452903532},
	doi = {10.1023/A:1015452903532},
	abstract = {Large-grain synchronous dataflow graphs or multi-rate graphs have the distinct feature that the nodes of the dataflow graph fire at different rates. Such multi-rate large-grain dataflow graphs have been widely regarded as a powerful programming model for DSP applications. In this paper we propose a method to minimize buffer storage requirement in constructing rate-optimal compile-time (MBRO) schedules for multi-rate dataflow graphs. We demonstrate that the constraints to minimize buffer storage while executing at the optimal computation rate (i.e. the maximum possible computation rate without storage constraints) can be formulated as a unified linear programming problem in our framework. A novel feature of our method is that in constructing the rate-optimal schedule, it directly minimizes the memory requirement by choosing the schedule time of nodes appropriately. Lastly, a new circular-arc interval graph coloring algorithm has been proposed to further reduce the memory requirement by allowing buffer sharing among the arcs of the multi-rate dataflow graph.},
	number = {3},
	journal = {The Journal of VLSI Signal Processing},
	author = {R. Govindarajan and Guang R. Gao and Palash Desai},
	month = jul,
	year = {2002},
	pages = {207--229}
},

@article{murthy_buffer_2004,
	title = {Buffer merging--a powerful technique for reducing memory requirements of synchronous dataflow specifications},
	volume = {9},
	url = {http://portal.acm.org/citation.cfm?id=989995.989999},
	doi = {10.1145/989995.989999},
	abstract = {We develop a new technique called buffer merging for reducing memory requirements of synchronous dataflow (SDF) specifications. SDF has proven to be an attractive model for specifying DSP systems, and is used in many commercial tools like System Canvas, SPW, and Cocentric. Good synthesis from an SDF specification depends crucially on scheduling, and memory is an important metric for generating efficient schedules. Previous techniques on memory minimization have either not considered buffer sharing at all, or have done so at a fairly coarse level (the meaning of this will be made more precise in the article). In this article, we develop a buffer overlaying strategy that works at the level of an input/output edge pair of an actor. It works by algebraically encapsulating the lifetimes of the tokens on the input/output edge pair, and determines the maximum amount of the input buffer space that can be reused by the output. We develop the mathematical basis for performing merging operations, and develop several algorithms and heuristics for using the merging technique for generating efficient implementations. We show improvements of up to 48\&percnt; over previous techniques.},
	number = {2},
	journal = {ACM Trans. Des. Autom. Electron. Syst.},
	author = {Praveen K. Murthy and Shuvra S. Bhattacharyya},
	year = {2004},
	keywords = {array lifetime,block diagram compiler,buffer overlaying,dataflow,design methodology,dsp and embedded systems,graph coloring,lifetime analysis,memory optimization,path covering,synchronous dataflow},
	pages = {212--237}
},

@inproceedings{ko_memory-constrained_2006,
	title = {Memory-constrained Block Processing Optimization for Synthesis of DSP Software},
	doi = {10.1109/ICSAMOS.2006.300820},
	abstract = {Digital signal processing (DSP) applications involve processing long streams of input data. It is important to take into account this form of processing when implementing embedded software for DSP systems. Task-level vectorization, or block processing, is a useful dataflow graph transformation that can significantly improve execution performance by allowing subsequences of data items to be processed through individual task invocations. In this way, several benefits can be obtained, including reduced context switch overhead, increased memory locality, improved utilization of processor pipelines, and use of more efficient DSP-oriented addressing modes. On the other hand, block processing generally results in increased memory requirements since it effectively increases the sizes of the input and output values associated with processing tasks. In this paper, we investigate the memory-performance tradeoff associated with block processing. We develop novel block processing algorithms that take carefully take into account memory constraints to achieve efficient block processing configurations within given memory space limitations. Our experimental results indicate that these methods derive optimal memory-constrained block processing solutions most of the time. We demonstrate the advantages of our block processing techniques on practical kernel functions and applications in the DSP domain},
	booktitle = {Embedded Computer Systems: Architectures, Modeling and Simulation, 2006. IC-SAMOS 2006. International Conference on},
	author = {Ming-Yung  Ko and Chung-Ching  Shen and Shuvra S.  Bhattacharyya},
	year = {2006},
	keywords = {data flow analysis,data flow graphs,dataflow graph transformation,digital signal processing application,DSP software synthesis,DSP-oriented addressing mode,embedded software,embedded systems,memory locality,memory-constrained block processing optimization algorithm,optimising compilers,processor pipeline utilization,signal processing,storage management,task-level vectorization},
	pages = {137--143}
},

@inproceedings{chandrachoodan_efficient_2001,
	title = {An efficient timing model for hardware implementation of multirate dataflow graphs},
	volume = {2},
	doi = {10.1109/ICASSP.2001.941126},
	abstract = {We consider the problem of representing timing information associated with functions in a dataflow graph used to represent a signal processing system in the context of high-level hardware (architectural) synthesis. This information is used for synthesis of appropriate architectures for implementing the graph. Conventional models for timing suffer from shortcomings that make it difficult to represent timing information in a hierarchical manner, especially for multirate signal processing systems. We identify some of these shortcomings, and provide an alternate model that does not have these problems. We show that with some reasonable assumptions on the way hardware implementations of multirate systems operate, we can derive general hierarchical descriptions of multirate systems similarly to single rate systems. Several analytical results such as the computation of the iteration period bound, that previously applied only to single rate systems can also easily be extended to multirate systems under the new assumptions. We have applied our model to several multirate signal processing applications, and obtained favorable results. We present results of the timing information computed for several multirate DSP applications that show how the new treatment can streamline the problem of performance analysis and synthesis of such systems},
	booktitle = {Acoustics, Speech, and Signal Processing, 2001. Proceedings. (ICASSP '01). 2001 IEEE International Conference on},
	author = {N. Chandrachoodan and S.S. Bhattacharyaa and K.J.R. Liu},
	year = {2001},
	keywords = {data flow graphs,efficient timing model,hardware implementation,hierarchical descriptions,hierarchical timing pair model,high level synthesis,high-level hardware synthesis,iteration period bound,multirate dataflow graphs,multirate DSP applications,multirate FIR filter,multirate signal processing systems,performance analysis,signal processing,systems synthesis,timing,timing information representation},
	pages = {1153--1156 vol.2}
}
@phdthesis{aziz_image-based_2007,
	type = {M.Eng. Thesis},
	title = {Image-Based Motion Estimation in a Stream Programming Language},
	url = {http://cag.lcs.mit.edu/commit/papers/07/aziz-meng-thesis.pdf},
	school = {Massachusetts Institute of Technology},
	author = {Abdulbasier Aziz},
	month = jun,
	year = {2007}
},

@phdthesis{lamb_linear_2003,
	type = {M.Eng. Thesis},
	title = {Linear Analysis and Optimization of Stream Programs},
	url = {http://cag.lcs.mit.edu/commit/papers/03/aalamb-meng-thesis.pdf},
	school = {Massachusetts Institute of Technology},
	author = {Andrew A. Lamb},
	month = may,
	year = {2003}
},

@phdthesis{karczmarek_constrained_2002,
	type = {S.M. Thesis},
	title = {Constrained and Phased Scheduling of Synchronous Data Flow Graphs for StreamIt Language},
	url = {http://cag.lcs.mit.edu/commit/papers/02/karczma-thesis-SM.pdf},
	school = {Massachusetts Institute of Technology},
	author = {Michal Karczmarek},
	month = dec,
	year = {2002}
},

@phdthesis{wong_modelingscalability_2004,
	type = {M.Eng. Thesis},
	title = {Modeling the Scalability of Acyclic Stream Programs},
	url = {http://cag.lcs.mit.edu/commit/papers/04/wong-meng-thesis.pdf},
	school = {Massachusetts Institute of Technology},
	author = {Jeremy Wong},
	year = {2004}
},

@phdthesis{kuo_streamit_2004,
	type = {M.Eng. Thesis},
	title = {The StreamIt Development Tool: A Programming Environment for StreamIt},
	url = {http://cag.lcs.mit.edu/commit/papers/04/kkuo-meng-thesis.pdf},
	school = {Massachusetts Institute of Technology},
	author = {Kimberly Kuo},
	month = jun,
	year = {2004}
},

@phdthesis{agrawal_linear_2004,
	type = {M.Eng. Thesis},
	title = {Linear State-Space Analysis and Optimization of StreamIt Programs},
	url = {http://cag.lcs.mit.edu/commit/papers/04/sitij-meng-thesis.pdf},
	school = {Massachusetts Institute of Technology},
	author = {Sitij Agrawal},
	month = aug,
	year = {2004}
},

@phdthesis{drake_stream_2006,
	type = {M.Eng. Thesis},
	title = {Stream Programming for Image and Video Compression},
	url = {http://cag.lcs.mit.edu/commit/papers/06/madrake-meng-thesis.pdf},
	school = {Massachusetts Institute of Technology},
	author = {Matthew Drake},
	month = may,
	year = {2006}
},

@phdthesis{reyes_graph_2004,
	type = {M.Eng. Thesis},
	title = {A Graph Editing Framework for the StreamIt Language},
	url = {http://cag.lcs.mit.edu/commit/papers/04/reyes-meng-thesis.pdf},
	school = {Massachusetts Institute of Technology},
	author = {Juan C Reyes},
	month = jun,
	year = {2004}
},

@phdthesis{zhang_streaming_2007,
	type = {M.Eng. Thesis},
	title = {A Streaming Computation Framework for the Cell Processor},
	url = {http://cag.lcs.mit.edu/commit/papers/07/zhang-meng-thesis.pdf},
	school = {Massachusetts Institute of Technology},
	author = {Xin David Zhang},
	month = aug,
	year = {2007}
},

@phdthesis{sermulins_cache_2005,
	type = {M.Eng. Thesis},
	title = {Cache Optimizations for Stream Programs},
	url = {http://cag.lcs.mit.edu/commit/papers/05/sermulins-meng-thesis.pdf},
	school = {Massachusetts Institute of Technology},
	author = {Janis Sermulins},
	month = may,
	year = {2005}
},

@phdthesis{gordon_stream-aware_2002,
	type = {S.M. Thesis},
	title = {A Stream-Aware Compiler for Communication-Exposed Architectures},
	url = {http://cag.lcs.mit.edu/commit/papers//02/mgordon-thesis-SM.pdf},
	school = {Massachusetts Institute of Technology},
	author = {Michael Gordon},
	month = aug,
	year = {2002}
}
@inproceedings{kudlur_orchestratingexecution_2008,
	address = {Tucson, AZ, USA},
	title = {Orchestrating the execution of stream programs on multicore platforms},
	isbn = {978-1-59593-860-2},
	url = {http://portal.acm.org.libproxy.mit.edu/citation.cfm?id=1375581.1375596\&jmp=cit\&coll=GUIDE\&dl=GUIDE},
	doi = {10.1145/1375581.1375596},
	abstract = {While multicore hardware has become ubiquitous, explicitly parallel programming models and compiler techniques for exploiting parallelism on these systems have noticeably lagged behind. Stream programming is one model that has wide applicability in the multimedia, graphics, and signal processing domains. Streaming models execute as a set of independent actors that explicitly communicate data through channels. This paper presents a compiler technique for planning and orchestrating the execution of streaming applications on multicore platforms. An integrated unfolding and partitioning step based on integer linear programming is presented that unfolds data parallel actors as needed and maximally packs actors onto cores. Next, the actors are assigned to pipeline stages in such a way that all communication is maximally overlapped with computation on the cores. To facilitate experimentation, a generalized code generation template for mapping the software pipeline onto the Cell architecture is presented. For a range of streaming applications, a geometric mean speedup of 14.7x is achieved on a 16-core Cell platform compared to a single core.},
	booktitle = {Proceedings of the 2008 ACM SIGPLAN conference on Programming language design and implementation},
	publisher = {ACM},
	author = {Manjunath Kudlur and Scott Mahlke},
	year = {2008},
	keywords = {cell processor,multicore,software pipelining,stream programming,streamit},
	pages = {114--124}
},

@phdthesis{chen_load-balanced_2005,
	type = {M.Eng. Thesis},
	title = {Load-balanced rendering on a general-purpose tiled architecture},
	copyright = {M.I.T. theses are protected by copyright. They may be viewed from this source for any purpose, but reproduction or distribution in any format is prohibited without written permission. See provided URL for inquiries about permission.},
	url = {http://dspace.mit.edu/handle/1721.1/33115},
	school = {Massachusetts Insitute of Technology},
	author = {Jiawen Chen},
	year = {2005},
	note = {Thesis (M. Eng.)--Massachusetts Institute of Technology, Dept. of Electrical Engineering and Computer Science, 2005.},
	keywords = {Electrical Engineering and Computer Science.}
}
