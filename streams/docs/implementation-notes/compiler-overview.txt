This document provides an overview of the organization of the StreamIt
compiler.  The compiler is build on top of version 1 of the Kopi Java
compiler, which is an open-source Java compiler that is written in
Java.  It is available from:

http://www.dms.at/kopi/

Kopi 2 has been released, to support Java generics and ASSERT
statements, but we haven't seen it necessary to incorporate their
changes as of yet.  

Compiler Flow
-------------

Here's the general flow of the compiler as it stands now:

0. The StreamIt frontend reads in a source file, and converts it to
   "old syntax" Java code; the main entry point is
   src/streamit/frontend/ToJava.java.

1. The Kopi scanner/parser reads in a source file (see
   src/at/dms/kjc/Main.java)

2. The Kopi system type-checks the code and resolves object references
   to point to actual objects instead of just symbolic names. (see
   src/at/dms/kjc/Main.java)

3. We translate the Kopi IR into a StreamIt high ir (SIR) consisting
   of a stream graph of filters, pipelines, splitjoins, and
   feedbackloops.  The class that does this translation is
   kjc/Kopi2SIR; the toplevel streamit stuff is in kjc/StreaMITMain.

4. We have some passes that operate on the sir code, such as:

   Constant Propagation / Loop Unrolling    kjc/sir/lowering/ConstantProp.java
   Field Propagation			    kjc/sir/lowering/FieldProp
   
   The constant prop. and loop unrolling is used to expand the
   parameterized structure of the IR into a static graph.

   There are also a set of graph transformations that can re-arrange
   filters in the graph, convert to and from different canonical
   forms, and adjust the granularity by fusing many filters into one
   or fissing one filter into many:
     kjc/sir/lowering/partition/RefactorSplitJoin.java
     kjc/sir/lowering/partition/RefactorPipeline.java
     kjc/sir/lowering/fusion/Lifter.java
     kjc/sir/lowering/fission/StatelessDuplicate.java
     kjc/sir/lowering/fission/VerticalFission.java

   These phases are used for partitioning and optimization, discussed below.

-----

Then the flow splits up into two parts, one for Raw and one for the
uniprocessor backend.

Raw Backend
-----------

The Raw side of the project (in kjc/raw) does partitioning, layout,
and communication scheduling for a Raw backend.  This generally works
by conversion to a flat, unstructured graph, and then simulation of
the execution according to a legal schedule.  The toplevel controller
for the raw backend is kjc/raw/RawBackend.java.  You can trace the
modules that it calls in the backend from there.

There are two partitioning algorithms implemented to do automatic
load-balancing on Raw:

 - dynamic programming 
    - in kjc/sir/lowering/partition/dynamicprogramming
    - global analysis of large space of partitioning options
    - can use stream transformations to adjust graph to facilitate
      partitioning

 - greedy algorithm
    - in kjc/sir/lowering/partition/GreedyPartitioner.java
    - locally fuses the filters with the least amount of work
    - generally performs significantly (~2X) worse than dynamic programming

The Raw backend will output a series of tile and switch files that you
can compile for the raw simulator by typing "make".  You can do "make
-f Makefile.streamit debug" to run the simulator, and "make -f
Makefile.streamit run" to just run it.  See the StreamIt Cookbook for
more detailed instructions.

Uniprocessor Backend
--------------------

The uniprocessor backend differs from the Raw backend in that the
entire filter graph is scheduled to run in serial, and the resulting
code is linked with a runtime library to do the scheduling at runtime.
In the long run, we could adjust the model to be more like raw's by
fusing the entire stream graph into one node and then just executing
that node; however, the runtime system of the C library also provides
more flexibility for things like message delivery, where you might
want to have some runtime control of the scheduling.

In order to compile to C for the uniprocessor, the stream graph is
lowered into a "low ir" or LIR, with supporting files in kjc/lir.  The
original purpose of the "lowering" package (kjc/sir/lowering) was to
lower the SIR to the LIR, although it now includes some files that are
somewhat broader in scope.  The toplevel controller for the
uniprocessor path is in kjc/sir/lowering/Flattener.java.  As is
visible from the code, there are a number of passes in the lowering,
and they are in this order:

kjc/sir/lowering/Structurer: this deals with the fact that there are
			     no objects in C.  Thus, all fields of a
			     given stream class need to be packaged
			     into a structure, and passed around to
			     each method that operates on the
			     structure.  So the Structurer modifies
			     all methods to take an additional
			     argument, and to pass the state of the
			     stream through this argument.

kjc/sir/lowering/SIRScheduler: this class interfaces with the
			       scheduler (see below) to build a set of
			       hierarchical work functions for all the
			       stream containers (pipelines,
			       splitjoins, and feedbackloops) in the
			       graph.  Then, the resulting runtime
			       system can execute the entire stream by
			       calling the toplevel work function,
			       with all the components scheduled
			       accordingly.

kjc/sir/lowering/LowerInitFunctions: this adds LIR hooks to the init
				functions to pass information to the C
				library about the properties of each
				stream (e.g., it's I/O types, rates, etc.)

kjc/sir/lowering/LowerWorkFunctions: just marks the entries and exits
				of work functions with LIR nodes.

So, the LIR basically consists of a set of hooks for our C runtime
system.  It is not a "low-level IR" in the traditional
sense--i.e. there is no 3-address form, or low-level optimizations.
If you wanted to implement a different backend for StreamIt, the LIR
might be useful if you had library support in the backend, but not
otherwise.

The Directory Structure
-----------------------

At this point an explanation of our directory structure is long
overdue.  From under streams/src, it looks like this:

|-- streamit            Code that is specific to the StreamIt compiler
|   |-- frontend        StreamIt-to-Java converter
|   |-- library         StreamIt Java runtime library
|   |-- misc            Support classes for the scheduler
|   |-- scheduler1      Old scheduler (unused)
|   `-- scheduler2      Current stream scheduler
|
`-- at/dms              Parts from Kopi:
    |-- kjc		This is the compiler section of Kopi, that
    |   |               we're using.
    |   |-- iterator	Stream iterators, used primarily for interfacing 
    |   |               with the scheduler.
    |   |-- linprog	Interface to a linear programming package,
    |   |               currently unused.
    |   |-- lir		The LIR is the low-ir for the uniprocessor
    |   |               backend discussed above.
    |   |-- raw		This is where all the Raw backend stuff lives.
    |   `-- sir		This holds our representation of the high IR.
    |       `-- lowering  Originally intended for lowering SIR to LIR,
    |	        |       this generally contains anything related to
    |	        |       preparing the SIR for a backend stage.
    |           |-- linear - domain-specific optimization of linear filters.
    |           |-- fission - Contains fission transformations on SIR nodes.
    |           |-- reordering - Different re-arrangements of stream graph.
    |           |-- fusion - Contains fusion transformations on SIR nodes.
    |           |-- stats - Stub for statistics gathering package.
    |           `-- partition - Contains partitioners for load balancing.
    |               |-- dynamicprog - dynamic programming partitioner.
    |               `-- linear - automatic selection for linear opt.
    |
    `-- util - Miscellaneous utilities for use in different packages.

The top-level directory structure is as follows:

`-- streams
    |-- 3rdparty        Extra parts needed to run Kopi; taken directly
    |                   from the Kopi distribution.
    |-- apps            StreamIt benchmarks and applications
    |-- docs            Documentation for the language and compiler
    |-- include         Parts included by other parts of the
    |                   distribution, including Raw bc devices and
    |                   LaTeX macros
    |-- library         Uniprocessor C runtime library
    |-- misc            Scripts and helpers used by various things
    |-- regtest         Automated test infrastructure
    `-- src             Java sources for compiler and runtime library


The Scheduler
-------------

The component above that we haven't touched upon is the scheduler.
The role of the scheduler is to calculate/choose an execution ordering
for the filters in some graph or sub-graph, given all of their I/O
rates.  Right now our scheduler is a simple hierarchical scheduler
that schedules each stream container independent of its neighbors, but
we are working on a "phased scheduler" that is more fine-grained and
results in smaller buffer sizes between filters.

The scheduler can be used in several contexts.  It is used by the
fusion algorithm to statically schedule the components of a pipeline
or splitjoin. It is used by the Raw backend to simulate the execution
of the stream graph so that the routing instructions can be generated
for the switches on Raw.  It is used by the uniprocessor path to build
the work functions of stream containers when the SIR is being lowered
to the LIR.  And it is used for the work estimation phase of the
automatic partitioner, to determine how many times a given stream
segment executes in a steady-state execution of the graph.

The Front-End
-------------

All of the above assumes code written in legal Java, where StreamIt
objects are Java classes derived from the classes in the
streamit.library package ("old syntax").  A front-end package reads in
files written in the StreamIt language ("new syntax"), does some
processing, and spits out an old-syntax file that the compiler can
process.  This includes processing to change between syntaxes for
language features such as filter I/O rates, and eliminating language
features not present in Java (most notably, complex numbers).

The main entry point to the front-end is the streamit.frontend.ToJava
class.  This reads in the input file using an ANTLR grammar, and
creates a parse tree using the classes in the streamit.frontend.nodes
package.  This IR is immutable; visitor classes, generally derived
from streamit.frontend.nodes.FEReplacer, rewrite the IR tree.  Some
generic passes live in the streamit.frontend.passes package, and are
used to perform limited semantic checking and would otherwise be
useful outside of the context of conversion to Java.

Currently, the major task of the front-end is to produce Java code to
feed to Kopi.  This is done in the streamit.frontend.tojava package.
A couple of special IR nodes are introduced here to handle concepts
not otherwise present in the front-end, such as Java constructors for
the Channel object to "declare" an input or output type.
streamit.frontend.tojava.NodesToJava is the final class, which takes
the tattered remnants of the IR tree and spits out the desired Java
file.

The front-end can also be invoked to produce code for the StreamIt
Java library.  This is generally identical to what's produced for the
compiler, but differs on details for things like phased filters.
There are also plans to change the calling convention for init
functions for the library path only to avoid needing a valid
constructor for every possible set of parameters.  The output of the
front-end in this case would be directly compiled with javac or jikes,
and run with java.