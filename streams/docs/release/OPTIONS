Options to the StreamIt 'knit' Compiler Script
----------------------------------------------

This is for the May 28, 2003 snapshot release (streamit-0.0.20030528).

$Id: OPTIONS,v 1.9 2003-05-28 17:46:43 thies Exp $


Basic usage:

  knit Foo.str

Reads Foo.str, produces Foo.java as an intermediate file, compiles
this down to Foo.c, and then compiles and links this to produce a
binary, a.out.

Options:

  --help
      Displays a summary of available options.

  --output <filename>
      Places the resulting binary in <filename>.

  --raw <n>
      Compile for an <n>-by-<n> RAW processor.

  --raw <n> --rawcol <m>
      Compile for an <n>-by-<m> RAW processor.

  --verbose
      Show intermediate commands as they are executed.

  --library
      Produce a Java file compatible with the StreamIt Java library,
      and compile and run it.

Options available for all backends:

  --unroll <n>, -u<n>
      Specify loop unrolling limit.  The default value is 16.

  --linearreplacement
      Domain-specific optimization: combine adjacent "linear" filters
      in the program into a single matrix multiplication operation
      wherever possible.  Corresponds to the "linear" option in the
      PLDI'03 paper.

  --sjtopipe, -J
      Convert split-joins to pipelines.  This works by converting an
      n-way split-join to n n-way split-joins in series, where each
      split-join has (n-1) identity filters and one of the children of
      the original split-join, and then fusing each splitjoin into
      a single filter.  This could improve performance for large 
      splitjoins by reducing network contention.

  --sync, -k
      Perform aggressive synchronization removal.  The simplest case
      of this involves two split-joins in a pipeline, where the joiner
      of the first and the splitter of the second have identical
      weights and the number of children is the same; then the two
      split-joins can be combined into one.  This case is performed
      by default, but --sync enables more aggressive (and less stable)
      transformations.

  --nofieldprop, -L
      Avoid propagating constant values from a filter's init function
      to its work function, as in:

        float->float filter ScaleBySquare(float v) {
          float v2;
          init { v2 = v * v; }
          work pop 1 push 1 { push(v2*pop()); }
        }

  --nolinearcollapse, -H
      When performing linear replacement or frequency replacement, do
      not collapse adjacent linear filters into a single filter; only
      operate on individual filters.

Options specific to RAW backend:

  --numbers <n>, -N<n>
      Instrument code to gather performance statistics on simulated
      code over <n> stady-state cycles.  The results are placed in
      results.out in the current directory.

  --partition, -a
      Partition the stream graph, performing either filter fission or
      fusion until the number of filters is approximately equal to the
      number of tiles.  This is required if the number of filters in
      the expanded stream graph is greater than the number of tiles.

  --dppartition, -y
      Use a partitioner based on dynamic programming, rather than the
      default greedy partitioner.  On some benchmarks this gets better
      results; performance is generally comparable.

  --simulatework, -T
      Use the RAW simulator to calculate the amount of time required
      to execute a work function, rather than using an estimator.
      This makes the compiler substantially slower; it may result in
      better partitioning.

   --magic_net, -M
      Compile to a "magic" network in which the buffer sizes between
      Raw tiles are conceptually unbounded (the sender never blocks),
      and the communication time has a constant overhead and per-hop
      latency.  These parameters can be varied by editing the 
      auto-generated Makefile.streamit file, which contains a string
      "-magic_crossbar C1H1".  The number after the "C" refers to the
      constant overhead; after the "H" refers to the per-hop latency.

  --raw-uni, -U
      Use the RAW backend, but fuse to a single tile and output code
      that can be run on a uniprocessor as a standalone C program
      (without depending on the StreamIt C library).

Options specific to uniprocessor backend:

  --linearpartition, -B
      Domain-specific optimization: perform linear replacement and
      frequency replacement selectively, based on an estimate of
      where it is most beneficial.  Corresponds to the "autosel"
      option in the PLDI'03 paper.

  --frequencyreplacement, -F
      Domain-specific optimization: combine adjacent "linear" filters
      in the program and convert them to the frequency domain
      wherever possible.  Corresponds to the "freq" option in the
      PLDI'03 paper.

  --poptopeek, -P
      Convert pop expressions into peeks, and pop only at the end of 
      the work function.

  --profile
      Compile C code with profiling information.  This requires that
      your system have profiling versions of the standard C and math
      libraries (libc_p.a and libm_p.a), along with a profiling
      version of the StreamIt library; 'make profile' from
      $STREAMIT_HOME/library/c.  Profiling results can be analyzed
      using 'gprof'.
