\section{Related Work}
\label{sec:related}

Several groups are researching strategies for efficient code
generation for DSP applications.  SPIRAL is a system that generates
libraries for signal processing
algorithms\cite{spiral,johnson01searching,egner01automatic}.  Using a
feedback-directed search process, DSP transforms are optimized for the
underlying architecture.  The input language to SPIRAL is
SPL\cite{xiong01spl,xiong-thesis}, which provides a parameterizable
way of expressing matrix computations.  Given a matrix representation
in SPL, SPIRAL generates formulas that correspond to different
factorizations of the matrix.  It searches for the most efficient
formula using several techniques, including dynamic programming and
stochastic evolutionary search.

We consider our work to be complementary to SPIRAL.  While SPIRAL
starts with a matrix representation in SPL, we start with general
StreamIt code and use linear dataflow analysis to extract a matrix
representation where possible.  Our linear combination rules are
distinct from the factorizations of SPIRAL, as StreamIt nodes can peek
at items that they do not consume.  In the future, SPIRAL could be
integrated with StreamIt to optimize a matrix factorization for a
given architecture.

The ATLAS project \cite{whaley01automated} also aims to produce fast
libraries for linear algebra manipulations, focusing on adaptive
library generation for varying architectures.  FFTW~\cite{frigo99fast}
is a runtime library of highly optimized FFT's that dynamically adapt
to architectural variations.  StreamIt is again complementary to these
packages: it allows programmers to interface with them using general
user-level code.

ADE (A Design Environment) is a system for specifying, analyzing, and
manipulating DSP algorithms~\cite{covell-ade}.  ADE includes a
rule-based system that can search for improved arrangements of stream
algorithms using extensible transformation rules.  However, the system
uses predefined signal processing blocks that are specified in
mathematical terms, rather than the user-specified imperative code
that appears in a StreamIt filter.  Moreover, ADE is intended for
algorithm exploration, while StreamIt includes support for code
generation and whole-program development.  In addition to ADE, other
work on DSP algorithm development is surveyed
in~\cite{oppenheim-symbolic}.

Karr~\cite{karr76} and Cousot and Halbwachs~\cite{cousot78} describe
general methods for detecting linear relationships among program
variables.  Karr maintains an affine representation (similar to ours)
for each program variable, while Cousot and Halbwachs use a polyhedral
model in which each dimension corresponds to a program variable.  For
general programs, the analyses described by these authors is more
general than ours.  In fact, the novelty of our linear dataflow
analysis is in its specialization for the streaming domain.  Rather
than tracking general relationships, we only track relationships to
items on the input tape.  This restriction---in combination with the
atomic, fine-grained nature of filter work functions---makes it
feasible to symbolically execute all loops, thereby obtaining more
precise linearity information.

A number of other programming languages are oriented around a notion
of a stream; see \cite{survey97} for a survey.  Also note that the
``linear data flow analysis'' of Ryan~\cite{ryan92} is completely
unrelated to our work; it aims to do program analysis in linear time.

%% Synchronous languages such as LUSTRE~\cite{lustre},
%% Esterel~\cite{esterel92}, and Signal~\cite{signal} target the embedded
%% domain, while languages such as Occam~\cite{occammanual},
%% SISAL~\cite{sisal} and StreamC~\cite{Rix98} target parallel and vector
%% targets.  However, none of the compilers for these languages have
%% coarse-grained, DSP-specific analyses such as linear filter detection.

% Something should be said about other stream projects and their attempts at optimizations...
% which I know very little about.
