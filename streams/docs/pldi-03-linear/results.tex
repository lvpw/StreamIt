\section{Results}
\label{sec:results}

Our compiler currently has two linear analysis optimizations. The
first, {\it linear replacement}, transforms linear streams 
(either filter, splitjoin or pipeline) by replacement with a filter 
that directly computes the calculation of the corresponding linear node. 
The second optimization, {\it frequency replacement}, applies the 
transformation described in Section \ref{sec:freq}. The partitioner 
automatically determines to which subsections of the overall program to apply
each of the transformations. Below we describe experiments and results 
that demonstrate substantial performance improvements due to our methods.

\subsection{Measurement Methodology}
%We chose to measure the strength of our optimizations in terms of 
%floating point instruction reduction. The StreamIt compiler currently
%has two code generation backends. The uniprocessor backend generates sequential C code
%that can be compiled and linked against a supporting library. 
%There is also a backend that generates code for the RAW microprocessor
%\cite{waingold97baring, raw-micro}, which features
%a grid of processors interconnected via various communication facilities. 
%Mapping a StreamIt program on to the RAW architecture is complicated
%by issues of communication, load balancing and partitioning\cite{streamit-asplos}. 
%Therefore, the effects of our linear analysis optimizations can not
%be easily differentiated from differences in placement, routing and fusion that result
%from modifying the program's stream graph (as is the case for linear replacement). 
%Therefore we chose to use the uniprocessor backend for our measurements.

%As always, the appropriate metric to measure performance is not totally clear. 
%Running time is complicated by the multitasking environment offered by 
%modern operating systems. Also, given that the uniprocessor backend for
%the StreamIt compiler is meant for prototyping, the supporting 
%library is anything but optimized. Therefore, measuring running time is
%probably not an appropriate metric.

\begin{figure}[t]
%\vspace{-6pt}
\center
\epsfxsize=3.2in
\epsfbox{images/multiplications-remaining.eps}
\vspace{-6pt}
\caption{Percent of multiplication operations remaining after performing linear replacement, frequency replacement, and both.}
\label{fig:linear-freq-both}
\vspace{-12pt}
\end{figure}

Our measurement platform is a Dual Intel 2.2 GHz P4 Xenon processor system 
with 2GB of memory running GNU/Linux. We compile our benchmarks using StreamIt's uniprocessor backend
and generate executables from the resulting C files using {\tt gcc} with {\tt -O2} optimization.
Both linear replacement and frequency replacement increase performance primarily
decreasing the number of floating point computations (principally multiplications) 
required per output.
To measure the number of runtime multiplications we use an instruction counting 
DynamoRIO\cite{dynamo99} client.
%Floating point multiplication instructions 
%in the IA-32 instruction set are defined to be any of ({\tt fmul fmulp fimulp fdiv fdivp fidivp fdivr fdivrp fidivr}).
%We measure execution time normalized to the number of program outputs generated. 
There are no standard benchmarks written yet for StreamIt, so we use
a set of representative programs\footnote{Stream graphs appear in Appendix A.}
which perform computations that are commonly found in streaming applications: 

1) {\bf FIR}, a single 256 point rectangularly windowed low pass FIR filter; 
2) {\bf RateConvert}, an audio down sampler that converts the 
sampling rate by a non-integral factor ($\frac{2}{3}$); 
3) {\bf TargetDetect}, four matched filters performing threshold target detection in parallel; 
4) {\bf FMRadio}, an FM software radio with equalizer;
5) {\bf Radar}, the core functionality in modern radar signal processors 
-- modeled after a system from the Polymorphic Computing Architecture (PCA);
6) {\bf FilterBank}, a multi-rate signal decomposition 
processing block common in communications and image processing; 
7) {\bf Vocoder}, a channel voice coder, used for speech analysis and compression;
8) {\bf Oversample}, a $16x$ oversampler, a function commonly found in audio applications 
such as CD players;
9) {\bf DToA}, an audio post-processing stage prior to a 1-bit D/A converter 
with oversampler and first order noise shaper.

\subsection{Performance}
To determine the effects of our linear replacement and frequency
replacement optimizations, we compiled each benchmark program with
linear replacement, with frequency replacement, with a back to back application of
frequency replacement and linear replacement and with the partitioner.
Figure~\ref{fig:linear-freq-both} shows the reduction in the number
of multiplications that our optimizations achieve.


%%%%%%%%% This paragraph is no longer accurate.
% When we have the final numbers, we can explain some of them
For FIR, all of the multiplication reduction comes from the
frequency replacement optimization: the entire application is
a single filter and so there is nothing to combine and no choice
for the partitioner.
For RateConvert{\bf XXXXX}.
The multiplication reduction in TargetDetect is
also solely due to the frequency transformation because threshold
detection is non-linear which makes the parallel computation blocks
uncollapsible. Finally, RateConvert contains a large low pass filter
which also benefits from frequency replacement.

All of the multiplication reduction in the FMRadio benchmark is due to
the automatic combination of parallel equalizer computations.
Table~\ref{fig:benchmark-statistics} shows the number of nodes in each
benchmark both before and after linear replacement.

FilterBank is the only benchmark where multiplications are reduced  
more by both optimizations than either alone. Linear replacement reduces
the required multiplications because it can combine the action of parallel analysis 
and synthesis channels into an overall FIR filter. Frequency replacement alone helps 
multiplication reduction only somewhat because FilterBank contains fairly small FIR filters.
However, frequency replacement speeds up the calculation of the overall filter
generated by linear replacement, and thus decreases the number of multiplies even further.

\begin{figure}[t]
\center
\epsfxsize=3.2in
\epsfbox{images/execution-speedup.eps}
\vspace{-6pt}
\caption{Execution speedup for each of the benchmarks with both linear replacement and frequency replacement optimizations.}
\label{fig:execution-speedup}
\vspace{-6pt}
\end{figure}

In general, reducing computation does not necessarily translate into 
execution time improvement, but as Figure~\ref{fig:execution-speedup} 
demonstrates, our benchmarks speedup on average by a factor of {\bf XXXXX} 
and by a factor of $XXXXXXX$ in the best case. Our frequency replacement optimization
takes advantage of the machine tuned FFT package FFTW~\cite{frigo99fast}), 
to perform the necessary time-frequency conversions.

However, our performance improvements are due only in part to to the efficiency of FFTW. 
Multiplications are decreased and execution is sped up in RateConvert, FM, FilterBank and
Vocoder with only linear replacement. Linear replacement only improvements are
due to savings obtained during linear collapsing.

\begin{table*}[t]
\vspace{-6pt}
\centering
\small
\begin{tabular}{|l|c|c|c||c||c|c|c|} 
\hline
& \multicolumn{3}{|c||}{Originally}  &             & \multicolumn{3}{|c|}{After Optimizations} \\
\hline
Benchmark  & Filters & Pipelines& SplitJoins & Average     & Filters      & Pipelines         & SplitJoins \\
           & (linear)& (linear) & (linear)   & vector size &              &                   &            \\
\hline
FIR        & 3 (1)   & 1(0)     & 0 (0)      & 256         & 3            & 1                 & 0 \\
\hline
RateConvert& 5 (3)   & 2 (1)    & 0 (0)      & 102         & 4            & 1                 & 0 \\
\hline
TargetDetect& 10 (4) & 6 (0)    & 1 (0)      & 300         & 7            & 2                 & 1 \\
\hline
FMRadio    & 26 (22) & 11 (9)   & 2 (2)      & 40          & 5            & 1                 & 0 \\
\hline
Radar      & 76 (60) & 17 (0)   & 2 (0)      & 4412        & 21           & 1                 & 2 \\
\hline
FilterBank & 27 (24) & 17 (9)   & 4 (4)      & 52          & 10           & 1                 & 2 \\
\hline
Vocoder    & 17 (13) & 10 (8)   & 2 (1)      & 60          & 7            & 2                 & 1 \\
\hline
Oversampler& 10 (8) & 1 (1)     & 0 (0)      & 33          & 3            & 1                 & 0 \\
\hline
DToA       & 14 (10) & 3 (1)    & 0 (0)      & 52          & 6            & 2                 & 0 \\
\hline

\end{tabular}
\vspace{-3pt}
\caption{Statistics for benchmarks before and after optimizations.
\protect\label{fig:benchmark-statistics}}
\vspace{-4pt}
\end{table*}
