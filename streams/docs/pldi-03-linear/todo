to add to paper:
---------------

possibly for Andrew to do:
------

- give example of a linear node.  Could go in one of two ways: give
  streamit code and then the matrix, or give general streamit code
  that implements an abstract matrix.  I think the first would be
  better.

- add to fig 7, xA + b = y.  (The b is missing)

- fig 9, some of the fonts are too small [esp. the (e'- (e+o*....) section]

- looks like the vector symbol goes funky (looks curvy) on b when it
  is in bold.

- should add vector symobls to x and y in all transformations and
everywhere where they're used as vectors

- some bugs in fig. 10:

   - in second line of matrices, add "e" superscript to A_1 (in label above)

   - in lamba_1^e, the push and pop rates are reversed (should be pop=1, push=3)

   - the vector sign is missing from b

- in figure 12:
   - in the second splitjoin, we have lambda_1^e but A_1.  Should add
     e in both cases or neither (same with actual matrix inside the node).

   - vector signs missing from b.
   
   - I would expand "duplicate" and "roundrobin" in the splitters and
     joiners.  We have room for the labels and other people might not
     understand.

- Figs 1 and 10 draw stream graphs horizontally, while figs. 6, 12,
  and appendices are vertically.  Do you think it'd make sense to
  always be vertical?  Not a big deal.

- I would remove titles of the graphs from excel.

- In results, I think we should move the description of the benchmarks
  into a table like in ASPLOS, which is "program characteristics" --
  lines of code, number of filters orig, number of filters expanded,
  and then possibly the results (mult. reduction and execution time
  with differnent options), if there's room in the same table.

- This is a low-priority pain, but bibliography could use some
  uniformizing.  For example, we reference PLDI in three completely
  different ways.

- I'm unclear about a number of things in the frequency section.  I
  think we need to make it more clear what class of filters we
  transform, and why.  Should define "convolutional filter" if that
  word has any meaning.  It'd be nice to describe the algorithm for 
  transforming matrices, not just column vectors, if possible.

------

- make clear what domain of inputs the frequency conversion will work
  on (what is a convolutinoal filter?  use it a lot w/o definition.)

- describe partitioning stuff (Bill)
- updated numbers (with new benchmarks?)
  - resolve Beamformer numbers
- editing / proofreading

Andrew's distallation of todo items (that are not already fixed) from reviewers:
- Make stream graphs easier to read / lay them out better
  - Perhaps show the various stream graphs for a single application (and point
    readers to the web/thesis for the stream graphs of the other benchmarks.
- Add examples of frequency transformation (don't know how to do this)
- More benchmarks
- Include measurements of code size and data size for before/after transformed programs
- Doesn't like sampling conversion rate of 2/3. Results will get better for larger rates,
	should I change it? 441/220 (downsample from CD to MP3 rates) perhaps?
	(I don't think so...)
- Address the concern of extra work being incurred by the zeros introduced
	in splitjoin combination.
- Possibly add the comments of the fourth reviewer:
	"More technically, what I found most interesting about the paper is
	that in order to perform the optimization, the optimizer first
	attempts to extract from the program a high-level model (in this case,
	an affine transformer) which then serves as a clean representation for
	the filter transformations."

Done
------------
- Possibly make more clear that "pushcount" and "popcount" are not simply counters but
	are used to generate the linear nodes. 
* Added a sentence to dataflow2.tex that says "The values of  $\mt{pushcount}$ and 
	$\mt{popcount}$ when a push or pop is encountered are used to determine the 
	appropriate locations within $A$ and ${\vec b}$."
------------
- Include some background on filters and their transformations. I wrote something
	like this for my thesis. Perhaps we can include it in the paper (in shortened form)
* There is a reasonable discussion of the topics of FIR filtering in the introduction to the Translation
	to Frequency section. I think that this is more or less enough information to understand the
	frequency transformation. I don't think that we need a more general introduction.
------------
- Cite Andrew's thesis for more details.
------------
- Add examples of combination rules
------------




to get more todo items:
-----------------------
- read paper carefully







high priority
-------------

- bill is confused with definitions of multiplication scaling

- > >- In 5.2, when you talk about generating a new stream that uses more
  > >   inputs, can you pose this in terms of the "expand" operation?
  > 
  > Can you help me with this? The other thing that is a little worrying about 
  > the whole thing is that the transformation thing makes almost no mention of 
  > linear nodes (only a passing comment in the intro).

- note that we require a certain minimum value of e in the expansion
process!

low priority
------------

- make it explicit somewhere that whenever we introduce \lambda_x, we
also introduce A_x, b_x, e_x, o_x, u_x.

probably not doing
------------------

- say more about when linear combination is a good thing?  I think the
statement with the sum of non-zero elements is not entirely accurate.

- Possibly compare to hand optimized (eg frequency transformations and all) code.

