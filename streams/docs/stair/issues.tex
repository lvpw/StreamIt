\documentclass[11pt]{article}

\usepackage{cite}
\usepackage[margin=1in]{geometry}
\usepackage{palatino}
\usepackage{url}

% Abstract formatting:
\def\class#1{\texttt{#1}}


% Print acronyms in small caps.
\def\cfg{\textsc{cfg}}
\def\dsp{\textsc{dsp}}
\def\fortran{\textsc{fortran}}
\def\ir{\textsc{ir}}
\def\Ir{\textsc{Ir}}
\def\mips{\textsc{mips}}
\def\mit{\textsc{mit}}
\def\opi{\textsc{opi}}
\def\raw{\textsc{raw}}
\def\scale{\textsc{scale}}
\def\sir{\textsc{sir}}
\def\ssa{\textsc{ssa}}
\def\Ssa{\textsc{Ssa}}
\def\stair{\textsc{stair}}
\def\Stair{\textsc{Stair}}
\def\suif{\textsc{suif}}
\def\Suif{\textsc{Suif}}
\def\suifvm{\texttt{suifvm}}
\def\vliw{\textsc{vliw}}
\def\vm{\textsc{vm}}
\def\xml{\textsc{xml}}
\def\Xml{\textsc{Xml}}
\def\machsuif{Machine \suif}

% Predefine useful email addresses.
\urldef\dmazemail\url{dmaze@cag.lcs.mit.edu}

\title{Commentary on \stair}
\author{David Maze\\\dmazemail}

\begin{document}

\maketitle

\begin{itemize}
\item 2.3, 2. Seems to me like types would still be useful --- might
  want a "bit" in addition to int and float?  (I don't know, if we
  ever generate hardware from low-level IR, for example.) But required
  bitwidth for everything does seem like overkill.  [Bill]
  
\item Variables.  Do we want to distinguish SSA by number or name?
  Seems like if you want to get a new SSA variable, you might just
  want to get a fresh name instead of finding what the current free
  number is for that variable.  [Bill]

  \emph{SSA-by-number means that it's easier to collect together
    different parts of the same variable without copying values around
    when doing register allocation.  ---dzm}
  
\item The array addressing case.  Wouldn't it be much easier for a
  lower layer to convert a single instruction to multiple instructions
  instead of the other way around? Seems like the store should be the
  most general, high-level version in the common layer.  So I'd vote
  for store-with-offset instead of doing the add of the address in the
  VM.  [Bill]
  
\item Branching.  I'm a little confused about why the insert
  conditional branch, etc., is in the Backend interface.  Isn't there
  a vm-level concept of branches?  Are all branches machine-specific?
  Why aren't they just like other instructions?  (Or you're saying
  that at the vm level, all branches are just implied by the control
  flow graph?  Still there needs to be some instruction for
  designating which path to take, I guess.)  [Bill]
  
  \emph{My intent was that everything would stay in \cfg{} form until
    the latest possible moment.  So all of the control flow, including
    conditional and unconditional branches, is in the \cfg.  This
    isn't necessarily ideal; we might want to break the \cfg{} around
    calls, for example.  ---dzm}
  
\item 4.4 Symbols --- are "variables" the same as temporary operands
  in the low-level \ir?  when you say "symbols and registers, but
  nothing else, have types" --- what's the "else"?  I think the
  temporaries in the low-level IR should have types as well.  [Bill]
  
  \emph{When a temporary is generated, it gets a slot in the symbol
    table, so it becomes a normal variable.  The "else" includes
    immediates (implicit integer or float type) and memory references
    (where you probably care).  The immediates are the thing that are
    a big pain with typing in \machsuif.  ---dzm}
  
\item I don't think don't think edge should be inner class of block,
  if that's what you were really intending.  (Passes might want to
  know about edges.)  [Bill]
  
  \emph{That is what I was intending.  That can be changed.  There's
    some concern about the names I'm using being pretty generic ones,
    though; I might use ControlEdge over an unqualified Edge.  ---dzm}
  
\item I think a major open question is whether or not the "low-level
  IR" is structured.  At one point (around StreamIt Fun Day '02) we
  were talking that there should be an architecture-independent
  equivalent of the "flat graph" that Mike Gordon currently uses in
  the Raw backend.  Maybe \stair{} is independent of this decision
  (\stair{} code could appear either in \sir{} function bodies, or in
  some low-level graph function body) but when we're building the
  infrastructure, I think it'd be good to introduce the generic
  unstructured graph at the same time.  Maybe Gordo can help define
  this -- or could just distill it from his Raw code.  [Bill]

\item Shouldn't there be phi nodes?  [Bill, paraphrased]

  \emph{Oh yeah, that didn't make it into the original document.  Each
    block should have a list of variables and associated \ssa{}
    numbers live on entry and exit.  Then, for each variable, either
    the \ssa{} number is identical to all of the previous blocks, or
    it's different from all of the previous blocks and an implicit phi
    function exists.  ---dzm}
  
\item Is there any value in having the \cfg{} and the textual sequence
  of instruction just be redundant views of the same thing?  Michal
  was describing algorithms where you just loop through a linear
  stream of instructions and follow the branches for a simple way of
  doing things.  I think the same thing could be done through a \cfg,
  but I can't tell if it'd be more cumbersome.  [Bill]
  
\item Perhaps \class{BlockContainer} should be replaced by
  \class{Function}; are there other interesting case of containers?
  [Bill]

\item Probably want more widespread use of annotations.

  \emph{Makes sense.  I'm not sure how much we actually want to
    annotate; annotations on instructions, blocks, and symbols all
    make sense, but on individual operands might be a bit excessive.
    Annotating blocks is also a little risky if blocks are going to be
    repeatedly refactored.  ---dzm}

\item \Suif's approach to types, using explicit bit sizes on types, is
  good.  This implies that a general type-conversion instruction is
  necessary.  Not having types on constants is fine, though.  [Mike K]

\item While control flow graphs can be useful, should they be the only
  representation of the program?  Having a flat graph can be useful.
  [Mike K]

  \emph{After discussion in the meeting, it sounds like people are
    happy if there isn't a hard global invariant that the \cfg{}
    representation isn't a fixed minimal control-flow graph of basic
    blocks.  In particular, Mike is satisfied if the representation
    has a ``flatten'' call that produces a single \class{Block}
    containing all of the code for a function.  In turn, this means
    that branch and label instructions are necessary in the \vm{}
    layer.  Functions to do common \cfg{} manipulations such as
    ``insert a block before this one'' also are important.}

\item \Ssa{} is a bit overrated.  We don't necessarily want to use it
  everywhere, and it's not useful for array references and globals.
  [Everybody]  ``It's fine if it's optional.''

  \emph{The \ssa-with-numbers approach does make \ssa{} pretty
    optional; if you don't want to use the \ssa{} information, you can
    just ignore it.  Since recomputing the liveness information can
    take time and passes might not need it, this means that passes
    using \ssa{} should be forced to recompute the relevant
    information.  Dealing with arrays and globals is an issue,
    though.  ---dzm}

\item The \ir{} has an operand field for predicates; the input \vm{}
  code should be unpredicated, though.

\item Having array and field access instructions in the \vm{} is
  useful for analysis.  It's better to have the instructions and
  dismantle them than to not have the instructions and be forced to
  reconstruct the information.  [Mike K]

\item \Suif{} has ``registers'' and ``memory'', but no ``symbols''.
  Registers in this world can be virtual registers, or can be bound to
  a hard register.  This means that the symbol table hierarchy can be
  eliminated, or at least reduced.  It also simplifies generating
  temporaries.  [Mike K]

  \emph{I suspect the concept of a symbol is still useful; if nothing
    else, you might want to annotate it for alias analysis.  At this
    \ir{} level, we can deal with field variables by putting them in a
    structure that's a function parameter.  This just leaves globals,
    which fall into the ``memory'' world.  I'm fine with dumping
    symbol tables.  ---dzm}

\item Explicit $\phi$-nodes are useful for \ssa.  Without them, it can
  be hard to find the definition(s) for a particular variable.

\item User-level constants should all be put into globals in the
  program, rather than being used as immediates.

\item There should be strong invariants for the \ir{} that passes can
  easily check.  Similarly, there should be coding standards for
  writing passes so that people who aren't us don't screw it up.
  [Mike K]

\end{itemize}
\end{document}

