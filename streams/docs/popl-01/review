Return-Path: <xleroy@leoville.inria.fr>
Received: from fort-point-station.mit.edu by po10.mit.edu (8.9.2/4.7) id DAA20651; Fri, 28 Sep 2001 03:48:11 -0400 (EDT)
Received: from concorde.inria.fr (concorde.inria.fr [192.93.2.39])
	by fort-point-station.mit.edu (8.9.2/8.9.2) with ESMTP id DAA11937
	for <thies@mit.edu>; Fri, 28 Sep 2001 03:48:10 -0400 (EDT)
Received: from leoville.inria.fr (leoville.inria.fr [128.93.11.81])
	by concorde.inria.fr (8.11.1/8.10.0) with ESMTP id f8S7m9506149
	for <thies@mit.edu>; Fri, 28 Sep 2001 09:48:09 +0200 (MET DST)
Received: (from xleroy@localhost)
	by leoville.inria.fr (8.11.1/8.11.1) id f8S7m9N38905;
	Fri, 28 Sep 2001 09:48:09 +0200 (CEST)
	(envelope-from xleroy)
Date: Fri, 28 Sep 2001 09:48:09 +0200 (CEST)
From: Xavier Leroy <xleroy@leoville.inria.fr>
Message-Id: <200109280748.f8S7m9N38905@leoville.inria.fr>
To: thies@mit.edu
Subject: Your POPL 2002 submission #143
Reply-To: mitchell.stanford.edu@leoville.inria.fr

Dear Bill Thies:

I am sorry to inform you that your paper was not selected
by the program committee to appear at POPL 2002:

      StreaMIT:  A Language for Streaming Applications

Comments from the reviewers are included with this message.

Please understand that many good papers could not be
accepted, due to the length and format of the conference.
We hope that the reviewers' comments will be helpful to
you in continuing your research.


Yours sincerely,

- John Mitchell
  Program chair

============================================================================ 
POPL 2002 Reviews for Paper #143
============================================================================ 

Title: StreaMIT:  A Language for Streaming Applications

Authors: William Thies, Michal Karczmarek, and Saman Amarasinghe

============================================================================ 

REVIEWER #1
============================================================================ 

Numerical Scores:

     appropriateness: 5
     originality: 2
     tech_strength: 2
     presentation: 3
     overall: 3
     confidence: 0.7


Comments:

I have a difficult time seeing what is novel in this paper. I can imagine that one
would like to have a stream library, but I cannot see the special difficulties
this raises, especially given work of Kahn, Strachey, etc. In any case, the 
paper does not spell out the challenge that has been overcome.

The semantics part of the paper appears rather thin.

============================================================================
REVIEWER #2
============================================================================ 

Numerical Scores:

     appropriateness: 7
     originality: 6
     tech_strength: 3
     presentation: 4
     overall: 4
     confidence: 0.8


Comments:

This paper describes a language for programming with streams.  In the
model, streams are assembled from collections of filters. Streams are 
formed using simple filter composition, splitjoins (which introduce 
a diamond into the data flow), and feedback loops.  The language also
includes primitives for passing out-of-channel control messages both
up- and down-stream.  Included in the messaging-model is a notion
of acceptable latency.   Computationally, all filters and stream 
elements execute concurrently and message passing is asynchronous,
so there is no global time.  Instead, the language incorporates a notion
of time based on the information wavefront.  Intuitively, this idea
corresponds to the number of items a given filter processes before
the data it generates (or reads) can be read by (or sent from) another
filter down (or up) stream.  The model of time can be used to guide
compiler optimizations and to detect deadlock and buffer overflow.

I like this paper because it introduces interesting ideas in the
area of imperative programming with streams.  

However, it has some drawbacks.

The language is presented in Java syntax, making it hard to separate
the abstractions of streaMIT from the ambient Java code.  The given
Java code probably serves as a good implementation of the abstractions,
but it makes it hard to see and understand the abstractions themselves.

The paper does not include any formal semantics proving that the analyses
described in the paper succesfully detect buffer overflow and deadlock.

more detailed comments
Sec. 2  "severs" --> "servers"

Chose your examples more carefully to illustrate your points.  You give
a lot of code, most of which is not essential to understanding your model.

Sec. 3.1.2  "StreaMIT's representationf of a filter is an improvement over
        general-purpose languages"  This comment is confusing, as you are
        working in Java...
        
        "input or output ratios"  Define these terms.
        
        "the absence of a run-time model in favor of automated scheduling 
        and optimization again distinguishes StreaMIT."  I don't understand
        this comment, as you must have some kind of run-time support for
        processing streams.
        
Sec. 3.2.1  "Figure 11" --> Figure 4.

Fig. 4  You don't define what a butterfly is.
        It would be helpful if you drew a block diagram of the FFT stream.
        
Fig. 6  What is a portal?

Sec. 3.2.2  "butterfly stages appropriately"  You haven't discussed this part.

Sec. 3.3.1  Discuss how StreaMIT message sending integrates with that of normal
            message sending in your language (Java?).
            
            "receiver is invoked"  What does this terminology mean?
            
Sec. 4.1.1 Be more precise about A's behavior.  Define peekA, popA, and pushA.

Fig. 10  The text describing this figure doesn't match the labels in the figure.

         Throughout effected --> affected.
         

Citation [8] is incomplete.

============================================================================
REVIEWER #3
============================================================================ 

Numerical Scores:

     appropriateness: 3
     originality: 6
     tech_strength: 3
     presentation: 3
     overall: 2
     confidence: 1


Comments:

This paper proposes a special purpose language for streaming applications,
taking a software radio as an example. The motivation for a new language is
that combining a high level of abstraction in programs, with the high
efficiency needed for very high volume streams, demands application-specific
optimisations in the compiler. The proposal combines a dataflow treatment of
high volume streams with asynchronous messages carrying occasional control
information between the nodes. An interesting idea is that, in order to
synchronize mode changes in different parts of the network, the sender
specifies when a message should be received *in relation to the sender's own
input and output streams* -- that is, the flow of data is used to supply a
notion of "global time", even though the relative execution times of different
nodes is not defined. Constraints on when messages must be received impose in
turn constraints on how computations can be scheduled, which the compiler
should take into account.

I like the idea, and I hope the authors pursue it, but the paper as it stands
is premature. 

Firstly, there is neither a language nor a compiler: instead the paper
describes a Java prototype. The design of "a clean syntax" and its compiler
are left as future work. Without either, it's hard to see how this really
falls under the scope of POPL. As it stands it's more of a programming example.

Secondly, seen as a language design, StreamIT with the syntax described is
flawed. For example, its clear that the authors expect that a single execution
of the "work loop" of a process will always read, "peek" and write the same
number of messages from and to its input and output streams -- this is assumed
in their analysis of stream sizes. Yet the syntax permits message reading and
writing in the arms of a conditional, for example, leading to meaningless
programs. The semantics leaves things to be desired in other ways, too. The
use of dataflow to define the timing of control messages is incompletely
defined: the time at which messages are transmitted between processes which
are "in parallel", rather than one downstream of the other, is "beyond the
scope of this paper". When a new language is presented, its meaning should be
*precisely* defined.

Thirdly, the authors should study related work better. The analyses they
propose, such as deadlock detection, have already been implemented for the
likes of Esterel and Lustre -- which they don't cite. The constructions for
stream processor networks which they describe, are very close to the
constructions provided by the Fudgets GUI library for Haskell -- but
notationally much heavier. They cite Occam and the pi-calculus as stream
programming languages, and then remark "However, most of these languages are
functional rather than imperative". Quite when Occam and pi-calculus became
functional languages, I don't know -- but in any case, what matters is surely
not whether a language is functional or imperative, but whether it is suited
to its purpose?

My advice is ditch the Java syntax, learn from Esterel, Lustre, and Fudgets,
redesign StreamIT with an appropriate syntax and a precisely defined
semantics, and build a compiler to show that the optimisations they suggest
can actually be performed. Then it'll be a great paper.

Details:

Your min and max functions should surely be related -- perhaps you can even
define one in terms of the other? What is the formal relationship?

I don't understand your calculation of max in section 4.1.1. You seem to be
saying that after n executions of the work loop, the filter will have popped n
items from its input stream. But it pops pop_A items per cycle, so there must
be a mistake here somewhere.

There must be at least a typo in your rule for transitions between
configurations: it contains the term n(out_A+push_A) -- but the argument of
n(-) should be a stream. Type error.

The last sentence just before your conclusion section is "Note that this
message is sent using best-effort delivery". You haven't mentioned "best
effort" delivery up to this point! You said that timing constraints on message
transmission are used (statically?) to determine an acceptable schedule. So
what on earth does "best effort" mean?? That the compiler statically decides,
"oh dear, this message send would screw up my schedule, so let's not bother
with it"?

============================================================================
