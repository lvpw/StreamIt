%\vspace{.5in}
\newpage

\newcommand{\doc}[1]{{\bf {\tt #1}} \vspace{3pt} \\}

\renewcommand{\theequation}{A-\arabic{equation}}
% redefine the command that creates the equation no.
\setcounter{equation}{0}  % reset counter 
\setcounter{section}{0}

\begin{center}
\large{\bf{APPENDIX:  Details on Java Syntax \vspace{6pt} \\ ***DRAFT***}}
\end{center}

\section{Java Classes}

A diagram of the Java class hierarchy for StreaMIT is shown in
Figure~\ref{fig:hierarchy}.  A summary of the methods in each class is
as follows.

\subsection{StreaMITObject}

A {\tt StreaMITObject} contains static fields and methods that are
useful for all classes in the stream.  The other classes extend this
type simply so that they can share the same namespace as the constants
and methods that it defines.

\subsubsection{Fields}

\doc{TimeInterval BEST\_EFFORT}  This pre-defined time interval
indicates that a message should be delivered on a ``best-effort''
basis, without strict timing guarantees.

\doc{SplitJoinType ROUND\_ROBIN}  This is used to specify a round robin splitter or joiner.

\doc{SplitJoinType NULL}  This is used to specify a splitter or joiner
that is null (it processes no items).

\doc{SplitJoinType DUPLICATE}  This specifies a duplicating splitter.

\doc{SplitJoinType COMBINE}  This specifies a combining joiner.

\subsubsection{Methods}

\doc{SplitJoinType WEIGHTED\_ROUND\_ROBIN(int w1, int w2, ...)}  This
specifies a weighted round robin with the given weights.  This
function does not take a variable number of arguments, but rather is
defined for all numbers of arguments that would be likely to occur in
a StreaMIT program.

\doc{Filter IDENTITY()} This returns a {\tt Filter} that outputs
exactly the items that it inputs.

\doc{MAX\_LATENCY(Stream a, Stream b, int n)}  This directive
constrains the schedule such that, at any given time, $a$ can only
progress up to the wavefront of information that $b$ will see after
$n$ invocations of its own work function.

\begin{figure}
\psfig{figure=hierarchy.eps,width=3.0in}
\caption{\protect\small The StreaMIT class hierarchy.  Other StreaMIT
classes unrelated to this hierarchy are {\tt SplitJoinType}, {\tt
Channel}, {\tt Portal}, and {\tt TimeInterval}.
\protect\label{fig:hierarchy}}
\end{figure}

\subsection{Stream extends StreaMITObject}

The {\tt Stream} represents a portion of the stream graph that inputs
has exactly one input channel and exactly one output channel.

\subsubsection{Methods}

\doc{void init(user-defined arguments)}  The {\tt init} function is
called automatically when the {\tt Stream} is first instantiated; it
receives as its arguments the same arguments that were passed to the
constructor.  Additionally, the {\tt init} function can be called
again with a message at runtime to trigger a re-initialization of this
stream.  The purpose of the function is to initialize child streams
and to set parameters used with this stream.  The filter can also
push, pop, and peek items from its channels from within the {\tt init}
function, although this usually isn't necessary.

\doc{Stream add(Stream child)}  The {\tt add} function appends {\tt
child} to the current pipeline of blocks comprising this stream and
returns {\tt child}.  It can only be called from within the {\tt init}
function.

\doc{void run()} The {\tt run} function provides an outside
interface for starting the stream.  No component of any stream may
call {\tt run}.

\subsection{Filter extends Stream}

The {\tt Filter} is the most basic kind of stream.  It contains no
child streams, and thus calling {\tt add} is forbidden from within its
{\tt init} function.  Instead, the {\tt Filter} defines a {\tt work}
function that explicitly describes the transfer of input items to
output items.  A filter has some input and output type, hereafter
referred to as {\tt <input-type>} and {\tt <output-type>},
respectively.

\subsubsection{Fields} 

\doc{Channel input}
\doc{Channel output} These input and output channels must be the first
two fields declared in the class.  At the line of their declaration,
they should be initialized to be a new {\tt <input-type>Channel} and
{\tt <output-type>Channel}, respectively.  These {\tt Channel} types
will be auto-generated.

\subsubsection{Methods}

\doc{void work()}  The {\tt work} function represents the most
fine-grained execution step of the filter.  It can read from the input
channel, write to the output channel, modify the state of the filter,
and send messages.

\doc{<input-type> drain(int index)}  The {\tt drain} function
specifies what values should be output from this filter if it lies on
the boundary of a region that is being re-initialized.  For the
information in the re-initialized region to drain out, downstream
filters will need to input data from the upstream edge of the region.
However, we do not want to pull fresh information from outside of the
region into the drain, so the {\tt drain} function is invoked instead
to fabricate data.  The {\tt drain} function is successively called
with indices 0, 1, 2, $\dots$ until the downstream region has drained.

\subsection{SplitJoin extends Stream}

\subsubsection{Methods}

A {\tt SplitJoin} is a set of independent, parallel streams that are
contained between a splitter and a joiner.

\doc{Splitter setSplitter(SplitJoinType splitter)}  This command sets the splitter within a {\tt SplitJoin} and returns its argument.  It must be called in the {\tt init} function of the {\tt SplitJoin}.

\doc{Joiner setJoiner(SplitJoinType joiner)} This command sets the joiner within a {\tt SplitJoin} and returns its argument.  It must be called in the {\tt init} function of the {\tt SplitJoin}.

\doc{Stream add(Stream child)} This {\tt add} function overrides the {\tt add} function of {\tt Stream} to append {\tt child} as a parallel component within the {\tt SplitJoin.}  The first stream to be added is connected to the first port of the splitter and joiner, and likewise with the rest of the streams.  This function returns its argument.

\subsection{FeedbackLoop extends Stream}

The FeedbackLoop provides the means for creating cycles in the stream
graph.

\subsubsection{Methods}

\doc{Joiner setJoiner(SplitJoinType joiner)}
\doc{Stream setBody(Stream stream)}
\doc{Splitter setSplitter(SplitJoinType splitter)}
\doc{Stream setLoop(Stream stream)} These methods set the joiner, body
stream, splitter, and loop stream for the feedback loop; they each
return their argument.  Each of them must be called from within the
{\tt init} function.

\doc{<varying type> initPath(int index)}  The {\tt initPath} function provides inputs to the joiner at the head of the feedback loop during the initialization period when there are no items on the channels around the loop.  The function is called with the number of the item that is being requested, starting from 0.

\doc{void setDelay(int delay)}  The {\tt setDelay} function specifies how many times the {\tt initPath} function is invoked before the joiner starts drawing input items from the feedback channel.

\subsection{SplitJoinType}

A {\tt SplitJoinType} represents a compiler-defined configuration for
the splitter or joiner in a SplitJoin.  For now, the user cannot
define custom {\tt SplitJoinType}'s, and the only ones available are
those that are constant fields in {\tt StreaMITObject}.

\subsection{Channel}

Channels are of a given type {\tt <channel-type>}, and are
auto-generated classes.  Their full Java class name is {\tt
<channel-type>Channel}, e.g., {\tt IntChannel}.  They provide typed
FIFO queues communicating steady-state data between filters.

\subsubsection{Methods}

\doc{<type> pop()}  The {\tt pop} function removes the item from the end of the channel and returns it.

\doc{<type> peek(int index)}  The {\tt peek} function returns the value at {\tt index} slots from the end of the channel, where {\tt peek(0)} = {\tt pop()}.  Unlike {\tt pop}, {\tt peek} does not remove any items from the channel.

\doc{void push(<type> item)}  The {\tt push} function enqueues {\tt item} onto the front of the channel.

\subsection{Portal}

Portals provide a means for broadcast messaging within StreaMIT.  They
are of a given type {\tt <portal-type>}, and are auto-generated
classes.  Note that {\tt <portal-type>} can be either a class or an
interface.  Their full Java class name is {\tt <portal-type>Portal},
e.g., {\tt MyFilterPortal}.

\subsubsection{Methods}

\doc{void register(<portal-type> receiver)}  The {\tt register} method adds {\tt receiver} to this portal as an object that will be the target of all messages passed to the portal.

\doc{all void methods of <portal-type>}  A portal automatically defines each of the void methods that is implemented by {\tt <portal-type>}.  Since these methods have no return value, their invocation can act as a message to the receiver object.  However, the signature of these methods is modified to accept an extra argument of type {\tt TimeInterval}, which specifies the timing of the message delivery.  When a method is called on the Portal, it is treated as a message and is forwarded to all registered receivers within the given time interval.

\subsection{TimeInterval}

The {\tt TimeInterval} class simply provides a wrapper for specifying
the upper and lower time limits for a message delivery.

\subsubsection{Methods}

\doc{TimeInterval(int maxTime)}  This constructs a time interval with maximum delivery time {\tt maxTime}.  The units of time are according to relative information wavefronts as described in the paper.

\doc{TimeInterval(int minTime, int maxTime)}  This constructs a time interval with minimum delivery time {\tt minTime} and maximum delivery time {\tt maxTime}.  The units of time are according to relative information wavefronts as described in the paper.

\section{Semantic checking}

\subsection{Java restrictions}
\label{sec:javarestrict}

Although this version of StreaMIT is expressed as legal Java syntax,
it allows only a small subset of the features of Java.  Here we list
some of the syntactical elements of Java that fall outside the domain
of legal StreaMIT programs.
\begin{enumerate}

\item StreaMIT disallows any instantiation, subclassing, or method
call to any object from the Java class libraries.  The only exception
is {\tt Object} itself, which may be subclassed as the basic means of
abstraction; however, no member functions of {\tt Object} may be
called.  Note that this eliminates threads and exceptions from
consideration because they require the instantiation of an object from
the class library.

\item StreaMIT does not support native method calls.

\end{enumerate}

\subsection{StreaMIT restrictions}

Though every legal StreaMIT program is a legal Java program, there are
legal Java programs--even with the constraints of
Section~\ref{sec:javarestrict}--that violate higher-level semantic
requirements of StreaMIT.  We outline these constraints as follows:

\begin{enumerate}

\item In this version of StreaMIT, each invocation of a filter's work
function must peek, pop, and push a constant number of items.  Dynamic
rates will be the subject of future work.

\item If two filters are connected, then their corresponding input and
output types must match.  We postpone a formal treatment of types
until a future paper.

\item A given instance of a stream or filter must not appear more than
once in the stream graph.

\item A message handler cannot push, pop, or peek items from the input
and output channels of a filter.  However, a message handler can send
another message.

\item There must be no deadlock or buffer overflow in the program.  We
have developed a simple algorithm to verify that feedback loops and
simple round-robin SplitJoins neither deadlock nor overflow.

\item For weighted round robin SplitJoins, we are still developing our
analysis.  For now, we can at least verify that if the first filter on
a branch of a SplitJoin inputs zero items and the splitter is a
weighted round robin, then the splitter must have a weight of 0
assigned to the branch.  Similarly, if the last filter on a branch
output zero items and the joiner is a weighted round robin, then the
joiner must assign a weight of 0 to the branch.

\item The numer of inputs and outputs on weighted round robin joiners
and splitters must match the number of parallel streams in a
SplitJoin.

\item The splitter and joiner in a feedback loop must have two outputs
and two inputs, respectively, and must be something other than NULL.

\end{enumerate}
