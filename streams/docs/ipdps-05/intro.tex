\Section{Introduction}

Image compression, whether for still pictures or motion pictures
(e.g., video), plays an important role in Internet and multimedia
applications, digital appliances such as HDTV, and handheld devices
such as digital cameras and mobile phones. Compression allows one to
represent images and video with a much smaller amount of data and
negligible quality loss. The reduction in data decreases storage
requirements (important for embedded devices) and provides higher
effective transmission rates (important for Internet enabled devices).

Unfortunately, implementing a compression scheme can be especially
difficult. For performance reasons, implementations are typically not
portable as they are tuned to specific architectures. And while image
and video compression is needed on embedded systems, desktop PCs, and
high end servers, writing a separate implementation for every
architecture is not cost effective. Furthermore, compression standards
are also continuously evolving, and thus compression programs must be
easy to modify and update.

A typical compression algorithm involves three types of operations:
data representation, lossy compression, and lossless
compression. These operations are semi-autonomous, exhibit data and
pipeline parallelism, and easily fit into a sequence of distinct
processing kernels. As such, image and video compression is a good
match for the streaming model of computation, which affords certain
advantages in terms of programmability, robustness, and achieving high
performance. Our goal is to implement well-known still image and
motion picture compression standards---such as JPEG and MPEG-2---in
StreamIt~\cite{streamitcc}, a high-level architecture-independent
language for the streaming domain. This will result in clean,
malleable, and portable codes.
% TODO: emphasize benefits over C
In addition, using the stream-aware StreamIt compiler, we can produce
highly optimized codes that are competitive with hand-tuned
implementations. Our architecture targets include conventional
processors, as well as new and emerging wire
exposed and multi-core architectures~\cite{cell05hpca,mai00smartmemories,raw02ieee,raw04isca,burger04trips}.

This work is in the context of the StreamIt programming
language~\cite{streamitcc}, an architecture-independent stream
language that aims to improve programmer productivity within the
streaming domain. StreamIt provides an intuitive programming model,
allowing the programmer to build an application by connecting
components together into a stream graph, where the nodes represent
actors that carry out the computation, and edges represent FIFO
communication channels between actors. As a result, the parallelism
and communication topology of the application are exposed, empowering
the compiler to perform many stream-aware
optimizations~\cite{lamb03pldi,agrawal05cases,sermulins05lctes,gordon02asplos}
that elude other languages.

