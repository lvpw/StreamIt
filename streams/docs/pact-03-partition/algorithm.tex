structures
-------------------------------------------------------------------------
container s:
  s.height       : returns height of region
  s.width[i]     : returns width of i'th row
  s.get(i, j)    : returns the (i,j)'th child

globals
-------------------------------------------------------------------------
// A_s[x1][x2][y1][y2][n] holds minimum cost of assigning children 
// (x1..x2, y1..y2) of stream s to n tiles
forall s in graph:  int[][][][][] A_s;

// do partitioning of stream s on n tiles and return mapping from node
// to partition number
stream->int toplevel(stream s, int n)
-------------------------------------------------------------------------
setup(n)
cost = getCost(s, n)
// if desired, eliminate extra partitions that aren't contributing to
// the cost
while (n>1 && getCost(s, n-1)==cost)
  n--
endwhile
traceback(s, empty-map, 0, n)
return map

// setup for n partitions
void setup(int n) 
-------------------------------------------------------------------------
(pad all splitjoins so that each parallel stream is same length)
(add maximal synchronization to all splitjoins)
(consider feedbackloops as a 2-way splitjoin, each child of which is a
 2-element pipeline (to prevent fusing with loop/body separately)
(eliminate all splitjoins in pipelines in favor of rectangular pipelines)

forall s in graph
  A_s = new int[s.length()][s.length()][s.width()][s.width()][n]
  forall (x1,x2,y1,y2,n) \in A_s
    A[x1][x2][y1][y2][n] = -1

// return minimal cost for allocating <n> partitions to children
int getCost(stream s, int n)
-------------------------------------------------------------------------
// see if we will need a joiner
if (n>1 && needsJoiner(s)) 
  n--
if (s is Node)
  return getNodeCost(s, n)
if (s is Container)
  int maxWidth = max(s.width[0], ..., s.width[s.height]);
  return getContCost(s, 0, maxWidth-1, 0, s.height-1, n)
endif

// returns whether or not stream <s> needs a joiner if it is spread
// across multiple tiles
boolean needsJoiner (stream s)
-------------------------------------------------------------------------
par = s.parent()
if (par==null)
  // if have no parent, then need a joiner
  return true
else if (par.width()>1)
  // if par has multiple streams, it will have joiner instead
  return false;
else if (par.parent()==null && s!=par.get(0, par.length()-1))
  // if we're in middle of toplevel stream, then need joiner
  return true
else
  // otherwise we're guaranteed by lifter that par.parent().width>1,
  // so there will be a joiner there and we don't need one for s
  return false
end if
