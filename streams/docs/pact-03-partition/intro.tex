\section{Introduction}

Recent trends in both software hardware are accentuating the need for
high-level distributed stream programming.  On the software side,
applications centered around streams of data are becoming increasingly
importan and widespread.  The stream abstraction is central to
embedded applications for hand-held computers, cell phones, and sensor
networks, as well as for high-performance applications such as cell
phone base stations, radar image processing, and hyperspectral image
analysis.  

At the same time, with the wire delay problem looming ahead, there is
emerging a class of communication-exposed
architectures~\cite{raw-micro,trips,smartmemories}.  With replicated
processing units and distributed memory, these architectures are a
good match for the abundant parallelism and regular communication
patterns that are prevalent in stream programs.  However, if these
architectures are to be fully utilized, there needs to exist a
portable, high-level programming model that can be efficiently
compiled onto tomorrow's generation of machines.

This is the motivation of the StreamIt language and compiler.  The
StreamIt language provides high-level stream abstractions that aim to
improve the lives of both programmers and compiler writers.  One of
the novelties in StreamIt is the use of ``structured streams'': a
program consists of a set of concurrently executing filters that are
connected using a few hierarchical primitives.  We believe that
structured streams will offer critical benefits to software engineers,
just as structured control flow did many years ago.

In this paper, we explore the compiler side of structured stream
programming.  Though structure's restrictions on the programmer may be
beneficial, these restrictions on the compiler could become a curse
without proper analyses and optimizations.  Towards this end, we make
two contributions:
\begin{item}

\item A general dynamic programming algorithm for partitioning a
structured stream graph.  The algorithm exploits many aspects of the
graph's structure to improve its efficiency and effectiveness.

\item An implementation of the partitioner in the context of load
balancing StreamIt programs on Raw~\cite{raw-micro}, where we
demonstrate improvements over a greedy algorithm by an average of
24\%.

\item A suite of refactoring transformations that can be performed on
a structured stream graph, thereby  increasing the 

\end{item}


Say that the problem with restricting programmer flexibility is that
you restrict compiler flexibility.  After all, the structuring pattern
they chose isnt' necessarily the most effiecient.  So compiler needs
to have flexibility to morph the stream representation between
different equivalent forms.  It also needs to have a powerful and
efficient analysis framework for choosing between which form is the
"best".

This paper makes two contibutions: demonstrate flexibility of
structure by a series of stream graphs, then demonstrate power lended
by structure by abstracting the structures into a canonical form that
is very analyzable.  We give a dynamic programming algorithm that
leverages the structure of the graph to consider many possibilities, 
 could be used to determine any number of things about the graph; in
we focus on the load balancing problem.

Using the flexibility of the graph transformations, we can transform a
graph into a canonical form, on which we can do powerful analyses, and
then have the flexibility to transform it back into the form that is
most efficient.

 then say that contributions are a partitioner that is in some
respects more powerful than on an unstructured graph:
  - cuts along important places
  - cuts in the right directions
  - detecting symmetry and hierarchy to save time
    - work estimation
    - alisasing of child configurations
    - evaluating child configurations themselves

- does fissoin and fusion
- shows how to effectively compile something that was convenient for the programmer
- maintains single-input, single-output
- sticks with space multiplexing

- show how we can provide rectangular abstraction on single-input, single-output streams

- stream structures present one level of granularity... explore other
granularities through partitioning.  demonstrate two things: that with
single-input, single-output structures, can have flexible algorithms
with dynamic programming (e.g. that does both fission and fusion of
nodes), and 2) that a host of graph transformations can flexibly
support a range of other granularities in the program.

- another observation: the symmetry.  programs very often have not
only structure in their communication, but structure in their loads,
both vertically and horizontally.  the most advantageous partitionings
are ones that cut along those dimensions, which is exposed to the
compiler in a structured language.

  - partitioner takes advantage of this in two ways: 
    1) by detecting symmetry and only calculating things once
    2) by drawing cuts along likely paths
    3) by automatically calculating some properties that are the best,
       e.g. if you have the same filter duplicated in a splitjoin

- two thrusts: that structure actually SUPPORTS powerful ways of
program reasoning, and that we are flexible enough to manipulate
structured programs into a number of isomorphic forms.  can consider
structures on an abstract level, and then implement them in any number
of ways.

- very fast?  no
