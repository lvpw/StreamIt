\begin{figure}[t]
\scriptsize
\begin{verbatim}
float->float filter FIRFilter (float sampleRate, int N) {
  float[N] weights;

  init {
    weights = calcImpulseResponse(sampleRate, N);
  }

  prework push N-1 pop 0 peek N {
    for (int i=1; i<N; i++) {
      push(doFIR(i));
    }
  }

  work push 1 pop 1 peek N {
    push(doFIR(N));
    pop();
  }

  float doFIR(int k) {
    float val = 0;
    for (int i=0; i<k; i++) {
      val += weights[i] * peek(k-i-1);
    }
    return val;
  }
}

float->float pipeline Equalizer (float samplingRate, int N) {
  add splitjoin {
    int bottom = 2500;
    int top = 5000;
    split duplicate;
    for (int i=0; i<N; i++, bottom*=2, top*=2) {
      add BandPassFilter(sampleRate, bottom, top);
    }
    join roundrobin;
  }
  add Adder(N);
}

void->void pipeline FMRadio {
  add DataSource();
  add FIRFilter(sampleRate, N);
  add FMDemodulator(sampleRate, maxAmplitude);
  add Equalizer(sampleRate, 4);
  add Speaker();
}
\end{verbatim}
\vspace{-12pt}
\caption{\protect\small Parts of an FM Radio in StreamIt.
\protect\label{fig:radiocode}}
\vspace{-12pt}
\end{figure}

\begin{figure}[t]
\begin{center}
\hspace{0.1in}
\psfig{figure=radio-ascoded.eps, width=2.8in}
\vspace{-36pt}
\caption{\protect\small Block diagram of the FM Radio.
\protect\label{fig:radio-ascoded}}
\vspace{10pt}
~~
\begin{minipage}{0.46in}
\centering
\psfig{figure=pipeline.eps,width=0.46in} \\
\end{minipage} 
~
\begin{minipage}{1.3in}
\centering
\psfig{figure=splitjoin.eps,width=1.3in} \\
\end{minipage}
~
\begin{minipage}{1.02in}
\centering
\psfig{figure=feedback.eps,width=1.02in} \\
\end{minipage} 
\\ ~ \\ {\bf \protect\small (a) A pipeline. ~~(b) A splitjoin. ~~(c) A feedbackloop.}
\caption{\protect\small Stream structures supported by StreamIt.
\protect\label{fig:structures}}
\vspace{-12pt}
\end{center}
\vspace{-12pt}
\end{figure}

\section{The StreamIt Language}
\label{sec:streamit}

StreamIt is a portable programming language for high-performance
signal processing applications.  The current version of StreamIt is
tailored for static-rate streams: it requires that the input and
output rates of each filter are known at compile time.  In this
section, we provide a very brief overview of the syntax and semantics
of StreamIt, version 1.1.  A more detailed description of the design
and rationale for StreamIt can be found in~\cite{streamitcc}, which
describes version 1.0; the most up-to-date syntax specification can
always be found on our website~\cite{streamitweb}.

\subsection{Language Constructs}

The basic unit of computation in StreamIt is the {\it filter}.  A
filter is a single-input, single-output block with a user-defined
procedure for translating input items to output items.  An example of
a filter is the {\tt FIRFilter}, a component of our software radio
(see Figure \ref{fig:radiocode}).  Each filter contains an {\tt init}
function that is called at initialization time; in this case, the {\tt
FIRFilter} calculates {\tt weights}, which represents its impulse
response.  The {\tt work} function describes the most fine grained
execution step of the filter in the steady state.  Within the {\tt
work} function, the filter can communicate with its neighbors via FIFO
queues, using the intuitive operations of {\tt push(value)}, {\tt
pop()}, and {\tt peek(index)}, where {\tt peek} returns the value at
position {\tt index} without dequeuing the item.  The number of items
that are pushed, popped, and peeked\footnote{We define $peek$ as the
total number of items read, including the items popped.  Thus, we
always have that $peek \ge pop$.} on each invocation are declared with
the {\tt work} function.

In addition to {\tt work}, a filter can contain a {\tt prework}
function that is executed exactly once between initialization and the
steady-state.  Like {\tt work}, {\tt prework} can access the input and
output tapes of the filter; however, the I/O rates of {\tt work} and
{\tt prework} can differ.  In an {\tt FIRFilter}, a {\tt prework}
function is essential for correctly filtering the beginning of the
input stream.  The user never calls the {\tt init}, {\tt prework}, and
{\tt work} functions--they are all called automatically.

%% StreamIt's representation of a filter is an improvement over
%% general-purpose languages.  In a procedural language, the analog of a
%% filter is a block of statements in a complicated loop nest.  There is
%% no clear abstraction barrier between one filter and another, and
%% high-volume stream processing is muddled with global variables and
%% control flow. The loop nest must be re-arranged if the input or output
%% ratios of a filter changes, and scheduling optimizations further
%% inhibit the readability of the code.

%% In an object-oriented language, one could implement a stream
%% abstraction as a library.  This avoids some of the problems associated
%% with a procedural loop nest, but the programming model is complicated
%% by efficiency concerns--to optimize cache performance, the entire
%% application processes blocks of data that complicate and obscure the
%% underlying algorithm.

%% In contrast to these alternatives, StreamIt places the filter in its
%% own independent unit, making explicit the parallelism and inter-filter
%% communication while hiding the grungy details of scheduling and
%% optimization from the programmer.

The basic construct for composing filters into a communicating network
is a {\it pipeline}, such as the FM Radio in Figure
\ref{fig:radiocode}.  A pipeline behaves as the sequential composition
of all its child streams, which are specified with successive calls to
{\tt add} from within the pipeline.  For example, the output of {\tt
DataSource} is implicitly connected to the input of {\tt FIRFilter},
who's output is connected to {\tt FMDemodulator}, and so on.  The {\tt
add} statements can be mixed with regular imperative code to
parameterize the construction of the stream graph.

There are two other stream constructs besides pipeline: {\it
splitjoin} and {\it feedbackloop} (see Figure \ref{fig:structures}).
From now on, we use the word {\it stream} to refer to any instance of
a filter, pipeline, splitjoin, or feedbackloop.

A splitjoin is used to specify independent parallel streams that
diverge from a common {\it splitter} and merge into a common {\it
joiner}.  There are two kinds of splitters: 1) $duplicate$, which
replicates each data item and sends a copy to each parallel stream,
and 2) $roundrobin(w_1, \dots, w_n)$, which sends the first $w_1$
items to the first stream, the next $w_2$ items to the second stream,
and so on.  roundrobin is also the only type of joiner that we
support; its function is analogous to a roundrobin splitter.  If a
roundrobin is written without any weights, we assume that all $w_i =
1$.  The splitter and joiner type are specified with the keywords {\tt
split} and {\tt join}, respectively (see Figure \ref{fig:radiocode});
the parallel streams are specified by successive calls to {\tt add},
with the $i$'th call setting the $i$'th stream in the splitjoin.

The last control construct provides a way to create cycles in the
stream graph: the feedbackloop.  Due to space constraints, we omit a
detailed discussion of the feedbackloop.

\subsection{Design Rationale}

StreamIt differs from other stream languages in that it imposes a
well-defined structure on the streams; all stream graphs are built out
of a hierarchical composition of filters, pipelines, splitjoins, and
feedbackloops.  This is in contrast to other environments, which
generally regard a stream as a flat and arbitrary network of filters
that are connected by channels.  However, arbitrary graphs are very
hard for the compiler to analyze, and equally difficult for a
programmer to describe.  The comparison of StreamIt's structure with
arbitrary stream graphs could be likened to the difference between
structured control flow and GOTO statements: though the programmer
might have to re-design some code to adhere to the structure, the
gains in robustness, readability, and compiler analysis are immense.

%% \subsection{Messages}

%% StreamIt provides a dynamic messaging system for passing irregular,
%% low-volume control information between filters and streams.  Messages
%% are sent from within the body of a filter's {\tt work} function,
%% perhaps to change a parameter in another filter.  The central aspect
%% of the messaging system is a sophisticated timing mechanism that
%% allows filters to specify when a message will be received relative to
%% the flow of data items between the sender and the receiver.  With the
%% messaging system, StreamIt is equipped to support full application
%% development--not just high-bandwidth data channels, but also events,
%% control, and re-initialization.
