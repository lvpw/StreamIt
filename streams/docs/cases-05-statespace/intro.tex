%% This is an example first section.  You should put section/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the section/appendix file.
%% You can process specific files by typing their names in at the
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\mysection{Introduction}

%\mysubsection{Problem Overview}

Digital devices are increasingly common in everyday life. Examples
include cell phones, modems, CD players, and high definition
televisions. These products utilize Digital Signal Processing (DSP)
for a variety of applications, including signal compression and
decompression, noise reduction, and error correction.  Because such
programs often run in embedded environments with limited power and
strict real-time requirements, this is a domain where optimization is
still very important.  

Due to the emphasis on performance, DSP programs are typically
implemented in two phases.  First, the functionality of the algorithm
is specified at a high level of abstraction by applications designers.
Then, a set of DSP experts examine the global flow of data and perform
specialized transformations to efficiently map the algorithm to C and
assembly code.  This process is tedious and costly, as every change in
the high-level design necessitates new optimizations and
re-implementation of the code; in addition, the optimizations are
typically architecture-dependent, thereby sacrificing portability and
robustness.  In an ideal world, the compiler would provide a unified
framework for optimizing high-level DSP algorithms, thereby providing
an automatic path from the functional specification to an efficient
implementation.

As a small step towards this vision, this paper introduces a new
framework for analyzing and optimizing a large class of DSP
applications.  The framework, which we call linear state space
analysis, applies a large body of work on linear state space systems
to the domain of programming languages and compilers.  A state space
system is one in which a computational element produces and consumes
some values on each execution.  In addition, some internal data may be
preserved between executions; we refer to these values as {\it
states}.

A state space system is linear if it satisfies two criteria.  First,
each output must be a linear combination of the inputs and the current
state values.  Second, on each execution, the state values must be
updated as a linear combination of the inputs and the previous state
values.  Linear state space systems can model a large class of DSP
operations, including FIR filters, IIR filters, DCTs, upsamplers /
downsamplers and linear difference equations.  They are a
generalization of linear systems, in which a linear input-output
relationship holds but there is no state retained between executions.
There is a strong theoretical foundation for reasoning about linear
state space systems; it has been shown, for example, how to minimize
the number of states~\cite{Moore} as well as the number of parameters
in the system~\cite{Ackermann/Bucy,Mayne,Schutter}.

Our technique leverages domain-specific knowledge of linear state
space systems to perform novel optimizations on stream programs.  Our
framework applies to languages based on the synchronous dataflow model
of computation.  In this model, a program is a set of autonomous
filters that communicate over FIFO channels.  On each execution, a
filter consumes some items from its input channels and produces some
items on its output channels; it may also retain states between
executions.  A filter can be modeled as a linear state space system if
it satisfies the criteria described previously.  In this paper, we use
StreamIt as the input language; StreamIt is a high-level language and
compiler infrastructure for DSP applications.

This paper makes the following contributions:

\begin{itemize}

\vspace{\itemshrink} \item An extraction algorithm that examines each
filter and, where possible, builds a linear state space representation
to describe its behavior.

\vspace{\itemshrink} \item Rules for combining adjacent linear state space
blocks into a single representation, thereby eliminating redundant
computations and enabling further optimizations.  Each possible
configuration of blocks (sequential, parallel, and cyclic) is handled.

\vspace{\itemshrink} \item A state removal optimization that detects
and eliminates redundant states within a block.

\vspace{\itemshrink} \item A parameter reduction optimization that
adjusts the coefficients of the state update and output calculation in
order to decrease the number of operations used.

\vspace{\itemshrink} \end{itemize}

While the principle contribution of this paper is in the elegance and
generality of its theoretical formulation, we also demonstrate that
state space analysis is tractable by implementing it in the StreamIt
compiler.  We evaluate state space analysis over a small set of
micro-benchmarks and illustrate that it is more general than linear
optimizations alone.

In the rest of this section, we give an overview of StreamIt and
illustrating examples of state space analysis\footnote{\smaller As the
rest of this paper is devoted to linear state space analysis, we often
say only ``state space analysis'' for brevity.}.
Section~\ref{sec:statespace} gives the details of our state space
representation, including extraction and combination rules, while
Section~\ref{sec:optimization} describes the optimizations.
Section~\ref{sec:results} discusses our implementation,
Section~\ref{sec:related} details related work, and
Section~\ref{sec:conclusion} concludes.

%% A linear state space system is one in which a computational element
%% produces and consumes some values on each execution.  In addition,
%% some internal data may be preserved between executions; we refer to
%% these values as {\it states}.  In a linear state space system, each
%% output is a linear combination of the states and the input values.
%% The states are also updated on each execution to be a linear
%% combination of the inputs and the previous state values.  There is a

%% \mysubsection{DSP Analysis}

%%     In order to properly analyze DSP applications, we must use an
%% appropriate framework to model them.  This framework should
%% contain a number of simplifications in order to make our analysis
%% workable, but not too many simplifications that our analysis fails
%% to be robust.

%%     We start with the top level notion of an
%% application, defined as a large module that receives inputs,
%% performs computations, and outputs results.  This definition,
%% while correct, does not lend itself to any type of application
%% analysis. The first simplification we make is to divide an
%% application into blocks, which are abstract input-output modules.
%% These blocks are interconnected in a certain way to form the full
%% application. We can think of each block as a mini-application: it
%% takes its own inputs, performs calculations, and produces outputs.

%% \begin{figure}[t]
%%   \centering
%%   \includegraphics[width=5.0in]{figures/beamformer.eps}
%%   \caption{A DSP block diagram of the application Beamformer}
%%   \label{fig:block-diagram}
%% \end{figure}

%%     Blocks can be characterized in various ways. The simplest characterization
%% of blocks is a \textit{linear} block, defined as a module that
%% outputs a linear combination of its inputs plus a constant term. A
%% linear block can be represented by a matrix relating inputs to
%% outputs and a vector of constants. The next simplest
%% characterization of blocks is \textit{linear state space}. Such a
%% block uses a set of state variables. The output of this block is a
%% linear combination of its inputs and state variables. In addition,
%% the state variables are updated by a linear combination of
%% themselves and inputs.  A linear state space block can be
%% represented by four independent matrices.

%%     A linear state space characterization is more general than a
%% linear characterization - all linear blocks are also linear
%% state space blocks, but the converse is not true. The intuitive
%% reason for this fact is that a linear block is memoryless, meaning
%% the outputs only depend on current inputs. However, a linear
%% state space block has memory in the form of state variables, so
%% the outputs depend on current inputs and past inputs.

%%     We will perform analysis and optimization of DSP applications at
%% the linear state space level. We choose this representation
%% because it models a wide class of applications or parts of
%% applications, and it is simple to work with.

%%     Our work with state space representations will be done in the
%% context of StreamIt, a programming language designed for streaming
%% applications \cite{streamitcc}.  StreamIt allows users to create
%% their own blocks, but limits the way these blocks can be
%% connected. We perform the following steps on a StreamIt program:

%% \begin{enumerate}
%% \vspace{\itemshrink} \item Examine each block and determine whether or not it can be
%% characterized as linear state space. If it can, extract the
%% appropriate state space representation.

%% \vspace{\itemshrink} \item Combine connected blocks that each have a state space
%% representation, using an appropriate set of rules depending on the
%% type of connection.

%% \vspace{\itemshrink} \item Optimize representations through the use of state space
%% transformations.

%% \vspace{\itemshrink} \item Convert the state space representation(s) back to StreamIt
%% code.
%% \vspace{\itemshrink} \end{enumerate}

%% \mysubsection{Organization}
