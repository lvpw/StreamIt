\mysubsection{The StreamIt Language}
\label{sec:background}

StreamIt~\cite{streamitcc} is an architecture-independent language for
signal processing applications.  StreamIt aims to expose the abundant
parallelism and regular communication patterns in stream programs for
the benefit of the compiler.  The optimizations described in this
paper would be infeasible in a general-purpose language such as C.  As
detailed elsewhere~\cite{streamitcc}, C obscures the high-level
structure of a streaming application due to possible aliasing between
autonomous filters, complex modulo expressions on circular buffers,
and muddling of atomic execution steps with global control flow.
%There is not enough information in C code to automatically perform the
%high-level transformations that experts use to achieve competitive
%performance.  
In addition, StreamIt offers improved programmer productivity over C
due to its parameterizable and composable stream constructs.

The basic programmable unit in StreamIt is a filter; for example, see
the {\tt MovingAverage} filter in Figure~\ref{fig:filter-example}.  A
filter contains a work function which executes atomically, popping a
fixed number of items from the filter's input tape and pushing a fixed
number of items to the filter's output tape.  A filter can also
``peek'' at a given index on its input tape without consuming the
item; this makes it simple to write sliding-window applications such
as the {\tt MovingAverage}.  The push, pop, and peek rates are
declared on the same line as the work function, thereby enabling the
compiler to construct a static schedule of filter
firings~\cite{lee87static}.

Each filter has a distinct address space.  A filter can store two
types of variables: a {\it field} and a {\it local}.  Fields are
declared in the scope of the filter and are preserved across
executions, while locals are declared inside the work function and are
only live within a single execution.  There is also an init function,
run once at the beginning of the program, that can be used to
initialize fields.

StreamIt provides three hierarchical structures for composing filters
into larger stream graphs (see Figure~\ref{fig:structures}).  The {\it
pipeline} construct composes streams in sequence, with the output of
one connected to the input of the next.  The {\it splitjoin} construct
distributes data to a set of parallel streams, which are then joined
together in a roundrobin fashion.  The {\it feedback loop} provides a
mechanism for introducing cycles in the graph.  An example of a
pipeline appears in Figure~\ref{fig:iir-pipeline}.  It contains a
single IIR (Infinite Impulse Response) filter, which could be
implemented as shown at the top of Figure~\ref{fig:opt-seq}.

\begin{figure}[t]
\begin{minipage}{3.25in}
{\scriptsize
\begin{verbatim}
float->float filter MovingAverage(int N) {
  float[N] weights;  // a filter field

  // init function initializes the weights
  init {
    for (int i=0; i<N; i++)
      weights[i] = 1/N;
  }

  // work func. declares push, pop, peek rates
  work push 1 pop 1 peek N {
    float result = 0;  // a local variable
    for (int i=0; i<N; i++) {
      result += weights[i] * peek(i);
    }
    push(result);
    pop();
  }
}         
\end{verbatim}
\vspace{-18pt}
\caption{Example of a StreamIt filter.~~~~~~~\protect\label{fig:filter-example}}}
\end{minipage}
\vrule
\begin{minipage}{3.50in}
\begin{singlespace}

~~~~
\hspace{0.1in}\begin{minipage}{0.46in}
{\centering
\psfig{figure=pipeline.eps,width=0.46in} \\
}
\end{minipage} 
~
\begin{minipage}{1.3in}
{\centering
\psfig{figure=splitjoin.eps,width=1.3in} \\
}
\end{minipage}
~
\begin{minipage}{1.02in}
{\centering
\psfig{figure=feedback.eps,width=1.02in} \\
}
\end{minipage}

%\\ ~ \\ {\protect\small \mbox{~}(a) A pipeline. ~~~~~~~~~~(b) A splitjoin. ~~~~~~~~~~~~~~(c) A feedbackloop.}
~ \vspace{-6pt} \\ {\protect\footnotesize \mbox{~~~~}\hspace{0.1in}(a) pipeline ~~~~~~~~~(b) splitjoin ~~~~~~~~~~~~(c) feedbackloop}
\vspace{-6pt}
\caption{Structures supported by StreamIt.
\protect\label{fig:structures}}
\vspace{8pt}
\hrule
~~\hspace{0.2in}\begin{minipage}{3in}
\vspace{8pt}
\psfig{figure=iir-pipeline.eps, width=2.33in}
~~~~
\raisebox{12pt}{\psfig{figure=iir-pipeline2.eps, width=0.46in}}

~ \\ \vspace{-49.5pt}
\caption{Example pipeline with IIR filter.~~\protect\label{fig:iir-pipeline}}
\end{minipage}
\vspace{6pt}
%\vspace{6pt}
\end{singlespace}
\end{minipage}
\hrule
\end{figure}

%%         A filter can store two types of variables - \textit{field} and
%% \textit{local}. Field variables are declared outside of the
%% specific functions (work, prework, init), and can be accessed from
%% anywhere within the filter. Local variables are declared within a
%% specific function, and only have scope within that function. For
%% example, a variable declared within the init function is local,
%% and could not be accessed within the work function. Therefore, the
%% init function is used to initialize field variables.

\mysubsection{State Space Example}

As described previously, a linear state space model describes a stream
in which both the outputs and the state values are updated as a linear
combination of the inputs and the previous states.  We use the
following notation to describe such systems:

\hspace{0.5in}\begin{minipage}{2.5in}
\starteqnstar 
\vc{\dot{\mathbf{x}}} & = & \mathbf{A}\vc{\mathbf{x}} +
\mathbf{B}\vc{\mathbf{u}} \
\doneeqnstar
\end{minipage}
\begin{minipage}{2.5in}
\starteqnstar 
\vc{\mathbf{y}}
& = & \mathbf{C}\vc{\mathbf{x}} + \mathbf{D}\vc{\mathbf{u}}
\doneeqnstar
\end{minipage}

\noindent In these equations, the state vector is denoted by
$\vc{\mathbf{x}}$, the inputs by $\vc{\mathbf{u}}$, and the outputs
by $\vc{\mathbf{y}}$. $\vc{\dot{\mathbf{x}}}$ represents the new
state vector, i.e., the state vector after it is updated. The first
equation is for the state updates, while the second equation is for the
outputs.  $\mathbf{A}$, $\mathbf{B}$, $\mathbf{C}$, and
$\mathbf{D}$ are matrices whose dimensions depend on the number of
states, inputs, and outputs.

Figure~\ref{fig:opt-seq} illustrates an optimization sequence for an
IIR filter.  Three versions of the filter are shown: original,
following state removal, and following parameter reduction.  In each
case, the state space representation for the filter is shown on the
right, along with the number of multiplications and additions needed
per execution of the work function.

The state removal optimization identifies that the states $x_1$ and
$x_2$ are always used as part of the expression $x_1 + x_2$.  Thus,
one of the states can be eliminated in favor of a single variable,
$x$, that tracks the value of the sum.  While relatively simple in
this example, such a transformation can be quite subtle when applied
to a large representation (e.g., the result of combining many filters
together.)  State removal can reduce storage requirements as well as
eliminate arithmetic operations (in this example, 1 multiplication and
4 additions).  As described in Section~\ref{sec:state-removal}, state
removal is formulated as a general sequence of matrix operations.

The parameter reduction optimization refactors the coefficients that
operate on the state variables in order to reduce the number of
operations needed.  Following the transformation, $x$ assumes a value
that is twice as large as the original (at any given point of
execution).  However, this change does not affect the output of the
filter, as the coefficients in $\mathbf{A}$ are compensated
accordingly.  The transformation enables two coefficients in
$\mathbf{B}$ and $\mathbf{C}$ to change to a value of 1, thereby
eliminating two multiplication operations.  As described in
Section~\ref{sec:parameter-reduction}, this transformation is also
formulated as a general series of matrix operations.

%%     StreamIt is a programming language specifically tailored to DSP
%% streaming applications. The user creates a graph composed of four
%% types of StreamIt constructs: \textit{filters},
%% \textit{pipelines}, \textit{splitjoins}, and \textit{feedback
%% loops}. Filters encapsulate the computation done within an
%% application - they represent the blocks mentioned in the previous
%% section. Each filter operates on a one-dimensional `tape' of
%% values (of any type, including structures and arrays).  The other
%% three constructs dictate the type of connections possible between
%% filters. Every construct explicitly states its input type and
%% output type, and can be passed parameters as would be to a
%% procedure.

%%     StreamIt uses a buffer between every pair of filters to
%% hold values. When the input buffer of a construct (equivalent to
%% the output buffer of the previous construct) is appropriately
%% filled, the construct can execute. Execution involves three steps:
%% reading and removing items from the input buffer (consumption);
%% performing computations; putting items in the output buffer
%% (production). We will not consider the intricacies of managing
%% these buffers, and instead refer to the more abstract notion of a
%% tape.

%%     A filter has pre-defined \textit{peek}, \textit{pop}, and
%% \textit{push} rates (StreamIt code examples are given below).
%% During each execution, the filter accesses a maximum of peek
%% values from its input tape, consumes exactly pop input values from
%% its input tape, and produces exactly push values onto its output
%% tape. Since the removal of an input value is technically an access
%% of that input, the peek rate of a filter must be greater than or
%% equal to the pop rate of that filter. The push or pop rate can be
%% zero - the former corresponds to a filter that consumes items but
%% does not produce them (typically the last filter in a sequence)
%% and the latter corresponds to a filter that produces items but
%% does not consume them (typically the first filter in a sequence).
%% All the accesses, outputs, and removals, as well as all the
%% computation is done inside the main body of the filter, known as
%% the work function.

%% \begin{figure}[bthp]
%%   \centering
%%   \includegraphics[width=3.0in]{figures/filter.eps}
%%   \caption{StreamIt filter}
%%   \label{fig:filter}
%% \end{figure}

%%     StreamIt also supports a \textit{prework} function, which has its own push,
%% pop, and peek rates.  The prework function executes in place of
%% the work function for the first computation sequence, and is never
%% run again. Additionally, there is an \textit{init} function which
%% is run only once upon creation of the filter, and is usually used
%% to initialize variables.  The init and prework functions are both
%% optional.

%%         A filter can store two types of variables - \textit{field} and
%% \textit{local}. Field variables are declared outside of the
%% specific functions (work, prework, init), and can be accessed from
%% anywhere within the filter. Local variables are declared within a
%% specific function, and only have scope within that function. For
%% example, a variable declared within the init function is local,
%% and could not be accessed within the work function. Therefore, the
%% init function is used to initialize field variables.

%% Code examples of StreamIt filters are shown below.

%% \begin{scriptsize}
%% \begin{singlespace}
%% \begin{verbatim}
%% // This filter adds the parameter scalar to each input.
%% // It does not have an init or prework function
%% float -> float filter scalarAdd(float scalar) {
%%   work push 1 pop 1 peek 1 {
%%     push(scalar + pop());
%%   }
%% }
%% \end{verbatim}
%% \end{singlespace}
%% \end{scriptsize}

%% \begin{scriptsize}
%% \begin{singlespace}
%% \begin{verbatim}
%% // This filter outputs a running average of every three consecutive inputs.
%% // The first time it runs, it ouputs the average of the first two inputs without removing anything from the tape.
%% // It does not have an init function.
%% float -> float filter threeWayAverage() {
%%   prework push 1 pop 0 peek 2 {
%%     float temp;  // example of a local variable
%%     temp = (peek(0)+peek(1))/2;
%%     push(temp);
%%   }
%%   work push 1 pop 1 peek 3 {
%%     float temp;  // example of a local variable
%%     temp = (peek(0) + peek(1) + peek(2))/3
%%     push(temp);
%%     pop()
%%   }
%% }
%% \end{verbatim}
%% \end{singlespace}
%% \end{scriptsize}

%% \begin{scriptsize}
%% \begin{singlespace}
%% \begin{verbatim}
%% // This filter computes an infinite impulse response function.
%% // It does not have a prework function.
%% float->float filter IIR() {
%%     float curr;  // example of a field variable
%%     init {
%%       curr = 0;
%%     }
%%     work push 1 pop 1 peek 3 {
%%       float temp;  \\ example of a local variable
%%       temp = (peek(0) + peek(1) + peek(2))/6;
%%       curr = temp + curr/2;
%%       push(curr);
%%       pop();
%%     }
%% }
%% \end{verbatim}
%% \end{singlespace}
%% \end{scriptsize}

%%     Pipelines, splitjoins, and feedback loops are higher level
%% constructs created from filters. Each structures the layout of its
%% filters in a certain format. Even though these three constructs do
%% not directly provide the syntax to perform computations and work
%% from an input or output tape, they can be thought of as filters in
%% the following way: the construct recieves inputs which are passed
%% to one or more of the filters; all the filters perform
%% computations and pass values to one another through their input
%% and output tapes; the construct outputs values from one or more of
%% its filters. In fact, for every pipeline, splitjoin, and feedback
%% loop there is an equivalent filter representation. Therefore,
%% these three constructs are not strictly necessary for writing a
%% StreamIt program. However, they simplify and structure writing a
%% large application.

%%     The higher level constructs are not limited to combine filters -
%% they can also combine each other. This follows directly from the
%% fact that a higher level construct has some equivalent filter.
%% Therefore, if a pipeline can be composed of filters, it can also
%% be composed of pipelines, splitjoins, and feedback loops, which
%% are all like filters. We shall refer to all four StreamIt
%% constructs generically as blocks. This corresponds to the fact
%% that any StreamIt construct behaves as a block: it takes inputs,
%% performs calculations, and produces outputs.

%%     Pipelines combine a set of blocks in sequential fashion, so that
%% the output of the first block is the input to the second block,
%% the output of the second block is the input to the third block,
%% etc. The blocks are placed in order using the add statement.

%% \begin{figure}[bthp]
%%   \centering
%%   \includegraphics[width=3.0in]{figures/pipeline.eps}
%%   \caption{StreamIt pipeline}
%%   \label{fig:pipeline}
%% \end{figure}

%% \begin{scriptsize}
%% \begin{singlespace}
%% \begin{verbatim}
%% // This pipeline connects the filters scalarAdd and threeWayAverage.
%% // The parameter scalar passed to this pipeline is passed to the
%% // filter scalarAdd.
%% float -> float pipeline combinedWork(float scalar) {
%%   add scalarAdd(scalar);
%%   add threeWayAverage();
%% }
%% \end{verbatim}
%% \end{singlespace}
%% \end{scriptsize}

%%     A splitjoin arranges blocks in a parallel fashion.  The inputs to
%% a splitjoin are sent to each block in a \textit{roundrobin} or
%% \textit{duplicate} manner, and the outputs of each block are
%% joined in a roundrobin manner. Duplicate splitting means the
%% inputs to the splitjoin are copied and sent to each block, so that
%% each block receives exactly the same set of inputs.  Roundrobin
%% splitting means the inputs to the splitjoin are sent to each block
%% according to user defined weights.  For example, the first block
%% receives two inputs, the second block receives one input, the
%% third block receives two inputs.  Therefore, each block sees a
%% different set of inputs. Roundrobin joining (the only type of
%% joining permitted) means the outputs of each block are combined
%% according to user defined weights, and these represent the outputs
%% of the entire splitjoin. Blocks are listed in the order which they
%% recieve inputs using add statements. The way inputs are sent is
%% determined by using the split statement before the block list, and
%% the way outputs are recieved is determined by using the join
%% statement after the block list.

%% \begin{figure}[bthp]
%%   \centering
%%   \includegraphics[width=3.0in]{figures/splitjoin.eps}
%%   \caption{StreamIt splitjoin}
%%   \label{fig:splitjoin}
%% \end{figure}

%% \begin{scriptsize}
%% \begin{singlespace}
%% \begin{verbatim}
%% // This splitjoin splits its inputs three ways.
%% // The first two inputs are sent to the first block, the next
%% // input to the second block, and the next two inputs to the third
%% // block.
%% // The outputs are collected in the following manner: three from
%% //the first block, five from the second block, and four from the
%% // third block.
%% // For every 2+1+2=5 values inputted, 3+5+4=12 values are
%% // outputted.
%% float -> float splitjoin mySplitjoin() {
%%  split roundrobin(2,1,2);
%%   add combinedWork(3.5);
%%   add combinedWork(4.5);
%%   add threeWayAverage();
%% join roundrobin(3,5,4);
%% }
%% \end{verbatim}
%% \end{singlespace}
%% \end{scriptsize}

%%     A feedback loop uses some of its output as
%% an input. It consists of a body block and a loop block. The input
%% to the entire feedback loop is combined with the output of the
%% loop block and sent to the body block, via a roundrobin joiner.
%% The output of the body block is split two ways in a roundrobin or
%% duplicate manner.  The first set of outputs is used as the output
%% of the entire feedback loop, and the second set of outputs is used
%% as the input to the loop block. Note that there must be initial
%% values enqueued on the output tape of the loop block in order for
%% the feedback loop to begin executing. The first statement in a
%% feedback loop is a join, determining how inputs are sent to the
%% body block. The body and loop blocks are listed next. The last
%% statement is a split, determining where outputs are sent from the
%% loop block.

%% \begin{figure}[bthp]
%%   \centering
%%   \includegraphics[width=3.0in]{figures/feedback.eps}
%%   \caption{StreamIt feedback loop}
%%   \label{fig:feedback}
%% \end{figure}

%% \begin{scriptsize}
%% \begin{singlespace}
%% \begin{verbatim}
%% // This is a feedback loop implementation of the IIR filter.
%% // The body and loop are both anonymous filters.
%% float -> float feedbackloop IIRFeedback() {
%%   join roundrobin(3,1);
%%   body float->float filter {
%%     work push 1 pop 1 peek 4 {
%%       push((peek(0)+peek(1)+peek(2))/6 + peek(3)/2);
%%       pop();
%%     }
%%   };
%%   loop float->float filter {
%%     work push 1 pop 1 peek 1 {
%%       push(pop());
%%     }
%%   };
%%   split duplicate();
%%   enqueue(0.0);
%% }
%% \end{verbatim}
%% \end{singlespace}
%% \end{scriptsize}

%%     To run a program, the StreamIt compiler finds a
%% steady-state schedule of the number of times to execute each
%% filter \cite{Karczmarek}. If such a schedule cannot be found, the
%% user created block diagram is ill-formed and could not represent a
%% real world application.

%% \mysubsection{Block Representations}

%%     The execution of a block (StreamIt or otherwise) can by
%% characterized by a single equation if the block is linear, and a
%% pair of equations if the block is state space linear. We describe
%% these terms in detail below.

%% \mysubsubsection{Linear Representations}

%%     A block is termed linear if its outputs are a linear
%% combination of its inputs plus a set of constants. In mathematical
%% terms, this relationship can be modelled by the equation
%% $\vc{\mathbf{y}} = \mathbf{D}\vc{\mathbf{u}} +
%% \vc{\mathbf{b}}$, where $\vc{\mathbf{u}}$ is a column vector
%% representing the inputs, $\mathbf{D}$ is a matrix representing the
%% weights applied to each input, $\vc{\mathbf{b}}$ is a column
%% vector representing constants added to the inputs, and
%% $\vc{\mathbf{y}}$ is a column vector representing the outputs.

%%     Suppose we have the following linear model:
%% \starteqnstar
%% \vc{\mathbf{y}} = \left [ \begin{array} {cc} 1 & 2 \\ 3 & 4 \\
%% 5 & 6 \end{array} \right ] \vc{\mathbf{u}} + \left [
%% \begin{array} {c} 7
%% \\ 8 \\ 9 \end{array}\right ]
%% \doneeqnstar

%%     It is exactly described by the following StreamIt filter:
%% \begin{scriptsize}
%% \begin{singlespace}
%% \begin{verbatim}
%% int -> int filter linearFilter() {
%%   work push 3 pop 2 peek 2 {
%%     push(1*peek(0) + 2*peek(1) + 7);
%%     push(3*peek(0) + 4*peek(1) + 8);
%%     push(5*peek(0) + 6*peek(1) + 9);
%%     pop(); pop();
%%   }
%% }
%% \end{verbatim}
%% \end{singlespace}
%% \end{scriptsize}

%%     A process for analyzing and optimizing linear StreamIt filters
%% is described in \cite{Lamb}.
