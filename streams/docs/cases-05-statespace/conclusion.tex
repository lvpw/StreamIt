\mysection{Conclusion}
\label{sec:conclusion}

As embedded applications come to support more and more functionality,
the software will inevitably become more complex, and it will soon be
unmanageable to satisfy tight resource constraints via manual tuning
of low-level DSP code.  In order to replace the signal processing
expert in the design flow, compilers need to incorporate
domain-specific knowledge and have a clean, unified framework for
representing and optimizing the application.  This paper presents one
such framework, which is based on linear state space systems.  Using a
state space representation, we develop two novel optimizations for
stream programs: state removal and parameter reduction.  To
effectively apply these optimizations, we develop a general framework
for extracting, expanding, and combining state space representations.
An implementation of the framework within the StreamIt compiler
demonstrates speedups and increased generality over plain linear
optimizations.

%A large class of applications can be described using a
%linear state space model; in particular, the model subsumes a linear
%model that was developed previously~\cite{Lamb}.  

%%     Due to the infinite number of possible state space transforms,
%% the optimizations discussed are not necessarily ideal.
%% Additionally, parts of DSP applications are non-linear and cannot
%% be analyzed in the state space domain. Therefore, the work
%% presented in this thesis does not fully optimize some portions of
%% DSP applications, and does not apply towards other portions.
%% However, it does represent an additional step towards the goal of
%% a full analysis and optimization of any application. We outline
%% some of the future steps that can be taken, both to improve on the
%% work in this thesis and to expand it to other types of
%% domain-specific analyses and optimizations.
%% \begin{itemize}

%% \vspace{\itemshrink} \item As mentioned in Section 4, minimally parameterize a system,
%% then uses multiple execution stages.

%% \vspace{\itemshrink} \item Use a balanced representation \cite{Moore} to quantify the
%% relative impact of each state of a filter on its execution. Then
%% the states that have impact values below a certain threshold can
%% be removed, resulting in only a small change in the filter's
%% execution.

%% \vspace{\itemshrink} \item Formulate loops in traditional programming languages as
%% state space filters, and use state space work developed in this
%% thesis to detect their induction variables and optimize their
%% execution.

%% \vspace{\itemshrink} \item Create a cost function metric,
%% $f(\mathbf{A},\mathbf{B},\mathbf{C},\mathbf{D})$, that balances
%% the traditional program analysis metrics (throughput, power
%% consumption, memory allocation, etc.) in any manner desired. Then
%% find a general way to minimize this cost function over all
%% possible state space transformations $\mathbf{T}$.

%% \vspace{\itemshrink} \item Formulate a methodology to deal with filters whose outputs
%% are a linear combination of their inputs but a non-linear
%% combination of their state variables.

%% \vspace{\itemshrink} \item Use a `black box' method to find the appropriate
%% representation of a filter. In this approach the filter is given
%% inputs and the output data is collected. The input/output
%% relations are used to formulate an appropriate state space model
%% that may not exactly represent the filter, but does so within a
%% tolerable error margin (see \cite{Schutter}).
%% \vspace{\itemshrink} \end{itemize}
