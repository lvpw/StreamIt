To ask reservoir
----------------

- why does the reference VM allocate VM_WORD for element size instead
of bytes?  should we change all language for "bytes" to "words" and
introduce it into the svm description?  otherwise you might have
alignment problems.  (maybe I'm confused exactly what a "byte" means.
Does it mean a word, or does it mean 8 bits?)

  - also, shouldn't it clear it's memory?  and why does it allocate a
   word for every single thing it pushes?  it should be copied by the
   svm_push.

- note inconsistency in Move: if a given number of items are
specified, what happens if EOS encountered in flight?  The EOS tag is
transferred?  I'm assuming yes.

- should we remove bool's in favor of ints?

- did I add size_t correctly?
  - do you think size_t needs to be explained in the document?
  - why do you have an "int index" argument to blockRead / blockWrite instead of size_t?
  - also the length on pre-defined kernel move?

- I added n argument as FIRST one of pushMulticast, waitMultiple.  Is
that correct?

- the reference implementation of strided scatter requires that the
length is a multiple of the stride size, which is not specified by the
implementation.

- the reference implementation of strided gather has two problems: 1)
as with scatter, it assumes that length is a multiple of the stride
size.  but more seriously, 2) it counts items that are passed over
(not copied within a stride) as being part of the length, where the
specification intends to only count items written to the output stream
as part of the length (for symmetry with scatter).

- to simplify spec, saying that "length" in predefined kernels is > 0
if it's not ALL.

- added requires clauses for all predefined scatter/gather to stay
within the bounds of their blocks.

- in the reference implementation for indexed scatter/gather, why does
the length have to be sizetype?  It could actually be larger than
sizetype, as you could have an index repeated in multiple locations of
the index stream.  is this a concern?

- in indexed scatter/gather, there is an unpacking issue since the
generic function doesn't know the type of the index stream.  i
required the types of elementsize to be unsigned.  Should we further
require it the element size to be a word?  what do most DMA engines
allow?

- added to requires clause: for pre-defined kernels, the elementSize
of the source and destinations has to be the same

- should we require that elementsPerStride <= destStride in the
strided kernels?  Can any DMA return overlapping strides?

Extra Todo:
-----------

x add size_t where it appears in svm.c

  size_t is the unsigned integral type of the result of the sizeof
  operator.  it represents the size of the largest data object you can
  declare.  Almost certainly it is either unsigned int or unsigned long.
  It is the safest type to represent any integer data object you use s
  an array subscirpt.  subscript arithmetic will never overflow.

  size_t is defined in stddef.h, which is intrinsicly included in stdio
  or stdlib.

x add n at front of pushMulticast, waitMultiple

From Dennis 1/04:
-----------------

x page 4, Physical Entities, third bullet: Add "and controls" to the
  end of the paragraph.

x p6, streamInitRAM: In the second paragraph,
  "svm_Stream_Unaliased_RAM" is in the wrong font.

x p6, streamInitWithDataRAM: The parameter description for initEOS
  should describe the position of the initial item not at "initLength"
  but at "address + initLength - 1".

   --> The location in memory that is tagged would actually start at
       elementSize*(initLength-1) + address.  But I think this is
       complicating the description, because really it is the whole
       item that is conceptually tagged.

       However, I see the off-by-one confusion; will change to read as
       follows:

       "whether or not the initial item at position initLength-1
       should be tagged with an EOS tag.  That is, indicates the
       initial value of streamPeekEOS(s, initLength-1)."

x p7, streamInitFIFO: The first word in the Requires section should be
  "fifoLocation" rather than "ramLocation".

x p7, svm_Stream_Unordered: The restriction that peek can't be used if
  this flag is set also means that you can't use EOS with this stream,
  since peek is the only way you can look at the EOS flag.  Though
  sort of obvious, I think this point is important enough to state
  explicitly here.

   --> addressing by adjusting the requires clauses of streamPeek and
       streamPeekEOS to read:

   if {\tt n} $>$ 0, then {\tt svm\_Stream\_Unordered} flag has NOT been set.

   So, you can still use EOS on unordered streams, you just can't look ahead.

x p13/14, kernelRunMultiplexed: The phrase "N iterations" is used, but
  the term "iteration" is not defined.  From the outside, a kernel
  runs until finished.  Is there a call to use from within a kernel to
  indicate that it has come to a possible yield point?

   --> added explanation, with citation to appendix for precision

x p20, StridedScatter: The last phrase in the first paragraph, "in
  which case the elements moved appear at the beginning of each
  stride", doesn't make sense to me.  The same phrase is used in the
  StridedGather description on the next page.

    --> there are many things that are unclear when expressed with
        text, so I added an appendix with reference code for each
        predefined kernel.  This is long overdue.

x p20/21, IndexedScatter and IndexedGather: What happens if there are
  not enough elements in the source to account for all the index
  entries?  What if there are too many?  Should this document specify
  what happens in those cases?

   --> there is no such thing as an end of the stream in this sense.
    but this does make sense when blocks are in question, for which I
    added some requires clauses.

x p21: There are minor formatting problems after the parameters
  IndexedScatter/indexStr (a blank line) and IndexedGather/length (a
  strange line break).

x p23: In the example, I spent a little time looking for the
  definition of RLE and Zip typenames.  These are apparently either
  black box kernels or user kernels for which this example doesn't
  have the code.  A comment on the two variable declaration lines
  would save some confusion.

x p25, Managing Kernel Instruction Memory: The term "IMEM" is not
  defined; replace it with "the processor's instruction memory".

x p26, Error Handling, last line: change "was" to "were" -- it's
  future perfect tense.

x p28, third line: Change "consuming the EOS" to "consuming all data
  elements in the FIFO".  There may not be an EOS.

=============================================================================

big things
----------

x can only alias blocks
x only have stream interface to things

new notes from peter
--------------------

x first summary paragraph of 1.2.1 (stream control api) should be rewritten

x should come back to network model

pending
-------

minor:

x still there is the issue of whether or not multiple kernels can run
on a resource at the same time

optional:
x should convert everything to pseudocode and move to appendix
x Peter will send me some initial stuff for 5

x note that when you call a method with something that's not it's
type, it finds constructor taking arg

from me
-------

x think about how to remove the speaker from the final example

from saman
----------
x not clear what in order, out of order, random access means

from peter next day
-------------------

x have blocks, stream buffers
x still ordered, unorderd, just plain block
x is aliased = YES, has nonZeroStart = YES
x poke is gone

from peter
----------

x "architecture independent" is wrong name for pre-defined kernels

x get rid of one-graph-per kernel restriction

x for the totalLength, length thing, should have length of 0 before
you run even with random access

x it is fine to include send/receive in same graph, bridging across a
processor-processor connection

x you can execute as many predefined kernels on a processor as you
want -- instead of having optional location for copy, etc.

x class hierarchy graph, should make it clear there are three triangles

x on push and pop, move the if statement up above the modifier
  x bill should check that

x instead of "output tape" say "output stream" in canPush, etc.

x on dynamic rates, add a max value that is ALL by default

x kernel restrictions, need one more restriction: (after the section
heading) kernels may only call functions that also meet these
restrictions

x for StreamBuffer.getLength: should be just "Returns the number of
live items in this buffer" [pseudocode is wrong, and can move to
appendix]

x reset should not call reset on child streams

x finish(), should be terminate() instead

x can't interact with running kernel!
  - run() defined suspended, unstarted
  - finish() defined suspended, unstarted, finished
  - reset suspended, unstarted, finished

x iters has to be >= 1, and before it calls any work function, it
guarantees that it calls preWork on that kernel.

x at most one USER-DEFINED kernel can be assigned to a processor 

x concatanate constraints 5 & 6.  addresses and sizes within memory
nodes ... are also resources.  Say "This includes the addresses and
size arguments to stream"

x swap the order of 5.2.4 and 5.2.5

x scatter/gather, should have randomaccess ostream
  x should have numberOfRecords instead of record size

x copy: just does whole stream

x stridedScatter, stridedGather

x indexedScatter, indexedGather

come back to:
x postwork
x larger issue: the business of buffering data to/from i/o devices
  x how to deal with  suspension in the middle of a network operation.
  x postWork, finished, don't know what's going on
x simplifying the list of restrictions on stream control

later
-----

x add special constructors for initializing fields of totalLength,
end, start... er, how do you deal with reset in this case?  just
dealing with length, totalLength returning capacity for a copy kernel.

x decide what processor resource copy operations should execute on

x think about graphs that contain kernels spread out across multiple
processors

----------------

* Kernels are executable as individuals -- a kernel instance is
analagous to a remote function call on a kernel processor.

* Private kernel members are stored by the kernel processor. They are
not sent to the kernel when it starts, and are discarded when the kernel
is finished. For this reason, kernels cannot access private members or
methods in their constructors nor can the user define new public kernel
methods.

* kernels have a property status, which can be UNSTARTED, RUNNING,
SUSPENDED, or FINISHED.

* preWork and postWork return a new status, which can be RUNNING,
SUSPENDED, or FINISHED.

* kernels have public methods: run(), getStatus(), wait(), and
terminate()

* run() takes a variable length list of kernels the kernel depends on.
run(dependencies...) does the following:

As far as the control thread is concerned:
 Pack up the values of all public properties of the kernel and its
dependencies, send them to the kernel  Set the status as seen by the
control thread to RUNNING

As far as the kernel is concerned:
        Wait until status of every kernel in dependencies is FINISHED
        Unpack the values of all public properties of the kernel
        Do the following with the kernel:
        If (status == UNSTARTED) {
                status = prework();
        } else if (status == SUSPENDED) {
                status = RUNNING;
        }
        While (status == RUNNING) {
                status = work();
        }
        If (status == FINISHED) {
                postwork();
        }
        Pack up the "real values" of the kernel properities and status,
send them to the control thread

Notice that the kernel needs to internally call canPush() and canPop()
if the HLC has not guaranteed that those will return.

* getStatus() returns status of a kernel as seen by the control thread.

* wait() waits for and then unpacks all public properties and status of
the kernel produced by the last call to run().

* terminate() is a best-effort way to kill a kernel. No properties are
updated, nor is there any guarantee about at what point the kernel
stops. The kernel's status is set to FINISHED.

* A FINISHED kernel cannot be run.

* At any given time, only kernel may be writing or reading a stream
buffer unless said kernels are part of a graph. The length and
totalLength of such a buffer is updated when that kernel's properties
are updated.

* Graphs serve to join kernels which concurrently share stream buffers
for synchronization of those buffers by the low-level compiler, and have
no other purpose.

* Graphs have a constructor which takes a list of kernels (as per now),
but no methods.

* Kernels added to a graph must be UNSTARTED. A kernel can be added to
at most one graph, and if it is added to a graph on any control path
then it must be added to that graph along all control paths.

* Within a graph, a stream buffer may have only one writer and one
reader. The totalLength of such a buffer is updated whenever either the
writer's or reader's public properties are updated (the length is not
guaranteed to match reality until both are finished.)

metadata
--------

- do I need to define the actual API for accessing metadata stuff

- work out metadata description for Raw

- look at scalar operand networks for network characterization stuff

