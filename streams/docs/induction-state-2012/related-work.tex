\section{Related Work}


These capabilities enable a programmer to write an application and its
filters at a natural granularity that is independent of
parallelization considerations enabling portable, reusable, and
malleable code.  Furthermore, fine-grained implementations of filters
enables the compiler to perform guided filter fusion that balances
data and instruction cache behavior~\cite{sermulins-lctes05}.


Need to address the coarsening issue.  Brook, which disallows state
would force the user to just coarsen the filter.  Why wouldn't someone
just coarsen?  


One could write the induction filters given above at a more coarse granularity
such that the filter is pushing and popping ???? number of items.
Since the period of the filter is known at compile-time, though
parameterized, the push and pop rate could be equal to the period and
[explain how to coarsen].  This approach, however, is inferior because
of the following:

* The programmer grasped the algorithm and implemented the application
at the fine granularity.  A language should constrain the programmer
as little as possible for the sake of performance.

* The coarse-granularity implementation requires larger input and
output buffers to implement because of the larger push and pop rates.
Larger buffers occupy more of the cache and could evict filter data or
instructions are needed during execution.  Thus there could be more
access to longer latency memory hierarchies.

* Larger input and output rates also interact with the steady-state
scheduling algorithm.  Since the scheduling algorithm is performing
many cascading LCMs, a single filter with large input and output rates
will increase the multiplies of all filters of the application,
requiring more buffering and increasing latency.