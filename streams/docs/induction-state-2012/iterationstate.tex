\section{Induction Variable State}
\label{sec:inductionstate}

% \begin{figure}[t]
% {\eightpoint
% \begin{verbatim}
%   int->int stateful filter InductionFilter() {
%       int counter;
%       int max;
  
%       work push 1 pop 1{

%           ...

%           counter = (counter + 1);

%           if (counter > max) {
%               counter = 0;
%           } 
%       }
%   }
% \end{verbatim}
% \caption{Example of a stateful StreamIt filter using induction variable state.\protect\label{fig:filter-example}}}
% \end{figure}


Traditional induction variables encapsulate all variables that are
increased or decreased with iterations of a loop.  Induction variable
state as applied to stream programming is a class of state that
requires keeping count of how often a filter has been invoked.  Common
usage of induction variable state include performing some special
action after a certain number of iterations and keeping track of array
index positions.  Many filters maintain multiple induction variables
as well, which may be either dependent or independent of each other.

As is most commonly used now, induction variable state is maintained
by creating a mutable state field in the corresponding filter.  This
state can be set to the desired starting value.  The induction
variable is consistently updated at some point during the work call.
For many use cases, this induction variable may need to be reset if it
reaches a certain threshold. 

Figure~\ref{fig:apt-pipeline} illustrates a common pattern of explicit
induction variable state.  The implementation of the filter maintains
a filter variable {\tt frameno} (line 10) that is incremented on each call of
the {\tt AssignPictureType}'s work function.  This variable
represents state.  The {\tt framecount} variable (line 23) is derived
from this state and used in control flow.

As presently constructed, induction variable state for\-ces the
corresponding filter to be run in sequential order.  In providing a
mutable state whose value is dependent on the previous execution step,
it is necessary to run a filter execution step and establish the
induction variable value before moving on to the next execution step.
The tradition fission transformation would not be able to parallelize
this filter without understanding how to properly distribute the
calculation of the state.  As we mention in the introduction, this
could be accomplished using an automatic induction variable
recognizer, but its idiomatic nature may miss many opportunities for
parallelization.  This motivates our iteration keyword solution
introduced in the next section.
