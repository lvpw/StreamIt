Stream programs represent an important class of high-performance
computations. DeÔ¨Åned by their regular processing of sequences of data,
stream programs appear most commonly in the context of audio, video,
and digital signal processing, though also in networking, encryption,
and other area. The key to effectively parallelizing stream programs
is to take advantage of data parallelism present in filters that do
not maintain state.  One form of state that is common in streaming
applications is induction variable state.  An example of which is a
filter that maintains a counter of the number of times it has
executed, and performs behavior dependent on this state.  Examples of
filters with induction variable state can be found in applications
such as MPEG2 encoding, beamforming, FIR filtering, and doppler radar.
Filters with induction variable state in these applications represent
a bottleneck to scalable parallelization of these applications.

This paper demonstrates that it is essential to recognize and
parallelize filters with induction variable state to enable scalable
parallelization of many real-world streaming applications.  To make
such state explicit, we define a new language construct that
automatically returns the current iteration number of a given filter,
and we provide a desugaring for the construct.  We argue that using this
construct improves programmer productivity.  Furthermore, we augment
the StreamIt programming language to support this construct, and
present modifications to the fundamental filter fission
parallelization transformation for filters that employ the new
iteration idiom.  The necessity of parallelizing induction variable
state is demonstrated by a case study of the motion estimation stage
of MPEG2 encoding.
 % With multicore architectures becoming more prominent in computing
% systems, there is a growing need to adapt programs to use these
% available resources.  Stream programming is a programming 
% paradigm that can yield high-performance programs by effectively
% mapping computations across many cores.  Such programs are naturally
% expressible as graphs of independently executing filters communicating 
% over data channels.  

% Even with such inherent parallelism in this paradigm, data parallelism
% may be inhibited in filters due largely to how they are written.  
% Most commonly, filters may be "`stateful"', meaning they retain mutable 
% state between filter execution.  Such filters must be executed in a 
% serial fashion and cannot be replicated and run in parallel in order
% to maintain correctness.  A common category of filter state is that of 
% induction state.  Such state keeps track of how often the filter has 
% been invoked, allowing it to perform some special action at certain 
% iterations.  

% In this work, we attempt to eliminate such throughput bottlenecks on 
% data parallelism that may be caused by induction state usage.  This 
% process uses an internal induction variable and provides slight 
% modifications to filter fission, a transformation that increases the 
% granularity of stream graphs to improve parallelism in the stream program.

% The proposed modifications to filter fission are implemented in the 
% StreamIt language.  StreamIt Users can improve data parallelism on 
% filters that use induction variables by modifying common induction 
% variable patterns to use the added StreamIt language features. 


% ------
