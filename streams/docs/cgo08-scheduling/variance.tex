\section{Tolerating Variance With Static Schedules}

A particular challenge that a static scheduler faces is posed by the
work estimation $W_X$ required for an actor $X$. An efficient static
schedules requires an effective work estimation methodology. Previous
work in feedback directed optimizations has shown that profiling is a
practical approach to characterizing applications. There are numerous
examples of profiling used for various compiler optimizations such as
inlining, unrolling, data prefetching, trace formation, etc. And prior
related work on scheduling of stream graphs has shown that good static
estimation of work is
feasible~\cite{mgordon-asplos04,mgordon-asplos06}.

In the case of the patterns shown in the previous section, variance in
the expected work duration of an actor can lower utilization and
throughput when actors communicate across processor
boundaries. Inter-processor communication requires a shared buffer
where data is stored by the producing actors. If the buffer is full
and the producing actors get ahead of the consumers, they cannot write
to the buffer and hence they will block; similarly if the producers
are slow and the comsumers are fast because of work firing variance.

However, it possible to compensate for the variance by simply creating
extra {\it slack} between the two processors. Slack is essentially
allowing the shared buffer to be larger than the size mandated by the
schedule. As the slack increases, or in other words, the maximum
allowed buffer size is increased, the static schedule becomes more
resillient to variance and can maintain high utilization and sustain
throughput.

We emperically tested and observed this phenomena using both
simulations of the patterns and through actual implementations and
measurements on a Cell processor.