


// ############### Pass2_Types.str ###############
struct Vector3f
{
        float x;
        float y;
        float z;
}

struct Vector4f
{
        float x;
        float y;
        float z;
        float w;
}

struct Vertex
{
	Vector4f position;
}

struct Fragment
{
    int x;
    int y;
    float z;
}

struct TriangleSetupInfo
{
    // screen bounding box
    int minX;
    int minY;
    int maxX;
    int maxY;

    // triangle edge equations
    Vector3f edge01;
    Vector3f edge12;
    Vector3f edge20;

    // Special interpolants
    Vector3f wInterp;
    Vector3f zInterp;
}

struct Matrix3f
{
        float[9] m;
}

struct Matrix4f
{
        float[16] m;
}

struct BoundingBox2i
{
        int minX;
        int maxX;

        int minY;
        int maxY;
}



// ############### Pass2_TopLevelPipeline.str ###############
TriangleSetupInfo->void pipeline PixelPipeline( int offset, int numRasterizers,
						int screenWidth, int screenHeight )
{
    add Rasterizer( offset, numRasterizers, screenWidth, screenHeight );
    add RasterOps( offset, numRasterizers, screenWidth, screenHeight );
}

// float->float splitjoin FrontendSplitJoin
Vertex->Vertex splitjoin FrontendSplitJoin
{
    split roundrobin;

    add VertexShader( 0 );
/*
    add VertexShader( 1 );
    add VertexShader( 2 );
    add VertexShader( 3 );
    add VertexShader( 4 );
    add VertexShader( 5 );
*/

    join roundrobin;
}

TriangleSetupInfo->void splitjoin BackendSplit
{
    split duplicate;

    add PixelPipeline( 0, 1, 600, 600 );
/*
    add PixelPipeline( 0, 4, 600, 600 );
    add PixelPipeline( 1, 4, 600, 600 );
    add PixelPipeline( 2, 4, 600, 600 );
    add PixelPipeline( 3, 4, 600, 600 );
*/
    join roundrobin( 0 );
}

void->void pipeline Pass2
{
	add FileReader< float >( "shadow_triangle.bin" );
	add Input( 36 );
	add FrontendSplitJoin();
	add TriangleSetup( 600, 600 );
	add BackendSplit();
}



// ############### Pass2_Input.str ###############
float->Vertex filter Input( int vertexDataSize )
{
    int i;

    work pop 3 push 1
	{
	    Vertex v;

	    v.position.x = pop();
	    v.position.y = pop();
	    v.position.z = pop();
	    v.position.w = 1.0;

	    print( "i = " + i );

	    i = i + 3;
	    push( v );
	}
}



// ############### Pass2_VertexShader.str ###############
// Takes a Vertex in and "shades" it

Vertex->Vertex filter VertexShader( int id )
{
    Matrix4f modelView;
    Matrix4f projection;

    float worldX;
    float worldY;
    float worldZ;
    float worldW;

    float worldNX;
    float worldNY;
    float worldNZ;

    float eyeX;
    float eyeY;
    float eyeZ;
    float eyeW;

    float clipX;
    float clipY;
    float clipZ;
    float clipW;

    init
	{
	    // modelview matrix, identity for now
	    modelView.m[0] = 1;
	    modelView.m[1] = 0;
	    modelView.m[2] = 0;
	    modelView.m[3] = 0;

	    modelView.m[4] = 0;
	    modelView.m[5] = 1;
	    modelView.m[6] = 0;
	    modelView.m[7] = 0;

	    modelView.m[8] = 0;
	    modelView.m[9] = 0;
	    modelView.m[10] = 1;
	    modelView.m[11] = 0;

	    modelView.m[12] = 0;
	    modelView.m[13] = 0;
	    modelView.m[14] = -5;
	    modelView.m[15] = 1;

	    // normal matrix is just top-left 3x3 ^-T, doesn't matter which order you do it in

	    // nominal projection matrix
	    // fov = 50 degrees, 1:1 aspect ratio, near = 1, far = 10
	    // gluPerspective( 50, 1, 1, 10 );
	    projection.m[0] = 2.144507;
	    projection.m[1] = 0;
	    projection.m[2] = 0;
	    projection.m[3] = 0;

	    projection.m[4] = 0;
	    projection.m[5] = 2.144507;
	    projection.m[6] = 0;
	    projection.m[7] = 0;

	    projection.m[8] = 0;
	    projection.m[9] = 0;
	    projection.m[10] = -1.022222;
	    projection.m[11] = -1;

	    projection.m[12] = 0;
	    projection.m[13] = 0;
	    projection.m[14] = -2.022222;
	    projection.m[15] = 0;
	}

    void computeEyeSpace()
	{
	    eyeX = modelView.m[0] * worldX + modelView.m[4] * worldY + modelView.m[8]  * worldZ + modelView.m[12] * worldW;
	    eyeY = modelView.m[1] * worldX + modelView.m[5] * worldY + modelView.m[9]  * worldZ + modelView.m[13] * worldW;
	    eyeZ = modelView.m[2] * worldX + modelView.m[6] * worldY + modelView.m[10] * worldZ + modelView.m[14] * worldW;
	    eyeW = modelView.m[3] * worldX + modelView.m[7] * worldY + modelView.m[11] * worldZ + modelView.m[15] * worldW;
	}

    void computeClipSpace()
	{
	    clipX = projection.m[0] * eyeX + projection.m[4] * eyeY + projection.m[8]  * eyeZ + projection.m[12] * eyeW;
	    clipY = projection.m[1] * eyeX + projection.m[5] * eyeY + projection.m[9]  * eyeZ + projection.m[13] * eyeW;
	    clipZ = projection.m[2] * eyeX + projection.m[6] * eyeY + projection.m[10] * eyeZ + projection.m[14] * eyeW;
	    clipW = projection.m[3] * eyeX + projection.m[7] * eyeY + projection.m[11] * eyeZ + projection.m[15] * eyeW;
	}

    work pop 1 push 1
	{
	    Vertex vIn = pop();

	    worldX = vIn.position.x;
	    worldY = vIn.position.y;
	    worldZ = vIn.position.z;
	    worldW = vIn.position.w;

	    // "ftransform()"
	    computeEyeSpace();
	    computeClipSpace();

	    Vertex vOut;

	    vOut.position.x = clipX;
	    vOut.position.y = clipY;
	    vOut.position.z = clipZ;
	    vOut.position.w = clipW;

	    push( vOut );
	}
}



// ############### Pass2_TriangleSetup.str ###############
Vertex->TriangleSetupInfo filter TriangleSetup( int screenWidth, int screenHeight )
{
    Vertex v0;
    Vertex v1;
    Vertex v2;

    TriangleSetupInfo tsi;

    Vector3f[3] ndcSpace;
    Vector3f[3] screenSpace;

    Matrix3f vertexMatrix;
    Matrix3f vertexMatrixInverse;

    Vector3f wCoefficients;

    // coefficients for z interpolation
    Vector3f zInterp;

    void normalizeW()
	{
	    ndcSpace[0].x = v0.position.x / v0.position.w;
	    ndcSpace[0].y = v0.position.y / v0.position.w;
	    ndcSpace[0].z = v0.position.z / v0.position.w;

	    ndcSpace[1].x = v1.position.x / v1.position.w;
	    ndcSpace[1].y = v1.position.y / v1.position.w;
	    ndcSpace[1].z = v1.position.z / v1.position.w;

	    ndcSpace[2].x = v2.position.x / v2.position.w;
	    ndcSpace[2].y = v2.position.y / v2.position.w;
	    ndcSpace[2].z = v2.position.z / v2.position.w;
	}

    void viewport()
	{
	    screenSpace[0].x = screenWidth * ( ndcSpace[0].x + 1.0 ) / 2.0;
	    screenSpace[0].y = screenHeight * ( ndcSpace[0].y + 1.0 ) / 2.0;
	    // shift z range from [-1..1] to [0..1]
	    screenSpace[0].z = ( ndcSpace[0].z + 1.0 ) / 2.0;

	    screenSpace[1].x = screenWidth * ( ndcSpace[1].x + 1.0 ) / 2.0;
	    screenSpace[1].y = screenHeight * ( ndcSpace[1].y + 1.0 ) / 2.0;
	    // shift z range from [-1..1] to [0..1]
	    screenSpace[1].z = ( ndcSpace[1].z + 1.0 ) / 2.0;

	    screenSpace[2].x = screenWidth * ( ndcSpace[2].x + 1.0 ) / 2.0;
	    screenSpace[2].y = screenHeight * ( ndcSpace[2].y + 1.0 ) / 2.0;
	    // shift z range from [-1..1] to [0..1]
	    screenSpace[2].z = ( ndcSpace[2].z + 1.0 ) / 2.0;
	}

    void computeScreenBoundingBox()
	{
	    int v0x, v0y, v1x, v1y, v2x, v2y;
	    int temp;

	    v0x = ( int )( screenSpace[0].x );
	    v0y = ( int )( screenSpace[0].y );
	    v1x = ( int )( screenSpace[1].x );
	    v1y = ( int )( screenSpace[1].y );
	    v2x = ( int )( screenSpace[2].x );
	    v2y = ( int )( screenSpace[2].y );

	    // sort vertices into top to bottom, left to right order

	    // x max
	    if( v0x > v1x )
		{
		    temp = v0x;
		}
	    else
		{
		    temp = v1x;
		}

	    if( v2x > temp )
		{
		    temp = v2x;
		}

	    tsi.maxX = temp + 1;

	    if( v0y > v1y )
		{
		    temp = v0y;
		}
	    else
		{
		    temp = v1y;
		}

	    if( v2y > temp )
		{
		    temp = v2y;
		}

	    tsi.maxY = temp + 1;

	    // x min
	    if( v0x < v1x )
		{
		    temp = v0x;
		}
	    else
		{
		    temp = v1x;
		}

	    if( v2x < temp )
		{
		    temp = v2x;
		}

	    tsi.minX = temp;

	    // y min
	    if( v0y < v1y )
		{
		    temp = v0y;
		}
	    else
		{
		    temp = v1y;
		}

	    if( v2y < temp )
		{
		    temp = v2y;
		}

	    tsi.minY = temp;

	    if( tsi.minX < 0 )
		{
		    tsi.minX = 0;
		}
	    if( tsi.maxX > ( screenWidth - 1 ) )
		{
		    tsi.maxX = screenWidth - 1;
		}

	    if( tsi.minY < 0 )
		{
		    tsi.minY = 0;
		}
	    if( tsi.maxY > ( screenHeight - 1 ) )
		{
		    tsi.maxY = screenHeight - 1;
		}
	}

    void computeVertexMatrix()
	{
	    vertexMatrix.m[0] = v0.position.x;
	    vertexMatrix.m[3] = v0.position.y;
	    vertexMatrix.m[6] = v0.position.w;

	    vertexMatrix.m[1] = v1.position.x;
	    vertexMatrix.m[4] = v1.position.y;
	    vertexMatrix.m[7] = v1.position.w;

	    vertexMatrix.m[2] = v2.position.x;
	    vertexMatrix.m[5] = v2.position.y;
	    vertexMatrix.m[8] = v2.position.w;
	}

    void computeVertexMatrixInverse()
	{
	    float d;

	    d = ( vertexMatrix.m[0] * vertexMatrix.m[4] * vertexMatrix.m[8] - vertexMatrix.m[0] * vertexMatrix.m[5] * vertexMatrix.m[7] - vertexMatrix.m[3] * vertexMatrix.m[1] * vertexMatrix.m[8] + vertexMatrix.m[3] * vertexMatrix.m[2] * vertexMatrix.m[7] + vertexMatrix.m[6] * vertexMatrix.m[1] * vertexMatrix.m[5] - vertexMatrix.m[6] * vertexMatrix.m[2] * vertexMatrix.m[4] );

	    vertexMatrixInverse.m[0] = ( vertexMatrix.m[4] * vertexMatrix.m[8] - vertexMatrix.m[5] * vertexMatrix.m[7] ) / d;
	    vertexMatrixInverse.m[3] = -( vertexMatrix.m[3] * vertexMatrix.m[8] - vertexMatrix.m[5] * vertexMatrix.m[6] ) / d;
	    vertexMatrixInverse.m[6] = -(-vertexMatrix.m[3] * vertexMatrix.m[7] + vertexMatrix.m[4] * vertexMatrix.m[6] ) / d;
	    vertexMatrixInverse.m[1] = -( vertexMatrix.m[1] * vertexMatrix.m[8] - vertexMatrix.m[2] * vertexMatrix.m[7] ) / d;
	    vertexMatrixInverse.m[4] = ( vertexMatrix.m[0] * vertexMatrix.m[8] - vertexMatrix.m[2] * vertexMatrix.m[6] ) / d;
	    vertexMatrixInverse.m[7] = -( vertexMatrix.m[0] * vertexMatrix.m[7] - vertexMatrix.m[1] * vertexMatrix.m[6] ) / d;
	    vertexMatrixInverse.m[2] = -(-vertexMatrix.m[1] * vertexMatrix.m[5] + vertexMatrix.m[2] * vertexMatrix.m[4] ) / d;
	    vertexMatrixInverse.m[5] = -( vertexMatrix.m[0] * vertexMatrix.m[5] - vertexMatrix.m[2] * vertexMatrix.m[3] ) / d;
	    vertexMatrixInverse.m[8] = ( vertexMatrix.m[0] * vertexMatrix.m[4] - vertexMatrix.m[1] * vertexMatrix.m[3] ) / d;
	}

    void computeEdgeEquations()
	{
	    // edge01 = vertexMatrixInverse * [0 0 1]^T
	    tsi.edge01.x = vertexMatrixInverse.m[6];
	    tsi.edge01.y = vertexMatrixInverse.m[7];
	    tsi.edge01.z = vertexMatrixInverse.m[8];

	    // edge12 = vertexMatrixInverse * [1 0 0]^T
	    tsi.edge12.x = vertexMatrixInverse.m[0];
	    tsi.edge12.y = vertexMatrixInverse.m[1];
	    tsi.edge12.z = vertexMatrixInverse.m[2];

	    // edge20 = vertexMatrixInverse * [0 1 0]^T
	    tsi.edge20.x = vertexMatrixInverse.m[3];
	    tsi.edge20.y = vertexMatrixInverse.m[4];
	    tsi.edge20.z = vertexMatrixInverse.m[5];
	}

    void computeWInterp()
	{
	    // w coefficients = vertexMatrixInverse * [ 1 1 1 ]^T
	    tsi.wInterp.x = vertexMatrixInverse.m[0] + vertexMatrixInverse.m[3] + vertexMatrixInverse.m[6];
	    tsi.wInterp.y = vertexMatrixInverse.m[1] + vertexMatrixInverse.m[4] + vertexMatrixInverse.m[7];
	    tsi.wInterp.z = vertexMatrixInverse.m[2] + vertexMatrixInverse.m[5] + vertexMatrixInverse.m[8];
	}


    void computeZInterp()
	{
	    tsi.zInterp.x = vertexMatrixInverse.m[0] * screenSpace[0].z + vertexMatrixInverse.m[3] * screenSpace[1].z + vertexMatrixInverse.m[6]  * screenSpace[2].z;
	    tsi.zInterp.y = vertexMatrixInverse.m[1] * screenSpace[0].z + vertexMatrixInverse.m[4] * screenSpace[1].z + vertexMatrixInverse.m[7]  * screenSpace[2].z;
	    tsi.zInterp.z = vertexMatrixInverse.m[2] * screenSpace[0].z + vertexMatrixInverse.m[5] * screenSpace[1].z + vertexMatrixInverse.m[8] * screenSpace[2].z;
	}

    work pop 3 push 1
	{
	    v0 = pop();
	    v1 = pop();
	    v2 = pop();

	    computeVertexMatrix();
	    computeVertexMatrixInverse();

	    normalizeW(); // clip space --> ndc space
	    viewport(); // ndc space --> screen space

	    computeScreenBoundingBox();
	    computeEdgeEquations();

	    // special interpolants
	    computeWInterp();
	    computeZInterp();

	    // push out
	    push( tsi );
	}
}



// ############### Pass2_Rasterizer.str ###############
TriangleSetupInfo->Fragment filter Rasterizer( int offset, int numUnits, int screenWidth, int screenHeight )
{
    int numColumns;
    TriangleSetupInfo tsi;

    init
	{
	    numColumns = screenWidth / numUnits;
	}

    // TODO: would like to pass in a struct
    float interpolate( float interpX, float interpY, float interpZ,
		       float ndcX, float ndcY, float w )
	{
	    return( ( interpX * ndcX + interpY * ndcY + interpZ ) * w );
	}

    work pop 1 push *
	{
	    tsi = pop();

	    // given an x coordinate:
	    // x / numUnits = group number
	    // x % numUnits = offset within group
	    // group number * numUnits = start of group

	    int groupNumber = tsi.minX / numUnits;
	    int startOfGroup = groupNumber * numUnits;
	    int xStart = startOfGroup + offset;
	    if( xStart < tsi.minX )
		{
		    xStart = xStart + numUnits;
		}

	    for( int y = tsi.minY; y <= tsi.maxY; ++y )
		{
		    // for( int x = offset; x < tsi.maxX; x = x + numUnits )
		    for( int x = xStart; x < tsi.maxX; x = x + numUnits )
			{
			    // compute NDC coordinates for current pixel position
			    float ndcX = ( float )( x ) * 2.0 / ( float )screenWidth - 1.0;
			    float ndcY = ( float )( y ) * 2.0 / ( float )screenHeight - 1.0;

			    // interpolate w
			    float w = 1.0 / ( tsi.wInterp.x * ndcX + tsi.wInterp.y * ndcY + tsi.wInterp.z );

			    float inside01 = interpolate( tsi.edge01.x, tsi.edge01.y, tsi.edge01.z, ndcX, ndcY, w );
			    float inside12 = interpolate( tsi.edge12.x, tsi.edge12.y, tsi.edge12.z, ndcX, ndcY, w );
			    float inside20 = interpolate( tsi.edge20.x, tsi.edge20.y, tsi.edge20.z, ndcX, ndcY, w );
			    if( inside01 >= 0 && inside12 >= 0 && inside20 >= 0 )
				{
				    // interpolate z
				    float z = interpolate( tsi.zInterp.x, tsi.zInterp.y, tsi.zInterp.z, ndcX, ndcY, w );
				    if( z >= 0 )
					{
					    Fragment f;
					    f.x = x;
					    f.y = y;
					    f.z = z;

					    // push fragment
					    push( f );
					}
				}
			}
		}
	}
}



// ############### Pass2_RasterOps.str ###############
Fragment->void filter RasterOps( int offset, int numUnits,
	int screenWidth, int screenHeight )
{
    int width;

    // TODO: break it up!
    float[ 360000 ] zBuffer = init_array_1D_float( "Pass0.zBuffer.xy.arr", 360000 );
    int[ 360000 ] stencilBuffer = init_array_1D_int( "Pass1.sBuffer.xy.arr", ( 360000 ) );
    /*
      float[ ( screenWidth / numUnits ) * screenHeight ] zBuffer = init_array_1D_float( "Pass0.zBuffer.xy.arr", ( screenWidth / numUnits ) * screenHeight );
      int[ ( screenWidth / numUnits ) * screenHeight ] stencilBuffer = init_array_1D_int( "Pass1.sBuffer.xy.arr", ( screenWidth / numUnits ) * screenHeight );
    */

    float[ ( screenWidth / numUnits ) * screenHeight ] red;
    float[ ( screenWidth / numUnits ) * screenHeight ] green;
    float[ ( screenWidth / numUnits ) * screenHeight ] blue;

    // int[ ( screenWidth / numUnits ) * screenHeight ] stencilBuffer;

    init
	{
	    width = screenWidth / numUnits;
	}

    work pop 1
	{
	    Fragment f = pop();

	    f.x = f.x / numUnits;
	    int index = f.y * width + f.x;


	    if( f.z <= zBuffer[ index ] )
		{
		    if( stencilBuffer[ index ] == 0 )
			{
			    red[ index ] = 1.0;
			    green[ index ] = 0.0;
			    blue[ index ] = 0.0;
			}
		    else
			{
			    red[ index ] = 0.2;
			    green[ index ] = 0.2;
			    blue[ index ] = 0.2;
			}
		}
	}
}
