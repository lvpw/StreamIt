float->float filter CombineDFT(int n)
{
    float wn_r, wn_i;

    init {
	  wn_r = (float)cos(2 * 3.141592654 / n);
	  wn_i = (float)sin(2 * 3.141592654 / n);
    }

    work push 2*n pop 2*n {
        int i;
        float w_r = 1;
        float w_i = 0;
	  float[2*n] results;

        for (i = 0; i < n; i += 2) {
		float y0_r = peek(i);
            float y0_i = peek(i+1);
            
		float y1_r = peek(n + i);
            float y1_i = peek(n + i + 1);
		
            float y1w_r = y1_r * w_r - y1_i * w_i;
            float y1w_i = y1_r * w_i + y1_i * w_r;
		
            results[i] = y0_r + y1w_r;
            results[i + 1] = y0_i + y1w_i;
		
		results[n + i] = y0_r - y1w_r;
            results[n + i + 1] = y0_i - y1w_i;
		
            float w_r_next = w_r * wn_r - w_i * wn_i;
            float w_i_next = w_r * wn_i + w_i * wn_r;
            w_r = w_r_next;
            w_i = w_i_next;
        }

        for (i = 0; i < 2 * n; i++) {
            pop();
            push(results[i]);
        }
    }
}


float->float filter FFTReorderSimple(int n)
{
    int totalData;
    
    init {
	  totalData = 2*n; 
    }
    
    work push 2*n pop 2*n {
        int i;
        
        for (i = 0; i < totalData; i+=4) {
            push(peek(i));
            push(peek(i+1));
        }
        
        for (i = 2; i < totalData; i+=4) {
            push(peek(i));
            push(peek(i+1));
        }
        
        for (i = 0; i < n; i++) {
            pop();
            pop();
        }
    }
}


float->float pipeline FFTReorder(int n) 
{
    for (int i = 1; i < (n / 2); i *= 2) {
	  add FFTReorderSimple(n/i);
    }
}


float->float pipeline FFT_Kernel(int n) 
{
    add FFTReorder(n);
    for (int j = 2; j <= n; j *= 2) {
	  add CombineDFT(j);
    }
 }


void->float filter Read_From_AtoD(int N) 
{
    work pop 0 push 2*N {
	  push(0.0);
	  push(0.0);
	  push(1.0);
	  push(0.0);
	  
	  for(int i = 0; i < 2 * (N - 2); i++) {
		push(0.0);
	  }
    }
}


float->float filter RFtoIF(int _N, float _start_freq)
{
    // CONSTANTS {
    float CARRIER_FREQ = 1.0;
    float MIN_FREQ     = 1.0;
    int   MAX_WEIGHTS  = (int) (CARRIER_FREQ / MIN_FREQ * _N);
    // } CONSTANTS

    float[MAX_WEIGHTS] weights;
    int  size, count, N;

    init {
	  N = _N;
	  set_frequency(_start_freq);
    }
    
    work peek 1 pop 1 push 1 {
	  push(pop() * weights[count++]);

	  if (count == size) {
		count = 0;
	  }
    }

    handler set_frequency(float _freq) {
	  count  = 0;
	  size   = (int) (CARRIER_FREQ / _freq * N);
	  for (int i = 0; i < size; i++) {
		weights[i] = /* sin */ (i * pi / size);
	  }
    }
}


float->float splitjoin Check_Freq_Hop(int N, portal<RFtoIF> port) 
{
    // CONSTANTS {
    float FREQ_HOP_THRESHOLD = 1.0;
    int   MAX_FREQS          = 1; 
    float [MAX_FREQS] FREQS;
    for (int i = 0; i < MAX_FREQS; i++) {
	  FREQS[i] = i * 1.0;
    }
    // } CONSTANTS

    split roundrobin(N / 4 - 2, 1, 1, N / 2, 1, 1, N / 4 - 2);
    for (int i = 1, k = 0; i < 6; i++) {
	  if ((i == 2) || (i == 4)) {
		for (int j = 0; j < 2; j++) {
		    add float->float filter {
			  work pop 1 push 1 {
				float val = pop();
				if (val >= FREQ_HOP_THRESHOLD) {
				    port.set_frequency(FREQS[k]) [4 : 6];
				}
				push(val);
			  }
		    }
		}
		k++;
		if (k >= MAX_FREQS) k = 0;
	  }
	  else {
		add Identity<float>;
	  }
    }
    join roundrobin(N / 4 - 2, 1, 1, N / 2, 1, 1, N / 4 - 2);
}


void->void pipeline FHR
{
    // CONSTANTS {
    int N          = 64;
    int START_FREQ = 1;
    // } CONSTANTS

    portal <RFtoIF> port;

    add Read_From_AtoD(N);

    add RFtoIF(N, START_FREQ) to port;

    add FFT_Kernel(N);

    add Check_Freq_Hop(N, port);

    add float->void filter {
	  work push 0 pop 1 {
		print(pop());
	  }
    }
}
