/*
 * Copyright 2005 by the Massachusetts Institute of Technology.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in
 * advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 */

/**
 * @description
 * This file contains functions that implement Discrete Cosine Transforms and
 * their inverses.  When reference is made to the IEEE DCT specification, it
 * is refering to the IEEE DCT specification used by both MPEG and JPEG.
 * A definition of what makes an 8x8 DCT conform to the IEEE specification, as well
 * as a pseudocode implementation, can be found in Appendix A of the MPEG-2 specification
 * (ISO/IEC 13818-2) on P. 125. 
 *
 * @author <a href="mailto:madrake@gmail.com">Matthew Drake</a>
 * @file DCTinternal.str
 * @version 1.0
 */

/**
 * @internal
 */
int->int filter DCT_2D_ref {
// Based on the implementation given in the C MPEG-2 reference implementation
  float[8][8] c;
  
  init {
    for (int i = 0; i < 8; i++) {
      float s = (i == 0) ? sqrt(0.125) : 0.5;
      for (int j = 0; j < 8; j++) {
        c[i][j] = s*cos((pi/8.0)*i*(j+0.5));
      }
    }
  }

  work pop 64 push 64 {
    int[8][8] block;
    float[8][8] tmp;
    int i, j, k;
    for (i = 0; i < 8; i++) {
      for (j = 0; j < 8; j++) {
        block[i][j] = pop();
      }
    }
    for (i = 0; i < 8; i++) {
      for (j = 0; j < 8; j++) {
        float s = 0.0;
        for (k = 0; k < 8; k++) {
          s += c[j][k] * block[i][k];
        }
      tmp[i][j] = s;
      }
    }
    for (j = 0; j < 8; j++) {
      for (i = 0; i < 8; i++) {
        float s = 0.0;
        for (k = 0; k < 8; k++) {
          s += c[i][k] * tmp[k][j];
        }
        block[i][j] = (int) floor(s+0.5);
      }
    }
    for (i = 0; i < 8; i++) {
      for (j = 0; j < 8; j++) {
        push(block[i][j]);
      }      
    }
  }
}

/**
 * @internal
 */
int->int filter iDCT_2D_ref {
// Based on the implementation given in the C MPEG-2 reference implementation
  float[8][8] c;

  init {
    for (int freq = 0; freq < 8; freq++) {
      float scale = (freq == 0) ? sqrt(0.125) : 0.5;
      for (int time = 0; time < 8; time++)
        c[freq][time] = scale*cos((pi/8.0)*freq*(time + 0.5));
    }
  }
  work pop 64 push 64 {
    int[8][8] block;
    float[8][8] tmp;
    int i, j, k;
    for (i = 0; i < 8; i++)
      for (j = 0; j < 8; j++) {
        block[i][j] = pop();
      }
    float partial_product;
    for (i = 0; i < 8; i++)
      for (j = 0; j < 8; j++) {
        partial_product = 0.0;
        for (k = 0; k < 8; k++) {
          float a3 = (c[k][j]*block[i][k]);
          partial_product += c[k][j]*block[i][k]; 
        }
        tmp[i][j] = partial_product;
      }
    for (j = 0; j < 8; j++)
      for (i = 0; i < 8; i++) {
        partial_product = 0.0;
        for (k = 0; k < 8; k++) {
          float a1 = c[k][i];
          float a2 = tmp[k][j];
          float a3 = a1*a2;
          partial_product += c[k][i]*tmp[k][j];
        }
        int v = (int) floor(partial_product + 0.5);
        block[i][j] = v;      
      }
    for (i = 0; i < 8; i++)
      for (j = 0; j < 8; j++) {
        push(block[i][j]);
      }
  }
}

/**
 * Transforms a 2D signal from the signal domain to the frequency domain
 * using a Discrete Cosine Transform. 
 * @param size The number of elements in each dimension 
 *        of the signal. 
 * @input size x size values, representing an array of values in the signal
 *        domain, ordered by row and then column.
 * @output size x size values representing an array of values in the 
 *         frequency domain, ordered by row and then column. Vertical frequency
 *         increases along each row and horizontal frequency along each column.
 */
float->float pipeline DCT_2D(int size) {
  add helper_Parallel_8_DCT_1D_X(size);
  add helper_Parallel_8_DCT_1D_Y(size); 
}

/**
 * Transforms a 2D signal from the frequency domain to the signal domain
 * using an inverse Discrete Cosine Transform.
 * @param size The number of elements in each dimension of the signal.
 * @input size x size values, representing an array of values in the frequency 
 *        domain, ordered by row and then column. Vertical frequency increases
 *        along each row and horizontal frequency along each column.
 * @output size x size values representing an array of values in the signal
 *         domain, ordered by row and then column.
 */
float->float pipeline iDCT_2D(int size) {
  add helper_Parallel_8_iDCT_1D_Y(size);
  add helper_Parallel_8_iDCT_1D_X(size);
}

/**
 * Transforms a 2D signal from the frequency domain to the signal domain
 * using an inverse Discrete Cosine Transform.
 * @param size The number of elements in each dimension of the signal.
 * @input size x size values, representing an array of values in the frequency 
 *        domain, ordered by row and then column. Vertical frequency increases
 *        along each row and horizontal frequency along each column.
 * @output size x size values representing an array of values in the signal
 *         domain, ordered by row and then column.
 */
int->int pipeline iDCT_2D_int(int size) {
  add int->float filter {
    work pop 1 push 1 {
      push((float) pop());
    }
  }
  add iDCT_2D(8);
  add float->int filter {
    work pop 1 push 1 {
      push((int) round(pop()));
    } 
  }
}

/**
 * Transforms a 2D signal from the signal domain to the frequency domain
 * using a Discrete Cosine Transform. 
 * @param size The number of elements in each dimension of the signal. 
 * @input size x size values, representing an array of values in the signal
 *        domain, ordered by row and then column.
 * @output size x size values representing an array of values in the 
 *         frequency domain, ordered by row and then column. Vertical frequency
 *         increases along each row and horizontal frequency along each column.
 */
int->int pipeline DCT_2D_int(int size) {
  add int->float filter {
    work pop 1 push 1 {
      push((float) pop());
    }
  }
  add DCT_2D(8);
  add float->int filter {
    work pop 1 push 1 {
      push((int) round(pop()));
    } 
  }
}

/**
 * @internal
 */
float->float filter DivideBy_float(float divisor) {
  work pop 1 push 1 {
    push(pop()/divisor);
  }
}

/**
 * Transforms a 1D signal from the frequency domain to the signal domain
 * using an inverse Discrete Cosine Transform.
 * @param size The number of elements in each dimension of the signal.
 * @input size values, representing an array of values in the frequency 
 *        domain, ordered by row and then column. Vertical frequency increases
 *        along each row and horizontal frequency along each column.
 * @output size values representing an array of values in the signal
 *         domain, ordered by row and then column.
 */
float->float pipeline iDCT_1D(int size) {
  add float->float splitjoin {
    split duplicate();
    for (int x = 0; x < size; x++) {
      add iDCT_1D_compute_value(x, size);    
    }
    join roundrobin(1);
  }
  add DivideBy_float(2.0);
}

/**
 * @internal
 */
float->float pipeline iDCT_1D_compute_value(int x, int size) {
  add float->float splitjoin {
    split roundrobin(1);
    for (int u = 0; u < size; u++) {
      if (u == 0) {
        add ComputeIntermediate(x, u, size, 1/sqrt(2));
      } else {
        add ComputeIntermediate(x, u, size, 1);
      }
    }
    join roundrobin(1);
  }
  add Add_float(8);
}

/**
 * @internal
 */
float->float filter Add_float(int num) {
  work pop num push 1 {
    float total = 0;
    for (int i = 0; i < num; i++) {
      total += pop();
    }
    push(total);
  }
}

/**
 * Transforms a 1D signal from the signal domain to the frequency domain
 * using a Discrete Cosine Transform. 
 * @param size The number of elements in each dimension of the signal. 
 * @input size values, representing an array of values in the signal
 *        domain, ordered by row and then column.
 * @output size values representing an array of values in the 
 *         frequency domain, ordered by row and then column. Vertical frequency
 *         increases along each row and horizontal frequency along each column.
 */
float->float pipeline DCT_1D(int size) {
  add float->float splitjoin {
    split duplicate();
    for (int u = 0; u < size; u++) {
      add DCT_1D_compute_value(u, size);
    }
    join roundrobin(1);
  }
  add DivideBy_float(2.0);
}

/**
 * @internal
 */
float->float pipeline DCT_1D_compute_value(int u, int size) {
  add float->float splitjoin {
    split roundrobin(1);
    for (int x = 0; x < size; x++) {
      if (u == 0) {
        add ComputeIntermediate(x, u, size, 1/sqrt(2));
      } else {
        add ComputeIntermediate(x, u, size, 1);    
      }
    }
    join roundrobin(1);
  }
  add Add_float(8);
}

/** 
 * @internal
 */
float->float filter ComputeIntermediate(int x, int u, int size, float Cu) {
  work pop 1 push 1 {
    push(Cu*pop()*cos(u*pi*(2.0*x+1)/(2.0*size)));
  }
}

/**
 * @internal
 */
float->float splitjoin helper_Parallel_8_DCT_1D_X(int size) {
  split roundrobin(size);
  for (int i = 0; i < size; i++) {
    add DCT_1D(size);
  }
  join roundrobin(size);
}

/**
 * @internal
 */
float->float splitjoin helper_Parallel_8_DCT_1D_Y(int size) {
  split roundrobin(1);
  for (int i = 0; i < size; i++) {
    add DCT_1D(size);
  }
  join roundrobin(1);
}

/**
 * @internal
 */
float->float splitjoin helper_Parallel_8_iDCT_1D_X(int size) {
  split roundrobin(size);
  for (int i = 0; i < size; i++) {
    add iDCT_1D(size); 
  }
  join roundrobin(size);
}

/**
 * @internal
 */
float->float splitjoin helper_Parallel_8_iDCT_1D_Y(int size) {
  split roundrobin(1);
  for (int i = 0; i < size; i++) {
    add iDCT_1D(size);
  }
  join roundrobin(1);
}
