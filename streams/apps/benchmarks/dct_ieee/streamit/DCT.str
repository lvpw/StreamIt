/*
 * Copyright 2005 by the Massachusetts Institute of Technology.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in
 * advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 */

/**
 * @description
 * This file contains functions that implement Discrete Cosine Transforms and
 * their inverses.  When reference is made to the IEEE DCT specification, it
 * is refering to the IEEE DCT specification used by both MPEG and JPEG.
 * A definition of what makes an 8x8 DCT conform to the IEEE specification, as well
 * as a pseudocode implementation, can be found in Appendix A of the MPEG-2 specification
 * (ISO/IEC 13818-2) on P. 125. 
 *
 * @author <a href="mailto:madrake@gmail.com">Matthew Drake</a>
 * @file DCT.str
 * @version 1.0
 */

/**
 * Transforms an 8x8 signal from the frequency domain to the signal domain
 * using an inverse Discrete Cosine Transform in accordance with
 * the IEEE specification for a 2-dimensional 8x8 iDCT.
 * @input 64 values representing an 8x8 array of values in the 
 *        frequency domain, ordered
 *        by row and then column. Vertical frequency increases 
 *        along each row and horizontal frequency along each column.
 * @output 64 values representing an 8x8 array of values in the
 *        signal domain, ordered by row and then column.
 */
int->int pipeline iDCT8x8_ieee {
  add iDCT_2D_int(8);
//  add iDCT_2D_ref;
}

/**
 * @internal
 */
int->int filter iDCT_2D_ref {
// Based on the implementation given in the C MPEG-2 reference implementation
  float[8][8] c;

  init {
    for (int freq = 0; freq < 8; freq++) {
      float scale = (freq == 0) ? sqrt(0.125) : 0.5;
      for (int time = 0; time < 8; time++)
        c[freq][time] = scale*cos((pi/8.0)*freq*(time + 0.5));
    }
  }
  work pop 64 push 64 {
    int[8][8] block;
    float[8][8] tmp;
    int i, j, k;
    for (i = 0; i < 8; i++)
      for (j = 0; j < 8; j++) {
        block[i][j] = pop();
      }
    float partial_product;
    for (i = 0; i < 8; i++)
      for (j = 0; j < 8; j++) {
        partial_product = 0.0;
        for (k = 0; k < 8; k++) {
          float a3 = (c[k][j]*block[i][k]);
          partial_product += c[k][j]*block[i][k]; 
        }
        tmp[i][j] = partial_product;
      }
    for (j = 0; j < 8; j++)
      for (i = 0; i < 8; i++) {
        partial_product = 0.0;
        for (k = 0; k < 8; k++) {
          float a1 = c[k][i];
          float a2 = tmp[k][j];
          float a3 = a1*a2;
          partial_product += c[k][i]*tmp[k][j];
        }
        int v = (int) floor(partial_product + 0.5);
        block[i][j] = v;      
      }
    for (i = 0; i < 8; i++)
      for (j = 0; j < 8; j++) {
        push(block[i][j]);
      }
  }
}

/**
 * Transforms an 8x8 signal from the signal domain to the frequency domain
 * using a Discrete Cosine Transform in accordance with the IEEE
 * specification for a 2-dimensional 8x8 DCT.
 * @input 64 values representing an 8x8 array of values in the signal
 *        domain, ordered by row and then column.
 * @output 64 values representing an 8x8 array of values in the 
 *         frequency domain, ordered by row and then column. Vertical frequency
 *         increases along each row and horizontal frequency along each column.
 */
int->int pipeline DCT8x8_ieee {
  add DCT_2D_int(8);
}

/**
 * Transforms a 2D signal from the signal domain to the frequency domain
 * using a Discrete Cosine Transform. 
 * @param size The number of elements in each dimension 
 *        of the signal. 
 * @input size x size values, representing an array of values in the signal
 *        domain, ordered by row and then column.
 * @output size x size values representing an array of values in the 
 *         frequency domain, ordered by row and then column. Vertical frequency
 *         increases along each row and horizontal frequency along each column.
 */
float->float pipeline DCT_2D(int size) {
  add helper_Parallel_8_DCT_1D_X(size);
  add helper_Parallel_8_DCT_1D_Y(size); 
}

/**
 * Transforms a 2D signal from the frequency domain to the signal domain
 * using an inverse Discrete Cosine Transform.
 * @param size The number of elements in each dimension of the signal.
 * @input size x size values, representing an array of values in the frequency 
 *        domain, ordered by row and then column. Vertical frequency increases
 *        along each row and horizontal frequency along each column.
 * @output size x size values representing an array of values in the signal
 *         domain, ordered by row and then column.
 */
float->float pipeline iDCT_2D(int size) {
  add helper_Parallel_8_iDCT_1D_Y(size);
  add helper_Parallel_8_iDCT_1D_X(size);
}

/**
 * Transforms a 2D signal from the frequency domain to the signal domain
 * using an inverse Discrete Cosine Transform.
 * @param size The number of elements in each dimension of the signal.
 * @input size x size values, representing an array of values in the frequency 
 *        domain, ordered by row and then column. Vertical frequency increases
 *        along each row and horizontal frequency along each column.
 * @output size x size values representing an array of values in the signal
 *         domain, ordered by row and then column.
 */
int->int pipeline iDCT_2D_int(int size) {
  add int->float filter {
    work pop 1 push 1 {
      push((float) pop());
    }
  }
  add iDCT_2D(8);
  add float->int filter {
    work pop 1 push 1 {
      push((int) round(pop()));
    } 
  }
}

/**
 * Transforms a 2D signal from the signal domain to the frequency domain
 * using a Discrete Cosine Transform. 
 * @param size The number of elements in each dimension of the signal. 
 * @input size x size values, representing an array of values in the signal
 *        domain, ordered by row and then column.
 * @output size x size values representing an array of values in the 
 *         frequency domain, ordered by row and then column. Vertical frequency
 *         increases along each row and horizontal frequency along each column.
 */
int->int pipeline DCT_2D_int(int size) {
  add int->float filter {
    work pop 1 push 1 {
      push((float) pop());
    }
  }
  add DCT_2D(8);
  add float->int filter {
    work pop 1 push 1 {
      push((int) round(pop()));
    } 
  }
}

/**
 * Transforms a 1D signal from the frequency domain to the signal domain
 * using an inverse Discrete Cosine Transform.
 * @param size The number of elements in each dimension of the signal.
 * @input size values, representing an array of values in the frequency 
 *        domain, ordered by row and then column. Vertical frequency increases
 *        along each row and horizontal frequency along each column.
 * @output size values representing an array of values in the signal
 *         domain, ordered by row and then column.
 */
float->float filter iDCT_1D(int size) {
  work pop size push size {
    float Cu;
    for (int x = 0; x < size; x++) {
      float tempsum = 0;
      for (int u = 0; u < size; u++) {
        if (u == 0)
          Cu = 1/sqrt(2);
        else
          Cu = 1;
        tempsum += Cu*peek(u)*cos(u*pi*(2.0*x+1)/(2.0*size));
      }
      push((1.0/2.0)*tempsum);
    }
    for (int x = 0; x < size; x++) {
      pop();
    }
  }
}

/**
 * Transforms a 1D signal from the signal domain to the frequency domain
 * using a Discrete Cosine Transform. 
 * @param size The number of elements in each dimension of the signal. 
 * @input size values, representing an array of values in the signal
 *        domain, ordered by row and then column.
 * @output size values representing an array of values in the 
 *         frequency domain, ordered by row and then column. Vertical frequency
 *         increases along each row and horizontal frequency along each column.
 */
float->float filter DCT_1D(int size) {
  work pop size push size {
    float Cu;
    for (int u = 0; u < size; u++) {
      if (u == 0) 
        Cu = 1/sqrt(2);
      else
        Cu = 1;
      float tempsum = 0;
      for (int x = 0; x < size; x++) {
        tempsum += peek(x)*cos(u*pi*(2.0*x+1)/(2.0*size));
      }
      push((1.0/2.0)*Cu*tempsum);
    }
    for (int x = 0; x < size; x++) {
      pop();
    }
  }
}

/**
 * @internal
 */
float->float splitjoin helper_Parallel_8_DCT_1D_X(int size) {
  split roundrobin(size);
  for (int i = 0; i < size; i++) {
    add DCT_1D(size);
  }
  join roundrobin(size);
}

/**
 * @internal
 */
float->float splitjoin helper_Parallel_8_DCT_1D_Y(int size) {
  split roundrobin(1);
  for (int i = 0; i < size; i++) {
    add DCT_1D(size);
  }
  join roundrobin(1);
}

/**
 * @internal
 */
float->float splitjoin helper_Parallel_8_iDCT_1D_X(int size) {
  split roundrobin(size);
  for (int i = 0; i < size; i++) {
    add iDCT_1D(size); 
  }
  join roundrobin(size);
}

/**
 * @internal
 */
float->float splitjoin helper_Parallel_8_iDCT_1D_Y(int size) {
  split roundrobin(1);
  for (int i = 0; i < size; i++) {
    add iDCT_1D(size);
  }
  join roundrobin(1);
}
