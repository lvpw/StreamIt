#!/usr/local/bin/perl

# This script attempts to measure the work function 
# for linear filters
# for each pair (mults, peek) we measure the execution
# time the direct implementation and the execution time
# for the frequency implementation.

use strict;
require "reaplib.pl";

# the name of the file to generate.
my $PROGRAM_NAME = "WorkFunctionTest";
# the name of the output file to use 
my $OUTPUT_FILENAME = "workFunc.tsv";
# number of trials to run
my $NUM_TRIALS = 5;
# number of iterations to run the program for
my $ITERS = 1000000000;



# start off the action by determining the results directory:
# the first /tmp/workFunX, where X is some number, that doesn't exist
my $count = 0;
my $results_dir = "/tmp/workFun$count";
while (-e $results_dir) {$results_dir = "/tmp/workFun$count";$count++;}

# actually create the results directory.
print "making $results_dir: " . `mkdir $results_dir` . "\n";


# set up the number of peeks and pushes for each test.
# note that the number of peeks corresponds to the number of multiplies
# _per_ push. (peeks-zero_rows) is the actual number of multiplies in
# each push expression.
# format is "peeks:zero_rows:pushes
my @peeks_pushes;
#@peeks_pushes = ("10:0:1");

# auto generate the data set that we want
my ($i,$j);
for ($i=10; $i<=200; $i+=10) {
    for ($j=1; $j<2; $j++) {    
	push(@peeks_pushes, "$i:0:$j");
    }
}

# array to store all of the results
my @results = ("peeks\tzero_rows\tpushes\t" .
	       "linear outputs\tlinear times\tlinear avg time\t" .
	       "freq outputs\tfreq times\tfreq avg time\t" .
	       "load 1\tload 5\tload 15");

# now, start with the fun.
foreach (@peeks_pushes) {
    my ($peeks, $zero_rows, $pushes) = split(":",$_);

    # create a streamit program that performs the appropriate number of multiplies and adds.
    make_linear_program($results_dir, $PROGRAM_NAME, $peeks, $zero_rows, $pushes);
    
    # convert to java
    do_frontend_compile($results_dir, $PROGRAM_NAME);

    print "\n ";

    # get the output count and execution times 
    # for compilation with linearreplacement option
    my ($linear_outputs, $linear_time_string, $linear_avg_time) = 
	do_time_trial($results_dir, $PROGRAM_NAME, "--unroll 100000 --linearreplacement",
		      $NUM_TRIALS, $ITERS);

    print "\n ";

    # get the output count and execution times 
    # for compilation with frequency replacement option
    my ($freq_outputs, $freq_time_string, $freq_avg_time) = 
	do_time_trial($results_dir, $PROGRAM_NAME, "--unroll 100000 --frequencyreplacement 3",
		      $NUM_TRIALS, $ITERS/2);
    
    print "\n";

    # now, grab the load averages
    my ($load_1, $load_5, $load_15) = get_load();

    # save the line of output
    push(@results,
	 "$peeks\t$zero_rows\t$pushes\t" .
	 "$linear_outputs\t$linear_time_string\t$linear_avg_time\t" .
	 "$freq_outputs\t$freq_time_string\t$freq_avg_time\t" .
	 "$load_1\t$load_5\t$load_15");
}


# now, save our results to a file
open (OUTFILE, ">$results_dir/$OUTPUT_FILENAME");
print OUTFILE join("\n",@results);
close(OUTFILE);

# also for good measure, send an email.
open (MHMAIL, "|mhmail \$USER\@cag.lcs.mit.edu -s \"Work function measurements mail\"");
print MHMAIL join("\n",@results);
close(MHMAIL);



####
# Subroutine to create a linear program. The program is a single linear filter
# that computes a vector-matrix product. The matrix is peek rows high, push
# colums wide and has zero_rows zero rows at the top. The elements of the
# matrix are all non-zero, non-unity floating point numbers.
####
sub make_linear_program {
    my $path          = shift || die ("no path");
    my $filename_base = shift || die "no filename base";
    my $peeks         = shift || die ("no peeks");
    my $zero_rows     = shift;
    my $pushes        = shift || die ("no pushes");

    print "(file gen)";
    
    # create the header
    my $contents = <<EOF;
    // Autogenerated program for measuring timing information
    void->void pipeline $filename_base {
	add SimpleSource();
	add AutoGenFilter();
	add SimpleSink();
    }
    void->float filter SimpleSource {
	int x;
	work push 1 {
	    push(x);
	    x = (x+1) & 16;
	}
    }
    float->void filter SimpleSink {
	work pop 1 {
	    println(pop());
	}
    }
    float->float filter AutoGenFilter {
	work peek $peeks pop 1 push $pushes {
EOF
    
    # now, generate the body of the function
    # for each push
    my $current_coefficient = 2; # don't put in a 0 or 1
    my ($current_push, $current_peek);
    for ($current_push=0; $current_push<$pushes; $current_push++) {
	$contents .= "push("; # start the push statement
	for ($current_peek=$zero_rows; $current_peek<$peeks; $current_peek++) {
	    $contents .= "peek($current_peek)*$current_coefficient+";
	    $current_coefficient += 0.01; # inc the coeff so that there is no cse involved.
	}
	# chop off the last plus sign
	$contents = substr($contents,0,length($contents)-1);
	# finish up this push statement.
	$contents .= ");\n";
    }


    # generate the footer (end of the work function simply needs to be } 
    # and one final one for the end of the filter
$contents .= <<EOF;
        pop();
        }
    }
EOF

    # write that sucker to the appropriate place
    write_file($contents, "$path/$filename_base.str");
}

#### 
# Subroutine to do a time trial. We compile the 
# specified program with the specified streamit options
# figure out the number of outputs produces in a 
# certain number of iterations, remove printfs, recompile
# and then time their executions for several executions.
# 
# return value is ($outputs, $time_string, $avg_time)
# where the time string is a comma separated list of
# the execution times we measured and $avg_time is the
# average of hte number sin $time_string.
####
sub do_time_trial {
    my $results_dir   = shift || die ("no results dir");
    my $filename_base = shift || die ("no base name");
    my $options       = shift || die ("no options");
    my $num_trials    = shift || die ("no num iters");
    my $iters         = shift || die ("no iters");

    # run the streamit compiler and c compiler
    do_streamit_compile($results_dir, $filename_base, $options);
    do_c_compile($results_dir, $filename_base);

    # figure out the number of outputs
    my $outputs = get_output_count($results_dir, $filename_base, $iters);
    
    # remove prinfs
    remove_prints($results_dir, $filename_base);

    # compile to exe (again)
    do_c_compile($results_dir, $filename_base);

    # now, time the execution $num_trials times
    my @times;
    my $i;
    for ($i=0; $i<$num_trials; $i++) {
	push(@times,
	     time_execution($results_dir, $filename_base, $iters));
    }

    # compute the average execution time (perl cleverness)
    my $avg_time = 0;
    map($avg_time += $_, @times);
    $avg_time = $avg_time/$num_trials;

    #print "times: " . join(",", @times) . ". avg: $avg_time\n";

    # now, return the appropriate data
    return ($outputs, join(",",@times), $avg_time);

}

