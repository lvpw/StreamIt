/*
 * Copyright 2005 by the Massachusetts Institute of Technology.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in
 * advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 */

/**
 * @description
 * This file contains functions that allow one to decode MPEG-2 compliant video. 
 * The code is based on the MPEG-2 specification (ISO/IEC 13818-2). The MPEG-2 decoding
 * is a work in progress, although it works within a limited test range. Throughout the 
 * source code, citations are made in cases where an understanding of the code would be
 * helped by looking at an outside source. The format I have chosen is 
 * (cite NUM#, LOOKUP_INFO). NUM=1 refers to ISO/IEC: 13818-2, and NUM=2 refers to the reference
 * MPEG implementation written in C, available at [www.mpeg.org].
 *
 * @author <a href="mailto:madrake@gmail.com">Matthew Drake</a>
 * @file MPEGdecoder.str.pre
 * @version 1.0
 */

// Comments for readers of the StreamIt MPEG specification:
//
// TODO notes refer to parts of the MPEG-2 specification which this
// program does not yet handle, or assumptions made by the program.
// FEATURETODO notes refer to changes that ought to be made to the program,
// or support which can be added for more of the MPEG-2 specification, which
// is pending the addition of features to the StreamIt language compiler.
// In general I have tried to document my code, and refer to the MPEG-2
// specification whenever I used it. If you are looking at any particular
// block of code and aren't sure what it is doing, find the previous citation
// comment, and refer to the corresponding page in the MPEG 2 spec.

/**
 * Interprets and decodes a compressed MPEG-2 compliant bit stream, in accordance
 * with the IEEE MPEG-2 specification.
 * @param width The resolution width of the video. This variable is only needed until the StreamIt
 *              language supports dynamically reconfiguring splijtoins.
 * @param height The resolution height of the video. This variable is only needed until the StreamIt
 *               language supports dynamically reconfiguring splitjoins.
 * @input An MPEG-2 compliant bit stream of variable length.
 * @output Outputs a series of images representing the frames of the video. Each image
 *         consists of 3 integers for each pixel, with the number of pixels per image 
 *         equalling the width * height of the video. Frames are output in time order,
 *         top to bottom, left to right, and RGB color order.
 */
              
void->void pipeline MPEGdecoder_nomessage_5_3() {
    // 1 = Perform only the variable length decoding
    // 2 = MPEG decoding without the file parsing
    // 3 = Full MPEG pipeline
    // 4 = No file parsing, only perform block decoding. 
    //       Need 1320 iterations (-i 1320) to process input.
    // 5 = First half of the MPEG pipeline without file parsing
    //     - Block decoding and motion vector decoding
    //       Need 1320 iterations (-i 1320) to process input.
    // 6 = Color Channel Processing  - Upsampling for chrominance channels 
    //     and motion compensation for all channels
    //       Needs 1 iteration in library, but 3 in cluster due to scheduling
    //       differences.
    // 7 = 4 + 5 + 6 as they appear in the contest of MPEG decoding.
    //       Needs 1 iteration in library, but 3 in cluster due to scheduling
    //       differences.
    // 8 = The PictureReorder phase of MPEG decoding.
    //       The in library with nosched: would expect to schedule and
    //       run with -i 3, but for some reason hangs after only 2/3 of output.  
    // 9 = The ColorSpaceConversion_YCbCrtoRGB phase of MPEG decoding.
    //       Run with -i 253440 for correct amount of output (given correct
    //       input from phase 8, else -i 168960 for 2/3-length input).

    // Dynamic Rate Graphs: 1, 3
    // Static Rate Graphs: 2, 4, 5, 6 
    // In terms of how these different run modes break up the application:
    // If 3 does not run correctly, see if 1 and 2 run correctly
    // If 2 does not run correctly, see if 5 and 6 run correctly
    // If 5 does not run correctly, see if 4 runs correctly
    // If 1, 4, or 6 don't run correctly, let me know and I'll subdivide those into smaller test cases.

    // All of these test cases can be run independently of each other.
    // For each output file, there is an associated output file without the "unver" extension
    // and an md5sum which can be compared against the actual output to make sure it's correct.
    int parse_or_process = 5;

    int width=352;
    int height=240;
    int the_chroma_format = 1;

 if (parse_or_process == 5) {
        add FileReader<int>("../input/dec_nm_parsed.int");
        add int->int splitjoin {
            split roundrobin(64*blocks_per_macroblock[the_chroma_format], 16, 3);
            add BlockDecode();
            add int->int pipeline {
                add MotionVectorDecode();
                add Repeat(8, blocks_per_macroblock[the_chroma_format]);
            }
            add Repeat(3, blocks_per_macroblock[the_chroma_format]); // macroblock_intra
            join roundrobin(64, 8, 3);
        } 
        add FileWriter<int>("./dec_nm_color_channels_input_3.int");
    } 
}

int->int pipeline MPEGStream_to_rawImageStream(int width, int height,
                                               int the_chroma_format) {
    // width, height, chroma: Hacked till we have reprogrammable splitjoins FEATURETODO

    add int->int splitjoin {
        split roundrobin(64*blocks_per_macroblock[the_chroma_format], 16, 3);
        add BlockDecode();
        add int->int pipeline {
            add MotionVectorDecode();
            add Repeat(8, blocks_per_macroblock[the_chroma_format]);
        }
        add Repeat(3, blocks_per_macroblock[the_chroma_format]); // macroblock_intra
        join roundrobin(64, 8, 3);
    }

    // Each output channel is ordered left to right, top to bottom
    add int->int splitjoin {
        //    if (the_chroma_format == 1) {
        split roundrobin(4*75, 2*75);
        //    } else {
        //      split roundrobin(4*75, 4*75);
        //    }
        add LuminanceChannelProcessing(width, height, the_chroma_format);
        add int->int splitjoin {
            split roundrobin(75);
            add ChrominanceChannelProcessing(width, height, the_chroma_format);  
            add ChrominanceChannelProcessing(width, height, the_chroma_format);  
            join roundrobin(1, 1);
        }
        join roundrobin(1, 2);
    }
 
    // FEATURETODO This next component should also use the UpdatePortal_picture_type
    // but it doesn't because of messaging limitations.
    add PictureReorder(width, height);

    // This function assumes that no sequence display extension was ever
    // encountered in the data stream, and the default colorspace transformations 
    // apply.
    // (cite 1, P. 47, Table 6-9): Refer to entry 1, which is
    // Recommendation ITU-R BT.709 for transformations.
    add ColorSpaceConversion_YCbCrtoRGB;

}

int->int splitjoin ReorderCrCbBlocks(int blocks_per_macroblock) {
    split roundrobin(75*4, 75*(blocks_per_macroblock-4));
    add Identity<int>;
    add int->int splitjoin {
        split roundrobin(75);
        add Identity<int>;
        add Identity<int>;
        join roundrobin(75*((blocks_per_macroblock-4)/2));
    } 
    join roundrobin(75*4, 75*(blocks_per_macroblock-4));
}

/**
 * @internal
 */
int->int filter MPEGStreamParser_InternalBuffering(int width,
                                                   int height,
                                                   int the_chroma_format) {
    // FEATURETODO
    // When phases can take parameters, get rid of this definition and
    // uncomment the definition in the filter work function, and change
    // the phase PushMacroblock() to use the parameter. 
    int b_per_m = blocks_per_macroblock[the_chroma_format];
    int[12][64] QFS; // Should be b_per_m, but b_per_m gets assigned later for some reason.
    int picture_coding_type;
    int macroblock_intra;
    int macroblock_motion_forward;
    int macroblock_motion_backward;
    int[2][2][2] motion_code;
    int[2][2][2] motion_residual;

    int ran;

    int i_buf = 0;
    int i_buf_pos = 0;

    int i_amount;
    int i_result;

    init {
        ran = 0;
    } 

    void I_Pops() pop * {
        if (i_buf_pos < i_amount) {
            int ipt = i_amount - i_buf_pos;
            if (ipt == 32) {
                i_result = (pop() >> (32 - ipt));
                i_buf = 0;
            } else {
                i_result = (i_buf >> (32 - i_buf_pos)) & ((1 << i_buf_pos) - 1);
                i_result <<= ipt;
                i_buf = pop();
                i_result += (i_buf >> (32 - ipt)) & ((1 << ipt) - 1);
                i_buf <<= ipt;
            }
            i_buf_pos += 32;
        } else {
            i_result = (i_buf >> (32 - i_amount)) & ((1 << i_amount) - 1);
            if (i_amount == 32) {
                i_buf = 0;
            } else {
                i_buf = i_buf << i_amount;
            }
        }
        i_buf_pos -= i_amount;
    }

    void I_Peeks() pop * {
        if (i_buf_pos <= i_amount) {
            int ipt = i_amount - i_buf_pos;
            if (i_buf_pos == 32) {
                i_result = i_buf;
            } else {
                i_result = (i_buf >> (32 - i_buf_pos)) & ((1 << i_buf_pos) - 1);
            }
            if (ipt == 32) {
                i_result = peek(0);
            } else {
                i_result = (i_result << ipt) + 
                    ((peek(0) >> (32 - ipt)) & ((1 << ipt) -1));
            }
        } else {
            if (i_amount == 32) {
                i_result = (i_buf >> (32 - i_amount)) & ((1 << i_amount) - 1);
            } else {
                i_result = (i_buf >> (32 - i_amount)) & ((1 << i_amount) - 1);
            }
        }
    }


    void PushMacroblock() push (b_per_m*64+19) {
        for (int i = 0; i < blocks_per_macroblock[the_chroma_format]; i++) {
            for (int j = 0; j < 64; j++) {
                push(QFS[i][j]);
            }
        }
        for (int r = 0; r < 2; r++) 
            for (int s = 0; s < 2; s++)
                for (int t = 0; t < 2; t++) {
                    push(motion_code[r][s][t]);
                }
        for (int r = 0; r < 2; r++) 
            for (int s = 0; s < 2; s++)
                for (int t = 0; t < 2; t++) {
                    push(motion_residual[r][s][t]);
                }
        push(macroblock_intra);
        push(macroblock_motion_forward);
        push(macroblock_motion_backward);
    }
    
    work pop 19539 push (1320*(b_per_m*64+19)) {
        while (ran < 2) {
    
            println("Parsing M2V File...");
            ran = 1;
 
            int tempval;

            // video_sequence() (cite 1, P. 25)

            {
              int nsc_tempval;
              i_amount = 24;
              I_Peeks();
              nsc_tempval = i_result;

              while (nsc_tempval != 1) {
                i_amount = 1;
                I_Pops();
                nsc_tempval = i_result;

                // print("....looking for next_start_code....");
                i_amount = 24;
                I_Peeks();
                nsc_tempval = i_result;

              }
            }

            // sequence_header() (cite 1, P. 26)

            i_amount = 32;
            I_Pops();
            tempval = i_result;

            if (tempval != 0x000001B3)
                println("Error - Expected Video Sequence Start Code, Found " + tempval);

            // Reading Sequence Header
            int horizontal_size_value, vertical_size_value, aspect_ratio_information,
                frame_rate_code, bit_rate_value, vbv_buffer_size_value,
                constrained_parameters_flag, load_intra_quantiser_matrix, load_non_intra_quantiser_matrix;
            // (cite 1, P.55)
            i_amount = 12;
            I_Pops();
            horizontal_size_value = i_result;

            i_amount = 12;
            I_Pops();
            vertical_size_value = i_result;

            i_amount = 4;
            I_Pops();
            aspect_ratio_information = i_result;


            // (cite 1, P.41 Table 6-3)
            if (aspect_ratio_information == 0)
                println("Error - Forbidden Aspect Ratio");
            else if (aspect_ratio_information == 1) {
                // aspect_ratio_information == 1 -> aspect ratio is 1:1, this case is handled
            } else {
                println("Error - Program Limitation: Don't Know How to Handle Other Aspect Ratios");
            }
            i_amount = 4;
            I_Pops();
            frame_rate_code = i_result;

            // (cite 1, P.41-42 Table 6-4)
            float frame_rate_value = 0;
            if (frame_rate_code == 0)
                println("Error - Forbidden Frame Rate Code");
            else if (frame_rate_code == 4) {
                // frame_rate_code 4
                frame_rate_value = 30000.0/1001.0;
            }
            else 
                println("Error - Program Limitation: Don't Know How to Handle Other Frame Rate Codes");
            i_amount = 18;
            I_Pops();
            bit_rate_value = i_result;

            {
              int marker_bit;
              i_amount = 1;
              I_Pops();
              marker_bit = i_result;

              if (marker_bit != 1)
              print("Error - Expected Marker Bit To Be Set");
            }

            i_amount = 10;
            I_Pops();
            vbv_buffer_size_value = i_result;

            i_amount = 1;
            I_Pops();
            constrained_parameters_flag = i_result;


            // (cite 1, P. 43)
            if (constrained_parameters_flag != 0)
                println("Error - Expected Constrained Parameters Flag To Be 0");
            // Default Values for the quantiser_matrices
            int[64] intra_quantiser_matrix = 
                { 8, 16, 19, 22, 26, 27, 29, 34,
                  16, 16, 22, 24, 27, 29, 34, 37,
                  19, 22, 26, 27, 29, 34, 34, 38,
                  22, 22, 26, 27, 29, 34, 37, 40,
                  22, 26, 27, 29, 32, 35, 40, 48,
                  26, 27, 29, 32, 35, 40, 48, 58,
                  26, 27, 29, 34, 38, 46, 56, 69,
                  27, 29, 35, 38, 46, 56, 69, 83};
            int[64] non_intra_quantiser_matrix =
                {16, 16, 16, 16, 16, 16, 16, 16,
                 16, 16, 16, 16, 16, 16, 16, 16,
                 16, 16, 16, 16, 16, 16, 16, 16,
                 16, 16, 16, 16, 16, 16, 16, 16,
                 16, 16, 16, 16, 16, 16, 16, 16,
                 16, 16, 16, 16, 16, 16, 16, 16,
                 16, 16, 16, 16, 16, 16, 16, 16,
                 16, 16, 16, 16, 16, 16, 16, 16};
            // Assumes no alternate_scan TODO
            int[64] Ordering = {00, 01, 05, 06, 14, 15, 27, 28,
                                02, 04, 07, 13, 16, 26, 29, 42,
                                03, 08, 12, 17, 25, 30, 41, 43,
                                09, 11, 18, 24, 31, 40, 44, 53,
                                10, 19, 23, 32, 39, 45, 52, 54,
                                20, 22, 33, 38, 46, 51, 55, 60,
                                21, 34, 37, 47, 50, 56, 59, 61,
                                35, 36, 48, 49, 57, 58, 62, 63};
            i_amount = 1;
            I_Pops();
            load_intra_quantiser_matrix = i_result;

            if (load_intra_quantiser_matrix == 1) {
                // println("  Loading Intra Quantiser Matrix from File");    
                int[64] tempOrder;
                for (int i = 0; i < 64; i++) {
                    i_amount = 8;
                    I_Pops();
                    tempOrder[i] = i_result;

                }
                for (int i = 0; i < 64; i++) {
                    // Assumes no alternate_scan TODO
                    intra_quantiser_matrix[i] = tempOrder[Ordering[i]];
                }
            } else {
                // println("  Using Default Intra Quantiser Matrix");
                // Default Values Previously Loaded
            }
            i_amount = 1;
            I_Pops();
            load_non_intra_quantiser_matrix = i_result;


            if (load_non_intra_quantiser_matrix == 1) {
                // println("  Loading Non Intra Quantiser Matrix from File");
                int[64] tempOrder;
                for (int i = 0; i < 64; i++) {
                    i_amount = 8;
                    I_Pops();
                    tempOrder[i] = i_result;

                }
                for (int i = 0; i < 64; i++) {
                    // Assumes no alternate_scan
                    non_intra_quantiser_matrix[i] = tempOrder[Ordering[i]];
                }
            } else {
                // println("  Using Default Non Intra Quantiser Matrix");
                // Default Values Previously Loaded
            }

            {
              int nsc_tempval;
              i_amount = 24;
              I_Peeks();
              nsc_tempval = i_result;

              while (nsc_tempval != 1) {
                i_amount = 1;
                I_Pops();
                nsc_tempval = i_result;

                // print("....looking for next_start_code....");
                i_amount = 24;
                I_Peeks();
                nsc_tempval = i_result;

              }
            }

            // sequence_extension() (cite 1, P. 28)

            i_amount = 32;
            I_Pops();
            tempval = i_result;

            if (tempval != 0x000001B5)
                println("Error - Expected Extension Start Code, File Must be MPEG-1 " + tempval);
            int extension_start_code_identifier, profile_and_level_indication,
                progressive_sequence, chroma_format, horizontal_size_extension,
                vertical_size_extension, bit_rate_extension, vbv_buffer_size_extension,
                low_delay, frame_rate_extension_n, frame_rate_extension_d;
            i_amount = 4;
            I_Pops();
            extension_start_code_identifier = i_result;


            if (extension_start_code_identifier != 0x1)
                println("Error - Expected Sequence Extension Identifier " + extension_start_code_identifier);
      
            i_amount = 8;
            I_Pops();
            profile_and_level_indication = i_result;


            // We don't really care about the profile_and_level indicator - this matters if this implementation
            // were fully MPEG2 compliant to some profile/level, but it isn't.
            i_amount = 1;
            I_Pops();
            progressive_sequence = i_result;


            if (progressive_sequence == 1) {
                // progressive_sequence 1: allows only progressive frames
            } else {
                // progressive_sequence 0: allows interlaced and progressive frames
                println("Error - Program Limitation: Don't handle interlaced frames");
            }
            i_amount = 2;
            I_Pops();
            chroma_format = i_result;

            int block_count = blocks_per_macroblock[the_chroma_format]; // (cite 1, P. 62)
            if (chroma_format != the_chroma_format) {
                println("Error - Program specified with chroma " + the_chroma_format);
                println("        File has chroma " + chroma_format);
            }
            i_amount = 2;
            I_Pops();
            horizontal_size_extension = i_result;

            int horizontal_size = horizontal_size_value + (horizontal_size_extension << 12);
            int mb_width = (horizontal_size + 15) / 16;
            i_amount = 2;
            I_Pops();
            vertical_size_extension = i_result;

            int vertical_size = vertical_size_value +  (vertical_size_extension << 12);
            int mb_height = (vertical_size + 15) / 16;
            i_amount = 12;
            I_Pops();
            bit_rate_extension = i_result;

            // (cite 1, P.42)
            int bit_rate = 400 * (bit_rate_value + (bit_rate_extension << 18));
            {
              int marker_bit;
              i_amount = 1;
              I_Pops();
              marker_bit = i_result;

              if (marker_bit != 1)
              print("Error - Expected Marker Bit To Be Set");
            }
            i_amount = 8;
            I_Pops();
            vbv_buffer_size_extension = i_result;

            int vbv_buffer_size = vbv_buffer_size_value + (vbv_buffer_size_extension << 10);
            i_amount = 1;
            I_Pops();
            low_delay = i_result;

            if (low_delay == 1) {
                // low_delay 1 indicates that sequence contains no B-pictures
                println("Error - Program Limitation: Can't Handle This Case Yet");
            } else {
                // low_delay 0 indicates that sequence is allowed to contain B-pictures
            }

            i_amount = 2;
            I_Pops();
            frame_rate_extension_n = i_result;

            i_amount = 5;
            I_Pops();
            frame_rate_extension_d = i_result;

            // (cite 1, P. P.41)
            float frame_rate = frame_rate_value * 
                ((float) (frame_rate_extension_n + 1)) / ((float) (frame_rate_extension_d + 1));
            {
              int nsc_tempval;
              i_amount = 24;
              I_Peeks();
              nsc_tempval = i_result;

              while (nsc_tempval != 1) {
                i_amount = 1;
                I_Pops();
                nsc_tempval = i_result;

                // print("....looking for next_start_code....");
                i_amount = 24;
                I_Peeks();
                nsc_tempval = i_result;

              }
            }

            boolean sequence_end_code_not_found = true;

            while (sequence_end_code_not_found) {
                // extension_and_user_data(0) (cite 1, P.26)
                i_amount = 32;
                I_Peeks();
                tempval = i_result;

                while (tempval == 0x000001B5 || tempval == 0x000001B2) {
                    i_amount = 32;
                    I_Pops();
                    tempval = i_result;

                    if (tempval == 0x000001B5) {
                        // extension_data(0) (cite 1, P.27)
                        i_amount = 4;
                        I_Peeks();
                        tempval = i_result;
 
                        if (tempval == 2) { // extension_start_code_identifier
                            i_amount = 4;
                            I_Pops();
                            tempval = i_result;
 
                            int video_format;
                            i_amount = 3;
                            I_Pops();
                            video_format = i_result;

                            int color_description;
                            i_amount = 1;
                            I_Pops();
                            color_description = i_result;

                            if (color_description == 1) {
                                int color_primaries, transfer_characteristics, matrix_coefficients;
                                i_amount = 8;
                                I_Pops();
                                color_primaries = i_result;

                                i_amount = 8;
                                I_Pops();
                                transfer_characteristics = i_result;

                                i_amount = 8;
                                I_Pops();
                                matrix_coefficients = i_result;

                            }
                            int display_horizontal_size;
                            i_amount = 14;
                            I_Pops();
                            display_horizontal_size = i_result;

                            {
                              int marker_bit;
                              i_amount = 1;
                              I_Pops();
                              marker_bit = i_result;

                              if (marker_bit != 1)
                              print("Error - Expected Marker Bit To Be Set");
                            }
                            int display_vertical_size;
                            i_amount = 14;
                            I_Pops();
                            display_vertical_size = i_result;

                            // TODO - we don't do anything with this extra data we get out. Eventually we should.
                            {
                              int nsc_tempval;
                              i_amount = 24;
                              I_Peeks();
                              nsc_tempval = i_result;

                              while (nsc_tempval != 1) {
                                i_amount = 1;
                                I_Pops();
                                nsc_tempval = i_result;

                                // print("....looking for next_start_code....");
                                i_amount = 24;
                                I_Peeks();
                                nsc_tempval = i_result;

                              }
                            }
                        } else {
                            println("Error - Program Limitation: Not Yet Support for Sequence Scalable Extension()");
                        }
                    } else { // user_data() (cite 1, P.27)      
                        if (tempval != 0x000001B2) {
                            println("Error - Program Limitation: Not Yet Support for User_Data()");
                        } 
                        i_amount = 24;
                        I_Peeks();
                        tempval = i_result;

                        while (tempval != 0x000001) {
                            int user_data;
                            i_amount = 8;
                            I_Pops();
                            user_data = i_result;

                            // TODO we should probably do something with this data
                            i_amount = 24;
                            I_Peeks();
                            tempval = i_result;

                        }
                        {
                          int nsc_tempval;
                          i_amount = 24;
                          I_Peeks();
                          nsc_tempval = i_result;

                          while (nsc_tempval != 1) {
                            i_amount = 1;
                            I_Pops();
                            nsc_tempval = i_result;

                            // print("....looking for next_start_code....");
                            i_amount = 24;
                            I_Peeks();
                            nsc_tempval = i_result;

                          }
                        }
                    }
                    i_amount = 32;
                    I_Peeks();
                    tempval = i_result;

                }
        
                boolean picture_or_group_start_code_found = true;
                while (picture_or_group_start_code_found) {
                    i_amount = 32;
                    I_Peeks();
                    tempval = i_result;

                    if (tempval == 0x000001B8) {
                        // group_of_pictures_header() (cite 1, P.29)
                        i_amount = 32;
                        I_Pops();
                        tempval = i_result;

                        int drop_frame_flag, time_code_hours, time_code_minutes, time_code_seconds, 
                            time_code_pictures, closed_gop, broken_link;
                        // -- Time Code - Not Used in Decoding Process --
                        // (cite 1, P.49)
                        i_amount = 1;
                        I_Pops();
                        drop_frame_flag = i_result;

                        i_amount = 5;
                        I_Pops();
                        time_code_hours = i_result;

                        i_amount = 6;
                        I_Pops();
                        time_code_minutes = i_result;

                        {
                          int marker_bit;
                          i_amount = 1;
                          I_Pops();
                          marker_bit = i_result;

                          if (marker_bit != 1)
                          print("Error - Expected Marker Bit To Be Set");
                        }
                        i_amount = 6;
                        I_Pops();
                        time_code_seconds = i_result;

                        i_amount = 6;
                        I_Pops();
                        time_code_pictures = i_result;

                        // -- End of Time Code
     
                        i_amount = 1;
                        I_Pops();
                        closed_gop = i_result;

                        i_amount = 1;
                        I_Pops();
                        broken_link = i_result;

                        if (broken_link == 1)
                            println("Error - Program Limitation: broken_link = 1");
                        {
                          int nsc_tempval;
                          i_amount = 24;
                          I_Peeks();
                          nsc_tempval = i_result;

                          while (nsc_tempval != 1) {
                            i_amount = 1;
                            I_Pops();
                            nsc_tempval = i_result;

                            // print("....looking for next_start_code....");
                            i_amount = 24;
                            I_Peeks();
                            nsc_tempval = i_result;

                          }
                        }
                        // extension_and_user_data(1) (cite 1, P.26)
                        i_amount = 32;
                        I_Peeks();
                        tempval = i_result;

                        if (tempval == 0x000001B5 || tempval == 0x000001B2)
                            println("Error - Program Limitation: Not Yet Support for extension_and_user_data(1)");
                    }
 
                    // picture_header() (cite 1, P.30)
                    i_amount = 32;
                    I_Pops();
                    tempval = i_result;

                    if (tempval != 0x00000100) {
                        println("Error - Picture Start Code Expected, " + tempval);
                    }

                    int temporal_reference, /* FEATURETODO picture_coding_type, */ vbv_delay, full_pel_forward_vector,
                        forward_f_code, full_pel_backward_vector, backward_f_code;
                    // (cite 1, P.50) for interpretation of the following fields
                    i_amount = 10;
                    I_Pops();
                    temporal_reference = i_result;

                    i_amount = 3;
                    I_Pops();
                    picture_coding_type = i_result;

                    if (picture_coding_type == 1) {
                        // picture_coding_type = I-picture
                    } else if (picture_coding_type == 2) {
                        // picture_coding_type = P-picture
                    } else if (picture_coding_type == 3) {
                        // picture_coding_type = B-picture
                    } else {
                        println("  Error: Forbidden picture_coding_type " + picture_coding_type);
                    }
 
                    i_amount = 16;
                    I_Pops();
                    vbv_delay = i_result;

                    // TODO unknown interpretation for vbv_delay, (cite 1, P.50)
                    // The following is not used by the MPEG-2 specification (cite 1, P.51)
                    // Supposed to have certain values, but not guaranteed for most files.
                    if (picture_coding_type == 2 || picture_coding_type == 3) {
                        i_amount = 1;
                        I_Pops();
                        full_pel_forward_vector = i_result;

                        i_amount = 3;
                        I_Pops();
                        forward_f_code = i_result;

                    } 
                    if (picture_coding_type == 3) {
                        i_amount = 1;
                        I_Pops();
                        full_pel_backward_vector = i_result;

                        i_amount = 3;
                        I_Pops();
                        backward_f_code = i_result;

                    }
                    i_amount = 1;
                    I_Pops();
                    tempval = i_result;

                    if (tempval == 1)
                        println("Error: File conforms to some superset of the MPEG-2 specification");
                    {
                      int nsc_tempval;
                      i_amount = 24;
                      I_Peeks();
                      nsc_tempval = i_result;

                      while (nsc_tempval != 1) {
                        i_amount = 1;
                        I_Pops();
                        nsc_tempval = i_result;

                        // print("....looking for next_start_code....");
                        i_amount = 24;
                        I_Peeks();
                        nsc_tempval = i_result;

                      }
                    }
            
                    // picture_coding_extension() (cite 1, P.30)
                    i_amount = 32;
                    I_Pops();
                    tempval = i_result;

                    if (tempval != 0x000001B5)
                        println("Error - Expecting extension start code " + tempval);
                    i_amount = 4;
                    I_Pops();
                    extension_start_code_identifier = i_result;

                    if (extension_start_code_identifier != 0x8)
                        println("Error - Expecting picture coding extension ID " + extension_start_code_identifier);
                    int[2][2] f_code;
                    i_amount = 4;
                    I_Pops();
                    f_code[0][0] = i_result;

                    i_amount = 4;
                    I_Pops();
                    f_code[0][1] = i_result;

                    i_amount = 4;
                    I_Pops();
                    f_code[1][0] = i_result;

                    i_amount = 4;
                    I_Pops();
                    f_code[1][1] = i_result;

                    // (cite 1, P.51)
                    for (int i = 0; i < 2; i++) {
                        for (int j = 0; j < 2; j++) {
                            if (f_code[i][j] == 0 || (f_code[i][j] >= 10 && f_code[i][j] <= 14))
                                println("Error - Invalid f_code");
                            if (picture_coding_type == 1 && f_code[i][j] != 0xF)
                                println("Error - Program Limitation: I-frame has motion prediction");
                            if (picture_coding_type == 2 && f_code[1][j] != 0xF)
                                println("Error - Program Limitation: P-frame has backward motion prediction");
                        }
                    }
                    int intra_dc_precision, picture_structure, top_field_first, frame_pred_frame_dct, 
                        concealment_motion_vectors, q_scale_type, intra_vlc_format, alternate_scan, 
                        repeat_first_field, chroma_420_type, progressive_frame, composite_display_flag;
                    i_amount = 2;
                    I_Pops();
                    intra_dc_precision = i_result;

                    int actual_intra_dc_precision = intra_dc_precision + 8;
                    i_amount = 2;
                    I_Pops();
                    picture_structure = i_result;

                    if (picture_structure != 3)
                        println("Error - Program Limitation: Interlaced or bad picture structure");
                    i_amount = 1;
                    I_Pops();
                    top_field_first = i_result;
 // Interpreted Later
                    i_amount = 1;
                    I_Pops();
                    frame_pred_frame_dct = i_result;

                    if (frame_pred_frame_dct != 1) 
                        println("Error - Program Limitation or Bad Syntax: frame_pred_frame_dct must be 1");
                    i_amount = 1;
                    I_Pops();
                    concealment_motion_vectors = i_result;

                    i_amount = 1;
                    I_Pops();
                    q_scale_type = i_result;

                    i_amount = 1;
                    I_Pops();
                    intra_vlc_format = i_result;

                    i_amount = 1;
                    I_Pops();
                    alternate_scan = i_result;

                    if (alternate_scan == 1)
                        println("Error - Program Limitation - Doesn't handle alternate_scan right now");
                    i_amount = 1;
                    I_Pops();
                    repeat_first_field = i_result;

                    // TODO Assumes progressive_sequence = 1
                    if (repeat_first_field == 0) {
                        //  repeat_first_field = 0, one frame output
                    }
                    else {
                        if (top_field_first == 0)
                            println("  repeat_first_field = 1, top_field_first = 0, two frames output");
                        else
                            println("  repeat_first_field = 1, top_field_first = 1, three frames output");
                    }
                    i_amount = 1;
                    I_Pops();
                    chroma_420_type = i_result;

                    // We don't really care about this, although it should be 1 for 4:2:0 chroma.
                    // (cite 1, P.53)
                    i_amount = 1;
                    I_Pops();
                    progressive_frame = i_result;

                    // Again, I don't think we care too much about this value, since we assume only a
                    // base stream exists.
                    i_amount = 1;
                    I_Pops();
                    composite_display_flag = i_result;

                    if (composite_display_flag == 1) {
                        println("Error - Program Limitation: Assumes no composite display information");
                    } else {
                        // composite_display_flag - not present
                    }
                    {
                      int nsc_tempval;
                      i_amount = 24;
                      I_Peeks();
                      nsc_tempval = i_result;

                      while (nsc_tempval != 1) {
                        i_amount = 1;
                        I_Pops();
                        nsc_tempval = i_result;

                        // print("....looking for next_start_code....");
                        i_amount = 24;
                        I_Peeks();
                        nsc_tempval = i_result;

                      }
                    }
         
                    // extension_and_user_data(2)
                    i_amount = 32;
                    I_Peeks();
                    tempval = i_result;

                    if (tempval == 0x000001B5 || tempval == 0x000001B2)
                        println("Error - Program Limitation: Not Yet Support for extension_and_user_data(2)");
          
                    // picture_data() (cite 1, P.34)
                    boolean slice_start_code_follows = true;
                    while (slice_start_code_follows) {
                        // slice() (cite 1, P.34)
                        // Reset motion vector predictors, (cite 1, P.77-80)
                        i_amount = 24;
                        I_Pops();
                        tempval = i_result;

                        if (tempval != 0x000001) 
                            println("Error - Expecting slice_start_code " + tempval);
                        int slice_vertical_position;
                        i_amount = 8;
                        I_Pops();
                        slice_vertical_position = i_result;

                        if (slice_vertical_position < 0x01 || slice_vertical_position > 0xAF)
                            println("Error - Invalid slice_vertical_position" + slice_vertical_position);
                        if (vertical_size > 2800)
                            println("Error - Program Limitation: Doesn't handle vertical_sizes > 2800");
                        int mb_row, previous_macroblock_address;
                        mb_row = slice_vertical_position - 1;
                        previous_macroblock_address = (mb_row * mb_width) - 1;
                        int quantiser_scale_code;
                        i_amount = 5;
                        I_Pops();
                        quantiser_scale_code = i_result;

                        i_amount = 1;
                        I_Peeks();
                        tempval = i_result;

                        if (tempval == 1)
                            println("Error - Program Limitation: Doesn't handle intra_slice_flag");
                        i_amount = 1;
                        I_Pops();
                        tempval = i_result;

                        if (tempval == 1)
                            println("Error - Extra_bit_slice must be 0");
                        int[3] dc_dct_pred; // (cite 1, P.64-65)
                        // I'm not sure about this - see P. 64 and getpic.c Line 1180
                        // they disagree TODO
                        dc_dct_pred[0] = 0; // (int) pow(2,actual_intra_dc_precision - 1);
                        dc_dct_pred[1] = 0; // (int) pow(2,actual_intra_dc_precision - 1);
                        dc_dct_pred[2] = 0; // (int) pow(2,actual_intra_dc_precision - 1);
                        boolean macroblock_next = true;

                        while (macroblock_next) {
                            // macroblock() (cite 1, P.35)
                            int macroblock_escape = 0;
                            i_amount = 11;
                            I_Peeks();
                            tempval = i_result;

                            while (tempval == 8) {
                                i_amount = 11;
                                I_Pops();
                                tempval = i_result;

                                macroblock_escape += 33;
                                i_amount = 11;
                                I_Peeks();
                                tempval = i_result;

                            }
              
                            {
                              boolean found = false;
                              int guesslength = 1;
                              int tablepos = 0;
                              while (!found) {
                                i_amount = guesslength;
                                I_Peeks();
                                tempval = i_result;

                                tablepos = 0;
                                while (!found && tablepos < const_macroblock_address_inc_len) {
                                  if (tempval == const_macroblock_address_inc[tablepos].code && guesslength == const_macroblock_address_inc[tablepos].len) {
                                    found = true;
                                    i_amount = guesslength;
                                    I_Pops();
                                    tempval = i_result;

                                  } else {
                                  tablepos++;
                                }
                                }
                                guesslength++;
                              }
                              tempval = const_macroblock_address_inc[tablepos].value;
                            }
                            int macroblock_address_increment = tempval + macroblock_escape;         
                            int macroblock_address, mb_column;
                            macroblock_address = previous_macroblock_address + macroblock_address_increment;
                            previous_macroblock_address = macroblock_address;
                            mb_column = macroblock_address % mb_width;
                            // TODO - Don't actually check to make sure that macroblocks are skipped which aren't
                            // allowed to be skipped - this should be done, the rules are on (cite 1, P.60)
                            // macroblock_modes, (cite 1, P.36)
                            // TODO - If a sequence_scalable_extension present in bitstream, then may possibly
                            // need to use tables B5,6,7,8 as well.
                            if (picture_coding_type == 1) { // I-picture
                                {
                                  boolean found = false;
                                  int guesslength = 1;
                                  int tablepos = 0;
                                  while (!found) {
                                    i_amount = guesslength;
                                    I_Peeks();
                                    tempval = i_result;

                                    tablepos = 0;
                                    while (!found && tablepos < const_macroblock_type_Ipictures_len) {
                                      if (tempval == const_macroblock_type_Ipictures[tablepos].code && guesslength == const_macroblock_type_Ipictures[tablepos].len) {
                                        found = true;
                                        i_amount = guesslength;
                                        I_Pops();
                                        tempval = i_result;

                                      } else {
                                      tablepos++;
                                    }
                                    }
                                    guesslength++;
                                  }
                                  tempval = const_macroblock_type_Ipictures[tablepos].value;
                                }
                            } else if (picture_coding_type == 2) { // P-picture
                                {
                                  boolean found = false;
                                  int guesslength = 1;
                                  int tablepos = 0;
                                  while (!found) {
                                    i_amount = guesslength;
                                    I_Peeks();
                                    tempval = i_result;

                                    tablepos = 0;
                                    while (!found && tablepos < const_macroblock_type_Ppictures_len) {
                                      if (tempval == const_macroblock_type_Ppictures[tablepos].code && guesslength == const_macroblock_type_Ppictures[tablepos].len) {
                                        found = true;
                                        i_amount = guesslength;
                                        I_Pops();
                                        tempval = i_result;

                                      } else {
                                      tablepos++;
                                    }
                                    }
                                    guesslength++;
                                  }
                                  tempval = const_macroblock_type_Ppictures[tablepos].value;
                                }
                            } else if (picture_coding_type == 3) { // B-picture
                                {
                                  boolean found = false;
                                  int guesslength = 1;
                                  int tablepos = 0;
                                  while (!found) {
                                    i_amount = guesslength;
                                    I_Peeks();
                                    tempval = i_result;

                                    tablepos = 0;
                                    while (!found && tablepos < const_macroblock_type_Bpictures_len) {
                                      if (tempval == const_macroblock_type_Bpictures[tablepos].code && guesslength == const_macroblock_type_Bpictures[tablepos].len) {
                                        found = true;
                                        i_amount = guesslength;
                                        I_Pops();
                                        tempval = i_result;

                                      } else {
                                      tablepos++;
                                    }
                                    }
                                    guesslength++;
                                  }
                                  tempval = const_macroblock_type_Bpictures[tablepos].value;
                                }
                            }
                            int macroblock_quant, /* macroblock_motion_forward, macroblock_motion_backward, */
                                macroblock_pattern, /* macroblock_intra, */ spatial_temporal_weight_code_flag;
                            spatial_temporal_weight_code_flag = tempval & 0x01;
                            tempval >>= 1;
                            macroblock_intra = tempval & 0x01;
                            tempval >>= 1;
                            macroblock_pattern = tempval & 0x01;
                            tempval >>= 1;
                            macroblock_motion_backward = tempval & 0x01;
                            tempval >>= 1;
                            macroblock_motion_forward = tempval & 0x01;
                            tempval >>= 1;
                            macroblock_quant = tempval & 0x01;

                            if (spatial_temporal_weight_code_flag == 1)
                                println("Error - Program Limitation - Expects spatial_temporal_weight_code_flag to be 0");
                            // (cite 1, P.60, Table 6-17)
                            int prediction_type = 0; // 0 = reserved, 1 = field-based, 2=frame-based, 3=dual-prime
                            int motion_vector_count = 0;
                            int mv_format = 0; // 0 = field, 1 = frame
                            int dmv = 0; 
                            if (frame_pred_frame_dct == 1) {
                                // See comments on P.60 regarding what happens if frame_motion_type
                                // is omitted.
                                prediction_type = 2;
                                motion_vector_count = 1;
                                mv_format = 1;
                                dmv = 0;
                            }
                            if (macroblock_motion_forward == 1 || macroblock_motion_backward == 1) {
                                if (picture_structure == 3) {
                                    if (frame_pred_frame_dct == 0) {
                                        // (cite 1, P.60, Table 6-17)
                                        i_amount = 2;
                                        I_Pops();
                                        tempval = i_result;

                                        if (tempval == 0) {
                                            println("Error - Invalid frame_motion_type code");
                                        } else if (tempval == 1) {
                                            if (spatial_temporal_weight_code_flag < 2) {
                                                println("Error - Don't handle this case of frame_motion_type");
                                            } else {
                                                println("Error - Don't handle this case of frame_motion_type");
                                            }
                                        } else if (tempval == 2) {
                                            prediction_type = 2;
                                            motion_vector_count = 1;
                                            mv_format = 1;
                                            dmv = 0;
                                        } else if (tempval == 3) {
                                            prediction_type = 3;
                                            motion_vector_count = 1;
                                            mv_format = 0;
                                            dmv = 1;
                                        }
                                        if (prediction_type == 0)
                                            println("Error - Invalid prediction_type");
                                        else if (prediction_type == 1)
                                            println("  prediction_type field-based");
                                        else if (prediction_type == 2)
                                            println("  prediction_type frame-based");
                                        else if (prediction_type == 3)
                                            println("  prediction_type dual-prime");
                                        println("  motion_vector_count " + motion_vector_count);
                                        if (mv_format == 0)
                                            println("  mv_format field");
                                        else
                                            println("  mv_format frame");
                                        println("  dmv " + dmv);
                                    }
                                } else {
                                    println("Error - Program Limitation: Doesn't handle this case");
                                }
                            }
                            if ((picture_structure == 3) && (frame_pred_frame_dct == 0) && ((macroblock_intra == 1) || (macroblock_pattern == 1)))
                                println("Error - Program Limitation, Doesn't Handle This Particular Case");

                            if (macroblock_quant == 1) {
                                i_amount = 5;
                                I_Pops();
                                quantiser_scale_code = i_result;

                            }

                            /*            int[2][2][2] motion_code;
                                          int[2][2][2] motion_residual; FEATURETODO */
                            for (int i = 0; i < 2; i++)
                                for (int j = 0; j < 2; j++)
                                    for (int k = 0; k < 2; k++) {
                                        motion_code[i][j][k] = 0;
                                        motion_residual[i][j][k] = 0;
                                    }

                            // Motion Vector Predictor Reset, (cite 1, P.80)
                            if ((macroblock_intra == 1 && concealment_motion_vectors == 0) ||
                                (macroblock_intra == 0 && macroblock_motion_forward == 0 && 
                                 picture_coding_type == 2)) {
                            }

                            if (macroblock_motion_forward == 1 || 
                                (macroblock_intra == 1 && concealment_motion_vectors == 1)) {
                                // motion_vectors(0); (cite 1, P.36, 61)
                                if (motion_vector_count == 1) {
                                    if ((mv_format == 0) && (dmv != 1)) {
                                        println("Error - Program Limitation: Don't handle this case with mv_format and dmv.");
                                        println("mv_format " + mv_format + " dmv " + dmv);
                                    }
                                    // motion_vector(0,0);
                                    // (cite 1, P.61)
                                    for (int t = 0; t < 2; t++) {
                                        {
                                          boolean found = false;
                                          int guesslength = 1;
                                          int tablepos = 0;
                                          while (!found) {
                                            i_amount = guesslength;
                                            I_Peeks();
                                            motion_code[0][0][t] = i_result;

                                            tablepos = 0;
                                            while (!found && tablepos < const_motion_code_len) {
                                              if (motion_code[0][0][t] == const_motion_code[tablepos].code && guesslength == const_motion_code[tablepos].len) {
                                                found = true;
                                                i_amount = guesslength;
                                                I_Pops();
                                                motion_code[0][0][t] = i_result;

                                              } else {
                                              tablepos++;
                                            }
                                            }
                                            guesslength++;
                                          }
                                          motion_code[0][0][t] = const_motion_code[tablepos].value;
                                        }
                                        if ((f_code[0][t] != 1) && (motion_code[0][0][t] != 0)) {
                                            int r_size = f_code[0][t]-1;
                                            i_amount = r_size;
                                            I_Pops();
                                            motion_residual[0][0][t] = i_result;

                                        }
                                        if (dmv == 1) {
                                            println("Error - Program Limitation: Don't handle case of dmv = 1");
                                        }
                                    } 
                
                                } else {
                                    println("Error - Program Limitation: Don't handle field motion vectors");
                                }
                            }
                            if (macroblock_motion_backward == 1) {
                
                                // motion_vectors(1); (cite 1, P.36, 61)
                                if (motion_vector_count == 1) {
                                    if ((mv_format == 0) && (dmv != 1)) {
                                        println("Error - Program Limitation: Don't handle this case with mv_format and dmv.");
                                        println("mv_format " + mv_format + " dmv " + dmv);
                                    }
                                    // motion_vector(0,1);
                                    // (cite 1, P.61)
                                    for (int t = 0; t < 2; t++) {
                                        {
                                          boolean found = false;
                                          int guesslength = 1;
                                          int tablepos = 0;
                                          while (!found) {
                                            i_amount = guesslength;
                                            I_Peeks();
                                            motion_code[0][1][t] = i_result;

                                            tablepos = 0;
                                            while (!found && tablepos < const_motion_code_len) {
                                              if (motion_code[0][1][t] == const_motion_code[tablepos].code && guesslength == const_motion_code[tablepos].len) {
                                                found = true;
                                                i_amount = guesslength;
                                                I_Pops();
                                                motion_code[0][1][t] = i_result;

                                              } else {
                                              tablepos++;
                                            }
                                            }
                                            guesslength++;
                                          }
                                          motion_code[0][1][t] = const_motion_code[tablepos].value;
                                        }
                                        if ((f_code[1][t] != 1) && (motion_code[0][1][t] != 0)) {
                                            int r_size = f_code[1][t]-1;
                                            i_amount = r_size;
                                            I_Pops();
                                            motion_residual[0][1][t] = i_result;

                                        }
                                        if (dmv == 1) {
                                            println("Error - Program Limitation: Don't handle the case of dmv = 1");
                                        }
                                    }
                                }
                            }

                            if (macroblock_intra == 1 && concealment_motion_vectors == 1) {
                                {
                                  int marker_bit;
                                  i_amount = 1;
                                  I_Pops();
                                  marker_bit = i_result;

                                  if (marker_bit != 1)
                                  print("Error - Expected Marker Bit To Be Set");
                                }
                            }

                            int[12] pattern_code;
                            // The meaning of pattern_code is defined somewhat poorly
                            // on (cite 1, P.62) in the code block
                            for (int i = 0; i < 12; i++) {
                                if (macroblock_intra == 1) {
                                    pattern_code[i] = 1;
                                } else {
                                    pattern_code[i] = 0;
                                }
                            }
                            if (macroblock_pattern == 1) {
                                // coded_block_pattern() (cite 1, P.37, 62)
                                int cbp;
                                {
                                  boolean found = false;
                                  int guesslength = 1;
                                  int tablepos = 0;
                                  while (!found) {
                                    i_amount = guesslength;
                                    I_Peeks();
                                    cbp = i_result;

                                    tablepos = 0;
                                    while (!found && tablepos < const_coded_block_patterns_len) {
                                      if (cbp == const_coded_block_patterns[tablepos].code && guesslength == const_coded_block_patterns[tablepos].len) {
                                        found = true;
                                        i_amount = guesslength;
                                        I_Pops();
                                        cbp = i_result;

                                      } else {
                                      tablepos++;
                                    }
                                    }
                                    guesslength++;
                                  }
                                  cbp = const_coded_block_patterns[tablepos].value;
                                }
                                for (int i = 0; i < 6; i++) {
                                    if ((cbp & (1 << (5-i))) > 0)
                                        pattern_code[i] = 1;
                                }
                                if (chroma_format == 1 && cbp == 0) {
                                    println("Error - cbp not allowed to be zero in 4:2:0 format");
                                }
                                if (chroma_format == 2) {
                                    int coded_block_pattern_1;
                                    i_amount = 2;
                                    I_Pops();
                                    coded_block_pattern_1 = i_result;

                                    for (int i = 6; i < 8; i++) {
                                        if ((coded_block_pattern_1 & (1<< (7-i))) > 0)
                                            pattern_code[i] = 1;
                                    }
                                }
                                if (chroma_format == 3) {
                                    println("Error - Program Limitation: Doesn't handle 4:4:4 format");
                                }
                            }

                            for (int i = 0; i < block_count; i++) {
                                int QFS_current;
                                QFS_current = 0;
                                for (int j = 0; j < 64; j++) {
                                    QFS[i][j] = 0;
                                } 

                                // block(i) (cite 1, P.38)
                                // if macroblocks are skipped, predictor is reset
                                if (pattern_code[i] == 1) {
                                    if (macroblock_intra == 1) {
                                        if (i < 4) {
                                            int dc_dct_size_luminance, dc_dct_differential_luminance, dc_dct_luminance;
                                            {
                                              boolean found = false;
                                              int guesslength = 1;
                                              int tablepos = 0;
                                              while (!found) {
                                                i_amount = guesslength;
                                                I_Peeks();
                                                dc_dct_size_luminance = i_result;

                                                tablepos = 0;
                                                while (!found && tablepos < const_dct_dc_size_luminance_len) {
                                                  if (dc_dct_size_luminance == const_dct_dc_size_luminance[tablepos].code && guesslength == const_dct_dc_size_luminance[tablepos].len) {
                                                    found = true;
                                                    i_amount = guesslength;
                                                    I_Pops();
                                                    dc_dct_size_luminance = i_result;

                                                  } else {
                                                  tablepos++;
                                                }
                                                }
                                                guesslength++;
                                              }
                                              dc_dct_size_luminance = const_dct_dc_size_luminance[tablepos].value;
                                            }
                                            int dct_diff; // This next section from (cite 1, P.65)
                                            if (dc_dct_size_luminance == 0) {
                                                dct_diff = 0;
                                            } else {
                                                i_amount = dc_dct_size_luminance;
                                                I_Pops();
                                                dc_dct_differential_luminance = i_result;

                                                int half_range = (int) pow(2,dc_dct_size_luminance-1);
                                                if (dc_dct_differential_luminance >= half_range) {
                                                    dct_diff = dc_dct_differential_luminance;
                                                } else {
                                                    dct_diff = (dc_dct_differential_luminance + 1) - (2*half_range);
                                                }
                                            }
                                            dc_dct_luminance = dc_dct_pred[0] + dct_diff;
                                            dc_dct_pred[0] = dc_dct_luminance;
                                            QFS[i][0] = dc_dct_luminance;
                                            QFS_current = 1;
                                        } else {
                                            // Other ones 
                                            int dc_dct_size_chrominance, dc_dct_differential_chrominance, dc_dct_chrominance;
                                            {
                                              boolean found = false;
                                              int guesslength = 1;
                                              int tablepos = 0;
                                              while (!found) {
                                                i_amount = guesslength;
                                                I_Peeks();
                                                dc_dct_size_chrominance = i_result;

                                                tablepos = 0;
                                                while (!found && tablepos < const_dct_dc_size_chrominance_len) {
                                                  if (dc_dct_size_chrominance == const_dct_dc_size_chrominance[tablepos].code && guesslength == const_dct_dc_size_chrominance[tablepos].len) {
                                                    found = true;
                                                    i_amount = guesslength;
                                                    I_Pops();
                                                    dc_dct_size_chrominance = i_result;

                                                  } else {
                                                  tablepos++;
                                                }
                                                }
                                                guesslength++;
                                              }
                                              dc_dct_size_chrominance = const_dct_dc_size_chrominance[tablepos].value;
                                            }
                                            int dct_diff;
                                            if (dc_dct_size_chrominance == 0) {
                                                dct_diff = 0;
                                            } else {
                                                i_amount = dc_dct_size_chrominance;
                                                I_Pops();
                                                dc_dct_differential_chrominance = i_result;

                                                int half_range = (int) pow(2,dc_dct_size_chrominance-1);
                                                if (dc_dct_differential_chrominance >= half_range) {
                                                    dct_diff = dc_dct_differential_chrominance;
                                                } else {
                                                    dct_diff = (dc_dct_differential_chrominance + 1) - (2*half_range);
                                                }
                                            }
                                            // Blocks 4, 6, 8, and 10 go into [1]
                                            // Blocks 5, 7, 9, 11 go into [2]
                                            int temp_index = (i % 2) + 1;
                                            dc_dct_chrominance = dc_dct_pred[temp_index] + dct_diff;
                                            dc_dct_pred[temp_index] = dc_dct_chrominance;
                                            QFS[i][0] = dc_dct_chrominance;
                                            QFS_current = 1;
                                        }
                                    } else {
                                        // I don't think we really need to do anything here... if we let this just
                                        // fall through it should get handled in the next section, right?
                                        // Reset predictors, (cite 1, P. 64)
                                        dc_dct_pred[0] = 0;
                                        dc_dct_pred[1] = 0;
                                        dc_dct_pred[2] = 0;  
                                    }
                                    if (intra_vlc_format == 1 && macroblock_intra == 1)
                                        println("Error - Program Limitation: Need to use B15 to decode DCT coefficients instead of B14");
                                    while (QFS_current < 64) {
                                        if (macroblock_intra == 0 && QFS_current == 0) {
                                            // This section here from end of Table B.14 and 7.2.2.2 (cite 1, P.66)
                                            i_amount = 1;
                                            I_Peeks();
                                            tempval = i_result;

                                            if (tempval == 1) {
                                                i_amount = 1;
                                                I_Pops();
                                                tempval = i_result;

                                                i_amount = 1;
                                                I_Pops();
                                                tempval = i_result;

                                                if (tempval == 0)
                                                    QFS[i][0] = 1;
                                                else 
                                                    QFS[i][0] = -1;
                                                QFS_current += 1;
                                            }
                                        } 
                                        i_amount = 2;
                                        I_Peeks();
                                        tempval = i_result;

                                        if (tempval == 2) {
                                            i_amount = 2;
                                            I_Pops();
                                            tempval = i_result;

                                            QFS_current = 64;
                                        } else {
                                            int signed_level, run = 0;
                                            i_amount = 6;
                                            I_Peeks();
                                            tempval = i_result;

                                            if (tempval == 1) { 
                                                // Escape Code
                                                i_amount = 6;
                                                I_Pops();
                                                tempval = i_result;

                                                int level, sign;
                                                i_amount = 6;
                                                I_Pops();
                                                run = i_result;

                                                i_amount = 1;
                                                I_Pops();
                                                sign = i_result;

                                                i_amount = 11;
                                                I_Pops();
                                                level = i_result;

                                                if (sign == 0) {
                                                    signed_level = level;
                                                } else {
                                                    signed_level = level - 2048;
                                                }
                                            } else {
                                                // Regular Code
                                                int level = 0, sign = 0;
                                                // begin variable length code
                                                i_amount = 16;
                                                I_Peeks();
                                                tempval = i_result;

                                                // if (tempval >= 49152 && tempval <= 65535) { // 2
                                                if (tempval >= 49152) {
                                                    i_amount = 2;
                                                    I_Pops();
                                                    tempval = i_result;

                                                    run = const_dct_coefficients_table_zero_len2[0].run;
                                                    level = const_dct_coefficients_table_zero_len2[0].level; 
                                                    // } else if (tempval >= 24576 && tempval <= 32767) { // 3
                                                } else if (tempval >= 24576) {
                                                    i_amount = 3;
                                                    I_Pops();
                                                    tempval = i_result;

                                                    run = const_dct_coefficients_table_zero_len3[0].run;
                                                    level = const_dct_coefficients_table_zero_len3[0].level; 
                                                    // } else if (tempval >= 16384 && tempval <= 24575) { // 4
                                                } else if (tempval >= 16384) {
                                                    i_amount = 4;
                                                    I_Pops();
                                                    tempval = i_result;

                                                    run = const_dct_coefficients_table_zero_len4[tempval-4].run;
                                                    level = const_dct_coefficients_table_zero_len4[tempval-4].level; 
                                                    // } else if (tempval >= 10240 && tempval <= 16383) { // 5
                                                } else if (tempval >= 10240) {
                                                    i_amount = 5;
                                                    I_Pops();
                                                    tempval = i_result;

                                                    run = const_dct_coefficients_table_zero_len5[tempval-5].run;
                                                    level = const_dct_coefficients_table_zero_len5[tempval-5].level; 
                                                    // } else if (tempval >= 8192 && tempval <= 10239) { // 8
                                                } else if ( tempval >= 8192) {
                                                    i_amount = 8;
                                                    I_Pops();
                                                    tempval = i_result;

                                                    run = const_dct_coefficients_table_zero_len8[tempval-32].run;
                                                    level = const_dct_coefficients_table_zero_len8[tempval-32].level; 
                                                    // } else if (tempval >= 4096 && tempval <= 8191) { // 6
                                                } else if (tempval >= 4096) {
                                                    i_amount = 6;
                                                    I_Pops();
                                                    tempval = i_result;

                                                    run = const_dct_coefficients_table_zero_len6[tempval-4].run;
                                                    level = const_dct_coefficients_table_zero_len6[tempval-4].level; 
                                                    // } else if (tempval >= 2048 && tempval <= 4095) { // 7
                                                } else if (tempval >= 2048) {
                                                    i_amount = 7;
                                                    I_Pops();
                                                    tempval = i_result;

                                                    run = const_dct_coefficients_table_zero_len7[tempval-4].run;
                                                    level = const_dct_coefficients_table_zero_len7[tempval-4].level; 
                                                    // } else if (tempval >= 512 && tempval <= 1023) { // 10
                                                } else if (tempval >= 512) {
                                                    i_amount = 10;
                                                    I_Pops();
                                                    tempval = i_result;

                                                    run = const_dct_coefficients_table_zero_len10[tempval-8].run;
                                                    level = const_dct_coefficients_table_zero_len10[tempval-8].level; 
                                                    // } else if (tempval >= 256 && tempval <= 511) { // 12
                                                } else if (tempval >= 256) {
                                                    i_amount = 12;
                                                    I_Pops();
                                                    tempval = i_result;
 
                                                    run = const_dct_coefficients_table_zero_len12[tempval-16].run;
                                                    level = const_dct_coefficients_table_zero_len12[tempval-16].level; 
                                                    // } else if (tempval >= 128 && tempval <= 255) { // 13
                                                } else if (tempval >= 128) {
                                                    i_amount = 13;
                                                    I_Pops();
                                                    tempval = i_result;
 
                                                    run = const_dct_coefficients_table_zero_len13[tempval-16].run;
                                                    level = const_dct_coefficients_table_zero_len13[tempval-16].level; 
                                                    // } else if (tempval >= 64 && tempval <= 127) { // 14
                                                } else if (tempval >= 64) {
                                                    i_amount = 14;
                                                    I_Pops();
                                                    tempval = i_result;
 
                                                    run = const_dct_coefficients_table_zero_len14[tempval-16].run;
                                                    level = const_dct_coefficients_table_zero_len14[tempval-16].level; 
                                                    // } else if (tempval >= 32 && tempval <= 63) { // 15
                                                } else if (tempval >= 32) {
                                                    i_amount = 15;
                                                    I_Pops();
                                                    tempval = i_result;
 
                                                    run = const_dct_coefficients_table_zero_len15[tempval-16].run;
                                                    level = const_dct_coefficients_table_zero_len15[tempval-16].level; 
                                                    // } else if (tempval >= 16 && tempval <= 31) { // 16
                                                } else if (tempval >= 16) {
                                                    i_amount = 16;
                                                    I_Pops();
                                                    tempval = i_result;

                                                    run = const_dct_coefficients_table_zero_len16[tempval-16].run;
                                                    level = const_dct_coefficients_table_zero_len16[tempval-16].level; 
                                                }  else {
                                                    print("Error - Unknown Huffman Symbol");
                                                }

                                                // end variable length code
                                                i_amount = 1;
                                                I_Pops();
                                                sign = i_result;

                                                if (sign == 0) {
                                                    signed_level = level;
                                                } else {
                                                    signed_level = -level;
                                                }
                                            }
                                            QFS_current += run;
                                            if (QFS_current == 63) {
                                                i_amount = 2;
                                                I_Pops();
                                                tempval = i_result;

                                                if (tempval != 2) {
                                                    println("Error - Reached End of Block, Expecting End of Block Code");
                                                }
                                            }
                                            QFS[i][QFS_current] = signed_level;
                                            QFS_current++;
                                        }
                                        if (QFS_current > 64)
                                            println("Error - QFS_current > 64 " + QFS_current);
                                    }
                                } else {
                                    // Skipped block
                                    // This indicates a skipped block, but not a skipped macroblock. 
                                    for (int index = 0; index < 64; index++) {
                                        QFS[i][index] = 0;
                                    }
                                }
                            }
                            PushMacroblock();
                            i_amount = 23;
                            I_Peeks();
                            tempval = i_result;

                            if (tempval == 0) {
                                macroblock_next = false;
                            } else {
                                macroblock_next = true;
                            }
                        }
 
                        {
                          int nsc_tempval;
                          i_amount = 24;
                          I_Peeks();
                          nsc_tempval = i_result;

                          while (nsc_tempval != 1) {
                            i_amount = 1;
                            I_Pops();
                            nsc_tempval = i_result;

                            // print("....looking for next_start_code....");
                            i_amount = 24;
                            I_Peeks();
                            nsc_tempval = i_result;

                          }
                        }
                        i_amount = 32;
                        I_Peeks();
                        tempval = i_result;

                        if (tempval > 0x000001AF || tempval < 0x00000101)
                            slice_start_code_follows = false;
                        else
                            slice_start_code_follows = true;
                    }
                    {
                      int nsc_tempval;
                      i_amount = 24;
                      I_Peeks();
                      nsc_tempval = i_result;

                      while (nsc_tempval != 1) {
                        i_amount = 1;
                        I_Pops();
                        nsc_tempval = i_result;

                        // print("....looking for next_start_code....");
                        i_amount = 24;
                        I_Peeks();
                        nsc_tempval = i_result;

                      }
                    }
                    i_amount = 32;
                    I_Peeks();
                    tempval = i_result;


                    if (tempval == 0x00000100 || tempval == 0x000001B8) {
                        picture_or_group_start_code_found = true;
                    } else {
                        picture_or_group_start_code_found = false;
                    }

                }

                i_amount = 32;
                I_Peeks();
                tempval = i_result;

                if (tempval != 0x000001B7) {
                    println("Error - Program Limitation: Don't handle repeated sequence headers and sequence extensions");
                }
  
                if (tempval != 0x000001B7) {
                    sequence_end_code_not_found = true;
                } else {
                    sequence_end_code_not_found = false;
                }
            }
            println("Done Parsing M2V File...");
            println("Generating fake last frame to push out last real frame of video.");
            ran = 2;
            for (int i = 0; i < blocks_per_macroblock[the_chroma_format]; i++) {
                for (int j = 0; j < 64; j++) {
                    QFS[i][j] = 0;
                }
            }
            for (int r = 0; r < 2; r++) 
                for (int s = 0; s < 2; s++)
                    for (int t = 0; t < 2; t++) {
                        motion_code[r][s][t] = 0;
                    }
            for (int r = 0; r < 2; r++) 
                for (int s = 0; s < 2; s++)
                    for (int t = 0; t < 2; t++) {
                        motion_residual[r][s][t] = 0;
                    }
            macroblock_intra = 1;
            macroblock_motion_forward = 0;
            macroblock_motion_backward = 0;
            for (int i = 0; i < (width/16); i++) {
                for (int j = 0; j < (height/16); j++) {
                    PushMacroblock();
                } 
            }
            println("Done generating fake frame");
        }
    }
}

/**
 * @internal
 */
int->int pipeline BlockDecode() {
    add ZigZagUnordering;
    // Assumes no alternate_scan TODO
    // Output of this corresponds to QF[v][u], (cite 1, P. 67)
    add InverseQuantization();
    add BestSaturation(-2048, 2047, -2050, 2050);
    add MismatchControl();
    add iDCT8x8_ieee(3); // 0 = reference coarse, 1 = reference fine, 2 = fast, fine,  
    add BestSaturation(-256, 255, -260, 260);
}

/**
 * @internal
 */
int->int filter ZigZagUnordering {
    int[64] Ordering = {00, 01, 05, 06, 14, 15, 27, 28,
                        02, 04, 07, 13, 16, 26, 29, 42,
                        03, 08, 12, 17, 25, 30, 41, 43,
                        09, 11, 18, 24, 31, 40, 44, 53,
                        10, 19, 23, 32, 39, 45, 52, 54,
                        20, 22, 33, 38, 46, 51, 55, 60,
                        21, 34, 37, 47, 50, 56, 59, 61,
                        35, 36, 48, 49, 57, 58, 62, 63};
    work pop 64 push 64 {
        int[64] peekSubstitute;
        for (int i = 0; i < 64; i++) {
            peekSubstitute[i] = pop();
        }
        for (int i = 0; i < 64; i++) {
            push(peekSubstitute[Ordering[i]]);
        }
    }
}

/**
 * @internal
 */
int->int pipeline InverseQuantization() {

    // The handling of the intra DC coefficient is described on (cite 1, P.69)
    add int->int splitjoin {
        split duplicate;
        // Intra Coded Macroblocks
        add int->int splitjoin {
            split roundrobin(1, 63); 
            add InverseQuantization_DC_Intra_Coeff; // (cite 1, P.69)
            add InverseQuantization_AC_Coeff(1);
            join roundrobin(1, 63); 
        }
        // Non Intra Coded Macroblocks
        add InverseQuantization_AC_Coeff(0);
        join roundrobin(64, 64);  
    }
  
    // Selects which stream - FEATURETODO eventually programmable splitjoin and only one of the two
    // above branches gets taken instead of both.
 
    add InverseQuantizationJoinerSubstitute();
}

/**
 * @internal
 */
int->int filter InverseQuantizationJoinerSubstitute {
    int macroblock_intra;
 
    init {
        macroblock_intra = 1;
    }
   
    work pop (128) push 64 {
        if (macroblock_intra == -1) {
            println("  Error: macroblock_intra should not be -1, should have recieved update message");
        } else if (macroblock_intra == 1) {
            // It was Intra Coded
            for (int i = 0; i < 64; i++) {
                push(pop());
            }
            for (int i = 0; i < 64; i++) {
                pop();
            }
        } else {
            // It was Non Intra Coded
            for (int i = 0; i < 64; i++) {
                pop();
            }
            for (int i = 0; i < 64; i++) {
                push(pop());
            }
        }
    
    } 

}


/**
 * @internal
 */
int->int filter InverseQuantization_DC_Intra_Coeff() {
    // (cite 1, P.69)
    int[4] intra_dc_mult;
    int intra_dc_precision;

    init {
        intra_dc_mult[0] = 8;
        intra_dc_mult[1] = 4;
        intra_dc_mult[2] = 2;
        intra_dc_mult[3] = 1;
        intra_dc_precision = 0; 
    }

    work pop 1 push 1 {
        push(intra_dc_mult[intra_dc_precision] * pop());
    }

}

/**
 * @internal
 */
int->int filter InverseQuantization_AC_Coeff(int macroblock_intra) {
    // Assumes 4:2:0 data
    // (cite 1, P.69)
    // intra = 1: This is dequantizing the non-DC part of an intra coded block
    // intra = 0: This is dequantizing the DC and AC part of a non-intra coded block

    // These are all assigned by messages and MUST be assigned before the first 
    // call to work()
    int quantiser_scale_code;
    int q_scale_type;
    int[64] intra_quantiser_matrix = { 8, 16, 19, 22, 26, 27, 29, 34,
                                       16, 16, 22, 24, 27, 29, 34, 37,
                                       19, 22, 26, 27, 29, 34, 34, 38,
                                       22, 22, 26, 27, 29, 34, 37, 40,
                                       22, 26, 27, 29, 32, 35, 40, 48,
                                       26, 27, 29, 32, 35, 40, 48, 58,
                                       26, 27, 29, 34, 38, 46, 56, 69,
                                       27, 29, 35, 38, 46, 56, 69, 83};
    int[64] non_intra_quantiser_matrix = {16, 16, 16, 16, 16, 16, 16, 16,
                                          16, 16, 16, 16, 16, 16, 16, 16,
                                          16, 16, 16, 16, 16, 16, 16, 16,
                                          16, 16, 16, 16, 16, 16, 16, 16,
                                          16, 16, 16, 16, 16, 16, 16, 16,
                                          16, 16, 16, 16, 16, 16, 16, 16,
                                          16, 16, 16, 16, 16, 16, 16, 16,
                                          16, 16, 16, 16, 16, 16, 16, 16};

    // (cite 1, P.70 Table 7-6)
    int[2][32] quantiser_scale =
        // Note that quantiser_scale[x][0] is a Forbidden Value
        {{ 0,  2,  4,  6,  8, 10, 12, 14,
           16, 18, 20, 22, 24, 26, 28, 30,
           32, 34, 36, 38, 40, 42, 44, 46,
           48, 50, 52, 54, 56, 58, 60, 62},
         { 0,  1,  2,  3,  4,  5,  6,  7,
           8, 10, 12, 14, 16, 18, 20, 22,
           24, 28, 32, 36, 40, 44, 48, 52, 
           56, 64, 72, 80, 88, 96, 104, 112}};

    init {
        quantiser_scale_code = 1; // Guarantees that this throws an error
        // if it doesn't get a quantiser message
        // before getting some data.
        q_scale_type = 0; // Another nice error if no message received in time.
    }

    work pop (64-macroblock_intra) push (64-macroblock_intra) {
        if (quantiser_scale_code == 0)
            println("Error - quantiser_scale_code not allowed to be 0 " + macroblock_intra);
        for (int i = macroblock_intra; i < 64; i++) {
            int QF = pop();
            // (cite 1, P.71)
            int k = 0;
            if (macroblock_intra == 1) {
                k = 0;
            } else {
                // TODO - I think I'm interpreting this part of the spec correctly, check though.
                if (QF > 0) {
                    k = 1;
                } else if (QF < 0) {
                    k = -1;
                } else {
                    k = 0;
                }          
            }
            int W = 0;
            if (macroblock_intra == 1) {
                W = intra_quantiser_matrix[i];
            } else {
                W = non_intra_quantiser_matrix[i];
            }
            int F = (2 * QF + k) * W * 
                quantiser_scale[q_scale_type][quantiser_scale_code] / 32;
            push(F);
        }
    }

} 

/**
 * @internal
 */
int->int filter MismatchControl() {
    // (cite 1, P.71)
    work pop 64 push 64 {
        int sum, val;
        sum = 0;
        for (int i = 0; i < 63; i++) {
            val = pop();
            sum += val;
            push(val);
        }
        val = pop();
        sum += val;
        if ((sum & 0x1) == 0x1) {
            push(val);
        } else {
            if ((val * 0x1) == 0x1) {
                push(val-1);
            } else {
                push(val+1);
            }
        }
    }
}

/**
 * @internal
 */
int->int filter MotionVectorDecode() {
    // Note - at first glance, this filter looks like it OUGHT to handle. only a single motion vector instead
    // of all 8, and then it would be wrapped inside an 8 way splitjoin. This is only because of currently
    // existing limitations in this code, however. More general MPEG-2 bitstreams allow for concealment
    // motion vectors (to help in the case of errors introduced during transmission of the bitstream), and
    // when concealment motion vectors are introduced, then dependencies are introduced between the 
    // vectors. These dependencies will make it hard to use an 8-way splitjoin approach without a 
    // message passing scheme that allows for across splitjoin messaging. 

    // Section 7.6.3.1 covers this. (cite 1, P.77)
    int[2][2][2] PMV;

    int mv_format; // HACKED TODO - MESSAGING
    int picture_structure; // HACKED TODO - MESSAGING

    init {
        mv_format = 1; // HACKD TODO MESSAGING
        picture_structure = 1; // HACKED TODO - MESSAGING
    }

    work pop 16 push 8 {
        int[2][2][2] motion_code;
        for (int r = 0; r < 2; r++)
            for (int s = 0; s < 2; s++) 
                for (int t = 0; t < 2; t++) {
                    motion_code[r][s][t] = pop();
                }
        int[2][2][2] motion_residual;
        for (int r = 0; r < 2; r++)
            for (int s = 0; s < 2; s++) 
                for (int t = 0; t < 2; t++) {
                    motion_residual[r][s][t] = pop();
                }
        int[2][2][2] vectorp;
        for (int r = 0; r < 1; r++) {
            // NOTE TODO - Hacked right now, don't know when we need the second motion vector.
            for (int s = 0; s < 2; s++) {
                for (int t = 0; t < 2; t++) {
                    int r_size = 14;
                    int f = 1 << r_size;
                    int high = (16*f)-1;
                    int low = ((-16)*f);
                    int range = (32*f);
                    int delta;
                    if ((f == 1) || (motion_code[r][s][t] == 0)) {
                        delta = motion_code[r][s][t];
                    } else {
                        delta = ((int) (abs(motion_code[r][s][t])-1)*f) + 
                            motion_residual[r][s][t]+1;
                        if (motion_code[r][s][t]<0)
                            delta = -delta;
                    }
                    int prediction = PMV[r][s][t];
                    if ((mv_format == 0) && (t == 1) && (picture_structure == 3))
                        println("Error - Program Limitation: May not be correct in decoding motion vectors");
                    vectorp[r][s][t] = prediction + delta;
                    if (vectorp[r][s][t] < low)
                        vectorp[r][s][t] = vectorp[r][s][t] + range;
                    if (vectorp[r][s][t] > high)
                        vectorp[r][s][t] = vectorp[r][s][t] - range;
                    if ((mv_format == 0) && (t == 1) && (picture_structure == 3))
                        println("Error - Program Limitation: May not be correct in decoding motion vectors");
                    else 
                        PMV[r][s][t] = vectorp[r][s][t];
                    // TODO handle updating missed motion_vectors
                    // section 7.6.3.3 
                }
            }
        } 
        for (int r = 0; r < 2; r++)
            for (int s = 0; s < 2; s++) 
                for (int t = 0; t < 2; t++) {
                    push(vectorp[r][s][t]);
                }
    }
  
}

/**
 * @internal
 */
int->int pipeline LuminanceChannelProcessing(int width, 
                                             int height,
                                             int the_chroma_format) {
    add MacroBlockDescrambler(width, 64+11, 2);
    add DescrambleAndMotionCompensate(width, height, 1, 1, 1, the_chroma_format);
}

/**
 * @internal
 */
int->int pipeline ChrominanceChannelProcessing(int width, 
                                               int height,
                                               int the_chroma_format) {
    // Assumes 4:2:0 to 4:4:4 or 4:2:2 to 4:4:4
    // Adding 4:4:4 support requires some additional block reordering.
    if (the_chroma_format == 2) {
        add MacroBlockDescrambler(width/2, 64+11, 1);
    }
    int vertical_upsample_factor;
    if (the_chroma_format == 1) {
        vertical_upsample_factor = 2;
    } else {
        vertical_upsample_factor = 1;
    }
    add DescrambleAndMotionCompensate(width, height, vertical_upsample_factor, 2, 0, the_chroma_format);
    if (the_chroma_format == 1) {
        add ChannelUpsample_Vert_and_Horz(width/2, height/2);
    } else {
        add ChannelUpsample_Horizontal(width/2, height);
    }
}

/**
 * @internal
 */
int->int splitjoin MacroBlockDescrambler(int width, int block_data_size, int horiz_blockwidth) {
    split roundrobin(block_data_size*horiz_blockwidth);
    for (int i = 0; i < 2; i++) {
        add Identity<int>;
    }
    join roundrobin((width/8)*block_data_size);
}

/**
 * @internal
 */
int->int pipeline DescrambleAndMotionCompensate(int width, 
                                                int height, 
                                                int vertical_upsample_factor,
                                                int horizontal_upsample_factor,
                                                int temp,
                                                int the_chroma_format) {
    int datasize = (width/horizontal_upsample_factor)*(height/vertical_upsample_factor);

    // this filter is a hand-fused version of the splitjoin below
    add int->int filter {
	work push 75 pop 75 {
	    for (int i=0; i<64; i++) {
		push(pop());
	    }
	    // vectorp->vector (cite 1, P.82) 
	    for (int i=0; i<4; i++) {
		push(pop()/horizontal_upsample_factor);
		push(pop()/vertical_upsample_factor);
	    }
	    push(pop());
	    push(pop());
	    push(pop());
	}
    }

    /*
    add int->int splitjoin {
        split roundrobin(64, 8, 1, 1, 1);
        //add BlockDescrambler(width/horizontal_upsample_factor);
        add Identity<int>;
        add int->int splitjoin { // vectorp->vector (cite 1, P.82) 
            split roundrobin(1, 1); 
            add DivideBy(horizontal_upsample_factor);
            add DivideBy(vertical_upsample_factor);
            join roundrobin(1, 1);
        }
        add Identity<int>;
        add Identity<int>;
        add Identity<int>;
        //    join roundrobin(datasize, (datasize/64)*8, datasize/64, datasize/64, datasize/64); 
        join roundrobin(64, 8, 1, 1, 1);
    }  
    */

    add MotionPrediction(width/horizontal_upsample_factor, height/vertical_upsample_factor);
}

/**
 * @internal
 */
int->int splitjoin BlockDescrambler(int width) {
    split roundrobin(8);
    for (int i = 0; i < 8; i++) {
        add Identity<int>;
    }
    join roundrobin(width);
}

/**
 * @internal
 *
 * This is a filter version of the block descrambler that should avoid
 * some fusion overhead.  This version does not need any buffer, and
 * should be able to be derived by linear analysis.  Unfortunately, no
 * speedups were observed, but including it here for future reference.
 */
int->int filter BlockDescramblerFilter1(int width) {
    work push 8*width pop 8*width {
        for (int i=0; i<64; i+=8) {
            for (int j=0; j<width*8; j+=width) {
                int k = i+j;
                push(peek(k));
                push(peek(k+1));
                push(peek(k+2));
                push(peek(k+3));
                push(peek(k+4));
                push(peek(k+5));
                push(peek(k+6));
                push(peek(k+7));
            }
        }
        for (int i=0; i<8*width; i++) {
            pop();
        }
    }
}

/**
 * @internal
 *
 * This is a filter version of the block descrambler that should avoid
 * some fusion overhead.  This version uses a buffer so that no peek
 * statements are needed.  It is probably slower than
 * BlockDescramblerFilter1, but including for future experiments.
 */
int->int filter BlockDescramblerFilter2(int width) {
    work push 8*width pop 8*width {
        int[8*width] buffer;
        for (int i=0; i<width; i+=8) {
            for (int j=0; j<8; j++) {
                int k = j*width+i;
                buffer[k] = pop();
                buffer[k+1] = pop();
                buffer[k+2] = pop();
                buffer[k+3] = pop();
                buffer[k+4] = pop();
                buffer[k+5] = pop();
                buffer[k+6] = pop();
                buffer[k+7] = pop();
            }
        }
        for (int i=0; i<8*width; i++) {
            push(buffer[i]);
        }
    }
}

/**
 * @internal
 */
int->int filter MotionPrediction(int width, int height) {
    int count;

    int lastSeenFrame;

    int datarate = (width*height/64*(64+8+1+1+1));
    int pushrate = width*height;
  
    int[width][height] prev_picture;
    int[width][height] next_picture;

    int next_picture_type;

    init {
        next_picture_type = 1;
        count = 0;
    }

    work pop datarate push pushrate {
        if (next_picture_type == -1) {
            println("Error - Should have received a picture type message before motion prediction can process");
        } 
        if (next_picture_type == 1 || next_picture_type == 2) {
            prev_picture = next_picture;
            if (next_picture_type == 1) {
                readIPicture();
            } else {
                readPPicture();
            }
        } else {
            readBPicture();
        }
        count++;
    }

    void readIPicture() pop datarate push pushrate {
        lastSeenFrame = 1;
        int[width][height] temp_picture;
 
        for (int blocky = 0; blocky < (height/8); blocky++) {
            for (int blockx = 0; blockx < (width/8); blockx++) {
                for (int y = 0; y < 8; y++) {
                    for (int x = 0; x < 8; x++) {
                        temp_picture[x+blockx*8][y+blocky*8] = pop();
                    }
                }
                for (int i = 0; i < 8; i++) {
                    pop();
                }
                pop();
                pop();
                pop();
            }
        }

        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                next_picture[x][y] = temp_picture[x][y];
                push(temp_picture[x][y]);
            }
        }
    }

    void readPPicture() pop datarate push pushrate {
        lastSeenFrame = 2;
        int[width][height] temp_picture;
        int[width/8][height/8][2][2][2] vector;
        int[width/8][height/8] macroblock_intra;

        for (int blocky = 0; blocky < height/8; blocky++) {
            for (int blockx = 0; blockx < width/8; blockx++) {
                for (int y = 0; y < 8; y++) {
                    for (int x = 0; x < 8; x++) {
                        temp_picture[x+blockx*8][y+blocky*8] = pop();
                    }
                }
                for (int r = 0; r < 2; r++) {
                    for (int s = 0; s < 2; s++) {
                        for (int t = 0; t < 2; t++) {
                            vector[blockx][blocky][r][s][t] = pop();
                        }
                    }
                }
                macroblock_intra[blockx][blocky] = pop();
                pop();
                pop();
            }
        }

        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                if (macroblock_intra[x/8][y/8] == 0) {
                    int sample_data;
                    sample_data = predictMotionPixel(prev_picture, vector, 0, x, y);
                    next_picture[x][y] = temp_picture[x][y] + sample_data;
                } else {
                    next_picture[x][y] = temp_picture[x][y];
                }
                push(next_picture[x][y]);
                if (next_picture[x][y] > 127) {
                    next_picture[x][y] = 127;
                } else if (next_picture[x][y] < -128) {
                    next_picture[x][y] = -128;
                }
            }
        }
    }

    void readBPicture() pop datarate push pushrate {
        lastSeenFrame = 3;
        int[width][height] temp_picture;
        int[width/8][height/8][2][2][2] vector;
        int[width/8][height/8] macroblock_intra;
        int[width/8][height/8] macroblock_motion_forward;
        int[width/8][height/8] macroblock_motion_backward;

        for (int blocky = 0; blocky < height/8; blocky++) {
            for (int blockx = 0; blockx < width/8; blockx++) {
                for (int y = 0; y < 8; y++) {
                    for (int x = 0; x < 8; x++) {
                        temp_picture[x+blockx*8][y+blocky*8] = pop();
                    }
                }
                for (int r = 0; r < 2; r++) {
                    for (int s = 0; s < 2; s++) {
                        for (int t = 0; t < 2; t++) {
                            vector[blockx][blocky][r][s][t] = pop();
                        }
                    }
                }
                macroblock_intra[blockx][blocky] = pop();
                macroblock_motion_forward[blockx][blocky] = pop();
                macroblock_motion_backward[blockx][blocky] = pop();
            }
        }

        int[width][height] permsample;
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                int pushval;
                if (macroblock_intra[x/8][y/8] == 0) {
                    int[2] sample_data;
                    if (macroblock_motion_forward[x/8][y/8] == 1) {
                        sample_data[0] = predictMotionPixel(prev_picture, vector, 0, x, y);
                    }
                    if (macroblock_motion_backward[x/8][y/8] == 1) {
                        sample_data[1] = predictMotionPixel(next_picture, vector, 1, x, y);
                    }
                    if (macroblock_motion_forward[x/8][y/8] == 1) {
                        if (macroblock_motion_backward[x/8][y/8] == 1) {
                            permsample[x][y] = (1+sample_data[0]+sample_data[1]+256)/2-128;
                        } else {
                            permsample[x][y] = sample_data[0];  
                        }
                    } else {
                        permsample[x][y] = sample_data[1];
                    }
                } else {
                    permsample[x][y] = 0;
                }
                pushval = temp_picture[x][y] + permsample[x][y];
                push(pushval);
            }
        }
    }

    int predictPixelHorizHalfPelVertHalfPel(int[width][height] predict_pic, 
                                            int horiz_vector, 
                                            int vert_vector) {
        int sample_data;
        sample_data = (predict_pic[(horiz_vector-1)/2][(vert_vector-1)/2] +
                       predict_pic[(horiz_vector-1)/2][(vert_vector+1)/2] +
                       predict_pic[(horiz_vector+1)/2][(vert_vector-1)/2] +
                       predict_pic[(horiz_vector+1)/2][(vert_vector+1)/2]);
        sample_data += 128*4;
        if (sample_data > 0) {
            sample_data += 2;
        } else if (sample_data < 0) {
            println("Error - Shouldn't be less than zero " + sample_data);
        }
        sample_data = sample_data / 4;
        sample_data -= 128;
        return sample_data;
    }

    int predictPixelHorizHalfPelVertFullPel(int[width][height] predict_pic, 
                                            int horiz_vector, 
                                            int vert_vector) {
        int sample_data;
        sample_data = (predict_pic[(horiz_vector-1)/2][vert_vector/2] +
                       predict_pic[(horiz_vector+1)/2][vert_vector/2]);
        sample_data += 128*2;
        if (sample_data > 0) {
            sample_data += 1;
        } else if (sample_data < 0) { 
            println("Error - Shouldn't be less than zero " + sample_data);
        }
        sample_data = sample_data / 2;
        sample_data -= 128;
        return sample_data;
    }

    int predictPixelHorizFullPelVertHalfPel(int[width][height] predict_pic, 
                                            int horiz_vector, 
                                            int vert_vector) {
        int sample_data;
        sample_data = (predict_pic[horiz_vector/2][(vert_vector-1)/2] +
                       predict_pic[horiz_vector/2][(vert_vector+1)/2]);
        sample_data += 128*2;
        if (sample_data > 0) {
            sample_data += 1;
        } else if (sample_data < 0) {
            println("Error - Shouldn't be less than zero " + sample_data);
        }
        sample_data = sample_data / 2;
        sample_data -= 128;
        return sample_data;
    }

    int predictPixelHorizFullPelVertFullPel(int[width][height] predict_pic, 
                                            int horiz_vector, 
                                            int vert_vector) {
        int sample_data;
        sample_data = predict_pic[horiz_vector/2][vert_vector/2];
        return sample_data;
    }

    int predictMotionPixel(int[width][height] predict_pic, 
                           int[width/8][height/8][2][2][2] vector, 
                           int whichvect, 
                           int x, 
                           int y) {
        // whichvect = 0 for forward motion prediction
        // whichvect = 1 for backward motion prediction
        int horiz_vector = vector[x/8][y/8][0][whichvect][0] + (x*2);
        int vert_vector = vector[x/8][y/8][0][whichvect][1] + (y*2);
        int sample_data;
        if (vert_vector < 0 || vert_vector >= (height*2-1) || 
            horiz_vector < 0 || horiz_vector >= (width*2-1)) {
            sample_data = 0;
        } else if ((horiz_vector & 0x1) == 1) {
            if ((vert_vector & 0x1) == 1) {
                sample_data = predictPixelHorizHalfPelVertHalfPel(predict_pic, horiz_vector, vert_vector);
            } else {
                sample_data = predictPixelHorizHalfPelVertFullPel(predict_pic, horiz_vector, vert_vector);
            }
        } else {
            if ((vert_vector & 0x1) == 1) {
                sample_data = predictPixelHorizFullPelVertHalfPel(predict_pic, horiz_vector, vert_vector);
            } else {
                sample_data = predictPixelHorizFullPelVertFullPel(predict_pic, horiz_vector, vert_vector);
            }
        }
        if (sample_data > 127)
            sample_data = 127;
        else if (sample_data < -128)
            sample_data = -128;
        return sample_data;
    }

}

// Note: We assume we are going from 4:2:0 to 4:4:4
// Otherwise this won't work.
// Check out store.c in the mpeg reference implementation
// It has a more complicated, probably more accurate
// implementation. Only implement if needed.
/**
 * @internal
 */
int->int pipeline ChannelUpsample_Vert_and_Horz(int sourcewidth, 
                                                int sourceheight) {
    add ChannelUpsample_Vertical(sourcewidth, sourceheight);
    add ChannelUpsample_Horizontal(sourcewidth, sourceheight);
}

int->int splitjoin ChannelUpsample_Vertical(int sourcewidth, 
                                            int sourceheight) {
    split roundrobin(1);
    for (int i = 0; i < sourcewidth; i++) {
        add ChannelUpsample_1D(sourceheight, 0.75, 0.25);
    }
    join roundrobin(1);
}

int->int splitjoin ChannelUpsample_Horizontal(int sourcewidth, 
                                              int sourceheight) {
    split roundrobin(sourcewidth);
    for (int i = 0; i < sourceheight; i++) {
        add ChannelUpsample_1D(sourcewidth, 0.5, 0.5);
    }
    join roundrobin(sourcewidth*2);
}

/**
 * @internal
 */
int->int filter ChannelUpsample_1D_Unoptimized(int sourcelen, 
					       float weight1, 
					       float weight2) {
    work pop sourcelen push sourcelen*2 {
        int val1 = 0, val2 = 0;
        val1 = pop();
        push(val1);
        for (int i = 0; i < sourcelen-1; i++) {
            val2 = pop();
            float outval = (weight1*val1+weight2*val2);
            push((int) round(outval));
            outval = (weight2*val1+weight1*val2);
            push((int) round(outval));
            val1 = val2;
        }
        push(val2);
    }    
}

/**
 * @internal
 */
int->int filter ChannelUpsample_1D(int sourcelen, 
				    float weight1, 
				    float weight2) {
    work pop sourcelen push sourcelen*2 {
        int val1 = 0, val2 = 0;
	// keep track of product of weights to avoid extra multiplies
	float w1val1, w1val2; // weight1 * val1, weight1 * val2
	float w2val1, w2val2; // weight2 * val1, weight2 * val2

        val1 = pop();
	w1val1 = weight1*val1;
	w2val1 = weight2*val1;

        push(val1);
        for (int i = 0; i < sourcelen-1; i++) {
            val2 = pop();
	    w1val2 = weight1*val2;
	    w2val2 = weight2*val2;

            float outval = (w1val1+w2val2);
            push((int) round(outval));
            outval = (w2val1+w1val2);
            push((int) round(outval));

            w1val1 = w1val2;
            w2val1 = w2val2;
        }
        push(val2);
    }    
}

/**
 * @internal
 */
int->int filter PictureReorder(int width, 
                               int height) {
    int datarate = (width*height*3);
    int[(width*height*3)] databuffer;
    int next_picture_type = 1;

    prework pop datarate {
        for (int i = 0; i < datarate; i++) {
            databuffer[i] = pop();
        }
    }

    work pop datarate push datarate {
        if (next_picture_type == 3) {
            for (int i = 0; i < datarate; i++) {
                push(pop());
            }
        } else {
            for (int i = 0; i < datarate; i++) {
                push(databuffer[i]);
                databuffer[i] = pop();
            }
        }     
    }

}

/* ******************** Other files concatenated ******************** */
/*
 * Copyright 2005 by the Massachusetts Institute of Technology.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in
 * advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 */

/**
 * @description
 * This file contains global variables needed by both MPEG-2 decoders and encoders.
 * The code is based on the MPEG-2 specification (ISO/IEC 13818-2), Appendix B.
 *
 * @author <a href="mailto:madrake@gmail.com">Matthew Drake</a>
 * @file MPEGglobal.str.pre
 * @version 1.0
 */

struct vlc_table_entry {
    int code;
    int len; // Length of code in bits
    int value;
}

struct vlc_dct_table_entry { // See P. 135
    // We code a special vlc table type for the DCT coefficients because they are
    // so important.
    int code;
    int len; // Length of code in bits
    int run;
    int level;
}

static {
    int[4] blocks_per_macroblock = {0, 6, 8, 12}; 
    // Index is the chroma format
    // as defined in the MPEG-2 bitstream
    // 1 = 4:2:0, 2 = 4:2:2, 3 = 4:4:4
    
    vlc_table_entry[33] const_macroblock_address_inc;  // Table B1
    int const_macroblock_address_inc_len = 33;

    vlc_table_entry[2] const_macroblock_type_Ipictures; // Table B2
    int const_macroblock_type_Ipictures_len = 2;
 
    vlc_table_entry[7] const_macroblock_type_Ppictures; // Table B3
    int const_macroblock_type_Ppictures_len = 7;

    vlc_table_entry[11] const_macroblock_type_Bpictures; // Table B4
    int const_macroblock_type_Bpictures_len = 11;

    vlc_table_entry[64] const_coded_block_patterns; // Table B9
    int const_coded_block_patterns_len = 64;

    vlc_table_entry[33] const_motion_code; // Table B10
    int const_motion_code_len = 33;

    vlc_table_entry[12] const_dct_dc_size_luminance; // Table B12
    int const_dct_dc_size_luminance_len = 12;

    vlc_table_entry[12] const_dct_dc_size_chrominance; // Table B13
    int const_dct_dc_size_chrominance_len = 12;

    vlc_dct_table_entry[114] const_dct_coefficients_table_zero; // Table B14, assuming 
    int const_dct_coefficients_table_zero_len = 111; // intra_vlc_format == 1, macroblock_intra == 0
    int const_dct_coefficients_table_zero_max_symbol_len = 16;

    // Table B14, reordered for an optimized huffman scan
    // intra_vlc_format == 1, macroblock_intra == 0
    vlc_dct_table_entry[1] const_dct_coefficients_table_zero_len2; 
    vlc_dct_table_entry[16] const_dct_coefficients_table_zero_len16; 
    vlc_dct_table_entry[16] const_dct_coefficients_table_zero_len15; 
    vlc_dct_table_entry[16] const_dct_coefficients_table_zero_len14; 
    vlc_dct_table_entry[16] const_dct_coefficients_table_zero_len13; 
    vlc_dct_table_entry[16] const_dct_coefficients_table_zero_len12; 
    vlc_dct_table_entry[8] const_dct_coefficients_table_zero_len10; 
    vlc_dct_table_entry[8] const_dct_coefficients_table_zero_len8; 
    vlc_dct_table_entry[4] const_dct_coefficients_table_zero_len7; 
    vlc_dct_table_entry[4] const_dct_coefficients_table_zero_len6; 
    vlc_dct_table_entry[3] const_dct_coefficients_table_zero_len5; 
    vlc_dct_table_entry[2] const_dct_coefficients_table_zero_len4; 
    vlc_dct_table_entry[1] const_dct_coefficients_table_zero_len3; 

    init {
        blocks_per_macroblock[0] = 0; // ERROR - you must have set it incorrectly
        blocks_per_macroblock[1] = 6;
        blocks_per_macroblock[2] = 8;
        blocks_per_macroblock[3] = 12; 

        const_coded_block_patterns[0].code = 7;
        const_coded_block_patterns[0].len = 3;
        const_coded_block_patterns[0].value = 60;
        const_coded_block_patterns[1].code = 13;
        const_coded_block_patterns[1].len = 4;
        const_coded_block_patterns[1].value = 4;
        const_coded_block_patterns[2].code = 12;
        const_coded_block_patterns[2].len = 4;
        const_coded_block_patterns[2].value = 8;
        const_coded_block_patterns[3].code = 11;
        const_coded_block_patterns[3].len = 4;
        const_coded_block_patterns[3].value = 16;
        const_coded_block_patterns[4].code = 10;
        const_coded_block_patterns[4].len = 4;
        const_coded_block_patterns[4].value = 32;
        const_coded_block_patterns[5].code = 19;
        const_coded_block_patterns[5].len = 5;
        const_coded_block_patterns[5].value = 12;
        const_coded_block_patterns[6].code = 18;
        const_coded_block_patterns[6].len = 5;
        const_coded_block_patterns[6].value = 48;
        const_coded_block_patterns[7].code = 17;
        const_coded_block_patterns[7].len = 5;
        const_coded_block_patterns[7].value = 20;
        const_coded_block_patterns[8].code = 16;
        const_coded_block_patterns[8].len = 5;
        const_coded_block_patterns[8].value = 40;
        const_coded_block_patterns[9].code = 15;
        const_coded_block_patterns[9].len = 5;
        const_coded_block_patterns[9].value = 28;
        const_coded_block_patterns[10].code = 14;
        const_coded_block_patterns[10].len = 5;
        const_coded_block_patterns[10].value = 44;
        const_coded_block_patterns[11].code = 13;
        const_coded_block_patterns[11].len = 5;
        const_coded_block_patterns[11].value = 52;
        const_coded_block_patterns[12].code = 12;
        const_coded_block_patterns[12].len = 5;
        const_coded_block_patterns[12].value = 56;
        const_coded_block_patterns[13].code = 11;
        const_coded_block_patterns[13].len = 5;
        const_coded_block_patterns[13].value = 1;
        const_coded_block_patterns[14].code = 10;
        const_coded_block_patterns[14].len = 5;
        const_coded_block_patterns[14].value = 61;
        const_coded_block_patterns[15].code = 9;
        const_coded_block_patterns[15].len = 5;
        const_coded_block_patterns[15].value = 2;
        const_coded_block_patterns[16].code = 8;
        const_coded_block_patterns[16].len = 5;
        const_coded_block_patterns[16].value = 62;
        const_coded_block_patterns[17].code = 15;
        const_coded_block_patterns[17].len = 6;
        const_coded_block_patterns[17].value = 24;
        const_coded_block_patterns[18].code = 14;
        const_coded_block_patterns[18].len = 6;
        const_coded_block_patterns[18].value = 36;
        const_coded_block_patterns[19].code = 13;
        const_coded_block_patterns[19].len = 6;
        const_coded_block_patterns[19].value = 3;
        const_coded_block_patterns[20].code = 12;
        const_coded_block_patterns[20].len = 6;
        const_coded_block_patterns[20].value = 63;
        const_coded_block_patterns[21].code = 23;
        const_coded_block_patterns[21].len = 7;
        const_coded_block_patterns[21].value = 5;
        const_coded_block_patterns[22].code = 22;
        const_coded_block_patterns[22].len = 7;
        const_coded_block_patterns[22].value = 9;
        const_coded_block_patterns[23].code = 21;
        const_coded_block_patterns[23].len = 7;
        const_coded_block_patterns[23].value = 17;
        const_coded_block_patterns[24].code = 20;
        const_coded_block_patterns[24].len = 7;
        const_coded_block_patterns[24].value = 33;
        const_coded_block_patterns[25].code = 19;
        const_coded_block_patterns[25].len = 7;
        const_coded_block_patterns[25].value = 6;
        const_coded_block_patterns[26].code = 18;
        const_coded_block_patterns[26].len = 7;
        const_coded_block_patterns[26].value = 10;
        const_coded_block_patterns[27].code = 17;
        const_coded_block_patterns[27].len = 7;
        const_coded_block_patterns[27].value = 18;
        const_coded_block_patterns[28].code = 16;
        const_coded_block_patterns[28].len = 7;
        const_coded_block_patterns[28].value = 34;
        const_coded_block_patterns[29].code = 31;
        const_coded_block_patterns[29].len = 8;
        const_coded_block_patterns[29].value = 7;
        const_coded_block_patterns[30].code = 30;
        const_coded_block_patterns[30].len = 8;
        const_coded_block_patterns[30].value = 11;
        const_coded_block_patterns[31].code = 29;
        const_coded_block_patterns[31].len = 8;
        const_coded_block_patterns[31].value = 19;
        const_coded_block_patterns[32].code = 28;
        const_coded_block_patterns[32].len = 8;
        const_coded_block_patterns[32].value = 35;
        const_coded_block_patterns[33].code = 27;
        const_coded_block_patterns[33].len = 8;
        const_coded_block_patterns[33].value = 13;
        const_coded_block_patterns[34].code = 26;
        const_coded_block_patterns[34].len = 8;
        const_coded_block_patterns[34].value = 49;
        const_coded_block_patterns[35].code = 25;
        const_coded_block_patterns[35].len = 8;
        const_coded_block_patterns[35].value = 21;
        const_coded_block_patterns[36].code = 24;
        const_coded_block_patterns[36].len = 8;
        const_coded_block_patterns[36].value = 41;
        const_coded_block_patterns[37].code = 23;
        const_coded_block_patterns[37].len = 8;
        const_coded_block_patterns[37].value = 14;
        const_coded_block_patterns[38].code = 22;
        const_coded_block_patterns[38].len = 8;
        const_coded_block_patterns[38].value = 50;
        const_coded_block_patterns[39].code = 21;
        const_coded_block_patterns[39].len = 8;
        const_coded_block_patterns[39].value = 22;
        const_coded_block_patterns[40].code = 20;
        const_coded_block_patterns[40].len = 8;
        const_coded_block_patterns[40].value = 42;
        const_coded_block_patterns[41].code = 19;
        const_coded_block_patterns[41].len = 8;
        const_coded_block_patterns[41].value = 15;
        const_coded_block_patterns[42].code = 18;
        const_coded_block_patterns[42].len = 8;
        const_coded_block_patterns[42].value = 51;
        const_coded_block_patterns[43].code = 17;
        const_coded_block_patterns[43].len = 8;
        const_coded_block_patterns[43].value = 23;
        const_coded_block_patterns[44].code = 16;
        const_coded_block_patterns[44].len = 8;
        const_coded_block_patterns[44].value = 43;
        const_coded_block_patterns[45].code = 15;
        const_coded_block_patterns[45].len = 8;
        const_coded_block_patterns[45].value = 25;
        const_coded_block_patterns[46].code = 14;
        const_coded_block_patterns[46].len = 8;
        const_coded_block_patterns[46].value = 37;
        const_coded_block_patterns[47].code = 13;
        const_coded_block_patterns[47].len = 8;
        const_coded_block_patterns[47].value = 26;
        const_coded_block_patterns[48].code = 12;
        const_coded_block_patterns[48].len = 8;
        const_coded_block_patterns[48].value = 38;
        const_coded_block_patterns[49].code = 11;
        const_coded_block_patterns[49].len = 8;
        const_coded_block_patterns[49].value = 29;
        const_coded_block_patterns[50].code = 10;
        const_coded_block_patterns[50].len = 8;
        const_coded_block_patterns[50].value = 45;
        const_coded_block_patterns[51].code = 9;
        const_coded_block_patterns[51].len = 8;
        const_coded_block_patterns[51].value = 53;
        const_coded_block_patterns[52].code = 8;
        const_coded_block_patterns[52].len = 8;
        const_coded_block_patterns[52].value = 57;
        const_coded_block_patterns[53].code = 7;
        const_coded_block_patterns[53].len = 8;
        const_coded_block_patterns[53].value = 30;
        const_coded_block_patterns[54].code = 6;
        const_coded_block_patterns[54].len = 8;
        const_coded_block_patterns[54].value = 46;
        const_coded_block_patterns[55].code = 5;
        const_coded_block_patterns[55].len = 8;
        const_coded_block_patterns[55].value = 54;
        const_coded_block_patterns[56].code = 4;
        const_coded_block_patterns[56].len = 8;
        const_coded_block_patterns[56].value = 58;
        const_coded_block_patterns[57].code = 7;
        const_coded_block_patterns[57].len = 9;
        const_coded_block_patterns[57].value = 31;
        const_coded_block_patterns[58].code = 6;
        const_coded_block_patterns[58].len = 9;
        const_coded_block_patterns[58].value = 47;
        const_coded_block_patterns[59].code = 5;
        const_coded_block_patterns[59].len = 9;
        const_coded_block_patterns[59].value = 55;
        const_coded_block_patterns[60].code = 4;
        const_coded_block_patterns[60].len = 9;
        const_coded_block_patterns[60].value = 59;
        const_coded_block_patterns[61].code = 3;
        const_coded_block_patterns[61].len = 9;
        const_coded_block_patterns[61].value = 27;
        const_coded_block_patterns[62].code = 2;
        const_coded_block_patterns[62].len = 9;
        const_coded_block_patterns[62].value = 39;
        const_coded_block_patterns[63].code = 1;
        const_coded_block_patterns[63].len = 9;
        const_coded_block_patterns[63].value = 0;

        const_motion_code[0].code = 25;
        const_motion_code[0].len = 11;
        const_motion_code[0].value = -16;
        const_motion_code[1].code = 27;
        const_motion_code[1].len = 11;
        const_motion_code[1].value = -15;
        const_motion_code[2].code = 29;
        const_motion_code[2].len = 11 ;
        const_motion_code[2].value = -14;
        const_motion_code[3].code = 31;
        const_motion_code[3].len = 11;
        const_motion_code[3].value = -13;
        const_motion_code[4].code = 33;
        const_motion_code[4].len = 11;
        const_motion_code[4].value = -12;
        const_motion_code[5].code = 35;
        const_motion_code[5].len = 11;
        const_motion_code[5].value = -11;
        const_motion_code[6].code = 19;
        const_motion_code[6].len = 10;
        const_motion_code[6].value = -10;
        const_motion_code[7].code = 21;
        const_motion_code[7].len = 10;
        const_motion_code[7].value = -9;
        const_motion_code[8].code = 23;
        const_motion_code[8].len = 10;
        const_motion_code[8].value = -8;
        const_motion_code[9].code = 7;
        const_motion_code[9].len = 8;
        const_motion_code[9].value = -7;
        const_motion_code[10].code = 9;
        const_motion_code[10].len = 8;
        const_motion_code[10].value = -6;
        const_motion_code[11].code = 11;
        const_motion_code[11].len = 8;
        const_motion_code[11].value = -5;
        const_motion_code[12].code = 7;
        const_motion_code[12].len = 7;
        const_motion_code[12].value = -4;
        const_motion_code[13].code = 3;
        const_motion_code[13].len = 5;
        const_motion_code[13].value = -3;
        const_motion_code[14].code = 3;
        const_motion_code[14].len = 4;
        const_motion_code[14].value = -2;
        const_motion_code[15].code = 3;
        const_motion_code[15].len = 3;
        const_motion_code[15].value = -1;
        const_motion_code[16].code = 1;
        const_motion_code[16].len = 1;
        const_motion_code[16].value = 0;
        const_motion_code[17].code = 2;
        const_motion_code[17].len = 3;
        const_motion_code[17].value = 1;
        const_motion_code[18].code = 2;
        const_motion_code[18].len = 4;
        const_motion_code[18].value = 2;
        const_motion_code[19].code = 2;
        const_motion_code[19].len = 5;
        const_motion_code[19].value = 3;
        const_motion_code[20].code = 6;
        const_motion_code[20].len = 7;
        const_motion_code[20].value = 4;
        const_motion_code[21].code = 10;
        const_motion_code[21].len = 8;
        const_motion_code[21].value = 5;
        const_motion_code[22].code = 8;
        const_motion_code[22].len = 8;
        const_motion_code[22].value = 6;
        const_motion_code[23].code = 6;
        const_motion_code[23].len = 8;
        const_motion_code[23].value = 7;
        const_motion_code[24].code = 22;
        const_motion_code[24].len = 10;
        const_motion_code[24].value = 8;
        const_motion_code[25].code = 20;
        const_motion_code[25].len = 10;
        const_motion_code[25].value = 9;
        const_motion_code[26].code = 18;
        const_motion_code[26].len = 10;
        const_motion_code[26].value = 10;
        const_motion_code[27].code = 34;
        const_motion_code[27].len = 11;
        const_motion_code[27].value = 11;
        const_motion_code[28].code = 32;
        const_motion_code[28].len = 11;
        const_motion_code[28].value = 12;
        const_motion_code[29].code = 30;
        const_motion_code[29].len = 11;
        const_motion_code[29].value = 13;
        const_motion_code[30].code = 28;
        const_motion_code[30].len = 11;
        const_motion_code[30].value = 14;
        const_motion_code[31].code = 26;
        const_motion_code[31].len = 11;
        const_motion_code[31].value = 15;
        const_motion_code[32].code = 24;
        const_motion_code[32].len = 11;
        const_motion_code[32].value = 16;

        const_macroblock_address_inc[0].code = 1;
        const_macroblock_address_inc[0].len = 1;
        const_macroblock_address_inc[0].value = 1;
        const_macroblock_address_inc[1].code = 3;
        const_macroblock_address_inc[1].len = 3;
        const_macroblock_address_inc[1].value = 2;
        const_macroblock_address_inc[2].code = 2;
        const_macroblock_address_inc[2].len = 3;
        const_macroblock_address_inc[2].value = 3;
        const_macroblock_address_inc[3].code = 3;
        const_macroblock_address_inc[3].len = 4;
        const_macroblock_address_inc[3].value = 4;
        const_macroblock_address_inc[4].code = 2;
        const_macroblock_address_inc[4].len = 4;
        const_macroblock_address_inc[4].value = 5;
        const_macroblock_address_inc[5].code = 3;
        const_macroblock_address_inc[5].len = 5;
        const_macroblock_address_inc[5].value = 6;
        const_macroblock_address_inc[6].code = 2;
        const_macroblock_address_inc[6].len = 5;
        const_macroblock_address_inc[6].value = 7;
        const_macroblock_address_inc[7].code = 7;
        const_macroblock_address_inc[7].len = 7;
        const_macroblock_address_inc[7].value = 8;
        const_macroblock_address_inc[8].code = 6;
        const_macroblock_address_inc[8].len = 7;
        const_macroblock_address_inc[8].value = 11;
        const_macroblock_address_inc[9].code = 11;
        const_macroblock_address_inc[9].len = 8;
        const_macroblock_address_inc[9].value = 10;
        const_macroblock_address_inc[10].code = 10;
        const_macroblock_address_inc[10].len = 8;
        const_macroblock_address_inc[10].value = 11;
        const_macroblock_address_inc[11].code = 9;
        const_macroblock_address_inc[11].len = 8;
        const_macroblock_address_inc[11].value = 12;
        const_macroblock_address_inc[12].code = 8;
        const_macroblock_address_inc[12].len = 8;
        const_macroblock_address_inc[12].value = 13;
        const_macroblock_address_inc[13].code = 7;
        const_macroblock_address_inc[13].len = 8;
        const_macroblock_address_inc[13].value = 14;
        const_macroblock_address_inc[14].code = 6;
        const_macroblock_address_inc[14].len = 8;
        const_macroblock_address_inc[14].value = 15;
        const_macroblock_address_inc[15].code = 23;
        const_macroblock_address_inc[15].len = 10;
        const_macroblock_address_inc[15].value = 16;
        const_macroblock_address_inc[16].code = 22;
        const_macroblock_address_inc[16].len = 10;
        const_macroblock_address_inc[16].value = 17;
        const_macroblock_address_inc[17].code = 21;
        const_macroblock_address_inc[17].len = 10;
        const_macroblock_address_inc[17].value = 18;
        const_macroblock_address_inc[18].code = 20;
        const_macroblock_address_inc[18].len = 10;
        const_macroblock_address_inc[18].value = 19;
        const_macroblock_address_inc[19].code = 19;
        const_macroblock_address_inc[19].len = 10;
        const_macroblock_address_inc[19].value = 20;
        const_macroblock_address_inc[20].code = 18;
        const_macroblock_address_inc[20].len = 10;
        const_macroblock_address_inc[20].value = 21;
        const_macroblock_address_inc[21].code = 35;
        const_macroblock_address_inc[21].len = 11;
        const_macroblock_address_inc[21].value = 22;
        const_macroblock_address_inc[22].code = 34;
        const_macroblock_address_inc[22].len = 11;
        const_macroblock_address_inc[22].value = 23;
        const_macroblock_address_inc[23].code = 33;
        const_macroblock_address_inc[23].len = 11;
        const_macroblock_address_inc[23].value = 24;
        const_macroblock_address_inc[24].code = 32;
        const_macroblock_address_inc[24].len = 11;
        const_macroblock_address_inc[24].value = 25;
        const_macroblock_address_inc[25].code = 31;
        const_macroblock_address_inc[25].len = 11;
        const_macroblock_address_inc[25].value = 26;
        const_macroblock_address_inc[26].code = 30;
        const_macroblock_address_inc[26].len = 11;
        const_macroblock_address_inc[26].value = 27;
        const_macroblock_address_inc[27].code = 29;
        const_macroblock_address_inc[27].len = 11;
        const_macroblock_address_inc[27].value = 28;
        const_macroblock_address_inc[28].code = 28;
        const_macroblock_address_inc[28].len = 11;
        const_macroblock_address_inc[28].value = 29;
        const_macroblock_address_inc[29].code = 27;
        const_macroblock_address_inc[29].len = 11;
        const_macroblock_address_inc[29].value = 30;
        const_macroblock_address_inc[30].code = 26;
        const_macroblock_address_inc[30].len = 11;
        const_macroblock_address_inc[30].value = 31;
        const_macroblock_address_inc[31].code = 25;
        const_macroblock_address_inc[31].len = 11;
        const_macroblock_address_inc[31].value = 32;
        const_macroblock_address_inc[32].code = 24;
        const_macroblock_address_inc[32].len = 11;
        const_macroblock_address_inc[32].value = 33;

        const_macroblock_type_Ipictures[0].code = 1;
        const_macroblock_type_Ipictures[0].len = 1;
        const_macroblock_type_Ipictures[0].value = 2;
        const_macroblock_type_Ipictures[1].code = 1;
        const_macroblock_type_Ipictures[1].len = 2;
        const_macroblock_type_Ipictures[1].value = 34;
  
        const_macroblock_type_Ppictures[0].code = 1;
        const_macroblock_type_Ppictures[0].len =   1;
        const_macroblock_type_Ppictures[0].value = 20;
        const_macroblock_type_Ppictures[1].code = 1;
        const_macroblock_type_Ppictures[1].len = 2;
        const_macroblock_type_Ppictures[1].value = 4;
        const_macroblock_type_Ppictures[2].code = 1;
        const_macroblock_type_Ppictures[2].len = 3;
        const_macroblock_type_Ppictures[2].value = 16;
        const_macroblock_type_Ppictures[3].code = 3;
        const_macroblock_type_Ppictures[3].len = 5;
        const_macroblock_type_Ppictures[3].value = 2;
        const_macroblock_type_Ppictures[4].code = 2;
        const_macroblock_type_Ppictures[4].len = 5;
        const_macroblock_type_Ppictures[4].value = 52;
        const_macroblock_type_Ppictures[5].code = 1;
        const_macroblock_type_Ppictures[5].len = 5;
        const_macroblock_type_Ppictures[5].value = 36;
        const_macroblock_type_Ppictures[6].code = 1;
        const_macroblock_type_Ppictures[6].len = 6;
        const_macroblock_type_Ppictures[6].value = 34;

        const_macroblock_type_Bpictures[0].code = 2;
        const_macroblock_type_Bpictures[0].len = 2;
        const_macroblock_type_Bpictures[0].value = 24;
        const_macroblock_type_Bpictures[1].code = 3;
        const_macroblock_type_Bpictures[1].len = 2;
        const_macroblock_type_Bpictures[1].value = 28;
        const_macroblock_type_Bpictures[2].code = 2;
        const_macroblock_type_Bpictures[2].len = 3;
        const_macroblock_type_Bpictures[2].value = 8;
        const_macroblock_type_Bpictures[3].code = 3;
        const_macroblock_type_Bpictures[3].len = 3;
        const_macroblock_type_Bpictures[3].value = 12;
        const_macroblock_type_Bpictures[4].code = 2;
        const_macroblock_type_Bpictures[4].len = 4;
        const_macroblock_type_Bpictures[4].value = 16;
        const_macroblock_type_Bpictures[5].code = 3;
        const_macroblock_type_Bpictures[5].len = 4;
        const_macroblock_type_Bpictures[5].value = 20;
        const_macroblock_type_Bpictures[6].code = 3;
        const_macroblock_type_Bpictures[6].len = 5;
        const_macroblock_type_Bpictures[6].value = 2;
        const_macroblock_type_Bpictures[7].code = 2;
        const_macroblock_type_Bpictures[7].len = 5;
        const_macroblock_type_Bpictures[7].value = 60;
        const_macroblock_type_Bpictures[8].code = 3;
        const_macroblock_type_Bpictures[8].len = 6;
        const_macroblock_type_Bpictures[8].value = 52;
        const_macroblock_type_Bpictures[9].code = 2;
        const_macroblock_type_Bpictures[9].len = 6;
        const_macroblock_type_Bpictures[9].value = 44;
        const_macroblock_type_Bpictures[10].code = 1;
        const_macroblock_type_Bpictures[10].len = 6;
        const_macroblock_type_Bpictures[10].value = 34;

        const_dct_dc_size_luminance[0].code = 4;
        const_dct_dc_size_luminance[0].len = 3;
        const_dct_dc_size_luminance[0].value = 0;
        const_dct_dc_size_luminance[1].code = 0;
        const_dct_dc_size_luminance[1].len = 2;
        const_dct_dc_size_luminance[1].value = 1;
        const_dct_dc_size_luminance[2].code = 1;
        const_dct_dc_size_luminance[2].len = 2;
        const_dct_dc_size_luminance[2].value = 2;
        const_dct_dc_size_luminance[3].code = 5;
        const_dct_dc_size_luminance[3].len = 3;
        const_dct_dc_size_luminance[3].value = 3;
        const_dct_dc_size_luminance[4].code = 6;
        const_dct_dc_size_luminance[4].len = 3;
        const_dct_dc_size_luminance[4].value = 4;
        const_dct_dc_size_luminance[5].code = 14;
        const_dct_dc_size_luminance[5].len = 4;
        const_dct_dc_size_luminance[5].value = 5;
        const_dct_dc_size_luminance[6].code = 30;
        const_dct_dc_size_luminance[6].len = 5;
        const_dct_dc_size_luminance[6].value = 6;
        const_dct_dc_size_luminance[7].code = 62;
        const_dct_dc_size_luminance[7].len = 6;
        const_dct_dc_size_luminance[7].value = 7;
        const_dct_dc_size_luminance[8].code = 126;
        const_dct_dc_size_luminance[8].len = 7;
        const_dct_dc_size_luminance[8].value = 8;
        const_dct_dc_size_luminance[9].code = 254;
        const_dct_dc_size_luminance[9].len = 8;
        const_dct_dc_size_luminance[9].value = 9;
        const_dct_dc_size_luminance[10].code = 510;
        const_dct_dc_size_luminance[10].len = 9;
        const_dct_dc_size_luminance[10].value = 10;
        const_dct_dc_size_luminance[11].code = 511;
        const_dct_dc_size_luminance[11].len = 10;
        const_dct_dc_size_luminance[11].value = 11;

        const_dct_dc_size_chrominance[0].code = 0;
        const_dct_dc_size_chrominance[0].len = 2;
        const_dct_dc_size_chrominance[0].value = 0;
        const_dct_dc_size_chrominance[1].code = 1;
        const_dct_dc_size_chrominance[1].len = 2;
        const_dct_dc_size_chrominance[1].value = 1;
        const_dct_dc_size_chrominance[2].code = 2;
        const_dct_dc_size_chrominance[2].len = 2;
        const_dct_dc_size_chrominance[2].value = 2;
        const_dct_dc_size_chrominance[3].code = 6;
        const_dct_dc_size_chrominance[3].len = 3;
        const_dct_dc_size_chrominance[3].value = 3;
        const_dct_dc_size_chrominance[4].code = 14;
        const_dct_dc_size_chrominance[4].len = 4;
        const_dct_dc_size_chrominance[4].value = 4;
        const_dct_dc_size_chrominance[5].code = 30;
        const_dct_dc_size_chrominance[5].len = 5;
        const_dct_dc_size_chrominance[5].value = 5;
        const_dct_dc_size_chrominance[6].code = 62;
        const_dct_dc_size_chrominance[6].len = 6;
        const_dct_dc_size_chrominance[6].value = 6;
        const_dct_dc_size_chrominance[7].code = 126;
        const_dct_dc_size_chrominance[7].len = 7;
        const_dct_dc_size_chrominance[7].value = 7;
        const_dct_dc_size_chrominance[8].code = 254;
        const_dct_dc_size_chrominance[8].len = 8;
        const_dct_dc_size_chrominance[8].value = 8;
        const_dct_dc_size_chrominance[9].code = 510;
        const_dct_dc_size_chrominance[9].len = 9;
        const_dct_dc_size_chrominance[9].value = 9;
        const_dct_dc_size_chrominance[10].code = 1022;
        const_dct_dc_size_chrominance[10].len = 10;
        const_dct_dc_size_chrominance[10].value = 10;
        const_dct_dc_size_chrominance[11].code = 1023;
        const_dct_dc_size_chrominance[11].len = 10;
        const_dct_dc_size_chrominance[11].value = 11;

        // Note that the special codes End_of_Block and Escape
        // are left out of this table and must be checked for seperately.
        const_dct_coefficients_table_zero[0].code = 3;
        const_dct_coefficients_table_zero[0].len = 2;
        const_dct_coefficients_table_zero[0].run = 0;
        const_dct_coefficients_table_zero[0].level = 1;
        const_dct_coefficients_table_zero[1].code = 3;
        const_dct_coefficients_table_zero[1].len = 3;
        const_dct_coefficients_table_zero[1].run = 1;
        const_dct_coefficients_table_zero[1].level = 1;
        const_dct_coefficients_table_zero[2].code = 4;
        const_dct_coefficients_table_zero[2].len = 4;
        const_dct_coefficients_table_zero[2].run = 0;
        const_dct_coefficients_table_zero[2].level = 2;
        const_dct_coefficients_table_zero[3].code = 5;
        const_dct_coefficients_table_zero[3].len = 4;
        const_dct_coefficients_table_zero[3].run = 2;
        const_dct_coefficients_table_zero[3].level = 1;
        const_dct_coefficients_table_zero[4].code = 5;
        const_dct_coefficients_table_zero[4].len = 5;
        const_dct_coefficients_table_zero[4].run = 0;
        const_dct_coefficients_table_zero[4].level = 3;
        const_dct_coefficients_table_zero[5].code = 7;
        const_dct_coefficients_table_zero[5].len = 5;
        const_dct_coefficients_table_zero[5].run = 3;
        const_dct_coefficients_table_zero[5].level = 1;
        const_dct_coefficients_table_zero[6].code = 6;
        const_dct_coefficients_table_zero[6].len = 5;
        const_dct_coefficients_table_zero[6].run = 4;
        const_dct_coefficients_table_zero[6].level = 1;
        const_dct_coefficients_table_zero[7].code = 6;
        const_dct_coefficients_table_zero[7].len = 6;
        const_dct_coefficients_table_zero[7].run = 1;
        const_dct_coefficients_table_zero[7].level = 2;
        const_dct_coefficients_table_zero[8].code = 7;
        const_dct_coefficients_table_zero[8].len = 6;
        const_dct_coefficients_table_zero[8].run = 5;
        const_dct_coefficients_table_zero[8].level = 1;
        const_dct_coefficients_table_zero[9].code = 5;
        const_dct_coefficients_table_zero[9].len = 6;
        const_dct_coefficients_table_zero[9].run = 6;
        const_dct_coefficients_table_zero[9].level = 1;
        const_dct_coefficients_table_zero[10].code = 4;
        const_dct_coefficients_table_zero[10].len = 6;
        const_dct_coefficients_table_zero[10].run = 7;
        const_dct_coefficients_table_zero[10].level = 1;
        const_dct_coefficients_table_zero[11].code = 6;
        const_dct_coefficients_table_zero[11].len = 7;
        const_dct_coefficients_table_zero[11].run = 0;
        const_dct_coefficients_table_zero[11].level = 4;
        const_dct_coefficients_table_zero[12].code = 4;
        const_dct_coefficients_table_zero[12].len = 7;
        const_dct_coefficients_table_zero[12].run = 2;
        const_dct_coefficients_table_zero[12].level = 2;
        const_dct_coefficients_table_zero[13].code = 7;
        const_dct_coefficients_table_zero[13].len = 7;
        const_dct_coefficients_table_zero[13].run = 8;
        const_dct_coefficients_table_zero[13].level = 1;
        const_dct_coefficients_table_zero[14].code = 5;
        const_dct_coefficients_table_zero[14].len = 7;
        const_dct_coefficients_table_zero[14].run = 9;
        const_dct_coefficients_table_zero[14].level = 1;
        const_dct_coefficients_table_zero[15].code = 38;
        const_dct_coefficients_table_zero[15].len = 8;
        const_dct_coefficients_table_zero[15].run = 0;
        const_dct_coefficients_table_zero[15].level = 5;
        const_dct_coefficients_table_zero[16].code = 33;
        const_dct_coefficients_table_zero[16].len = 8;
        const_dct_coefficients_table_zero[16].run = 0;
        const_dct_coefficients_table_zero[16].level = 6;
        const_dct_coefficients_table_zero[17].code = 37;
        const_dct_coefficients_table_zero[17].len = 8;
        const_dct_coefficients_table_zero[17].run = 1;
        const_dct_coefficients_table_zero[17].level = 3;
        const_dct_coefficients_table_zero[18].code = 36;
        const_dct_coefficients_table_zero[18].len = 8;
        const_dct_coefficients_table_zero[18].run = 3;
        const_dct_coefficients_table_zero[18].level = 2;
        const_dct_coefficients_table_zero[19].code = 39;
        const_dct_coefficients_table_zero[19].len = 8;
        const_dct_coefficients_table_zero[19].run = 10;
        const_dct_coefficients_table_zero[19].level = 1;
        const_dct_coefficients_table_zero[20].code = 35;
        const_dct_coefficients_table_zero[20].len = 8;
        const_dct_coefficients_table_zero[20].run = 11;
        const_dct_coefficients_table_zero[20].level = 1;
        const_dct_coefficients_table_zero[21].code = 34;
        const_dct_coefficients_table_zero[21].len = 8;
        const_dct_coefficients_table_zero[21].run = 12;
        const_dct_coefficients_table_zero[21].level = 1;
        const_dct_coefficients_table_zero[22].code = 32;
        const_dct_coefficients_table_zero[22].len = 8;
        const_dct_coefficients_table_zero[22].run = 13;
        const_dct_coefficients_table_zero[22].level = 1;
        const_dct_coefficients_table_zero[23].code = 10;
        const_dct_coefficients_table_zero[23].len = 10;
        const_dct_coefficients_table_zero[23].run = 0;
        const_dct_coefficients_table_zero[23].level = 7;
        const_dct_coefficients_table_zero[24].code = 12;
        const_dct_coefficients_table_zero[24].len = 10;
        const_dct_coefficients_table_zero[24].run = 1;
        const_dct_coefficients_table_zero[24].level = 4;
        const_dct_coefficients_table_zero[25].code = 11;
        const_dct_coefficients_table_zero[25].len = 10;
        const_dct_coefficients_table_zero[25].run = 2;
        const_dct_coefficients_table_zero[25].level = 3;
        const_dct_coefficients_table_zero[26].code = 15;
        const_dct_coefficients_table_zero[26].len = 10;
        const_dct_coefficients_table_zero[26].run = 4;
        const_dct_coefficients_table_zero[26].level = 2;
        const_dct_coefficients_table_zero[27].code = 9;
        const_dct_coefficients_table_zero[27].len = 10;
        const_dct_coefficients_table_zero[27].run = 5;
        const_dct_coefficients_table_zero[27].level = 2;
        const_dct_coefficients_table_zero[28].code = 14;
        const_dct_coefficients_table_zero[28].len = 10;
        const_dct_coefficients_table_zero[28].run = 14;
        const_dct_coefficients_table_zero[28].level = 1;
        const_dct_coefficients_table_zero[29].code = 13;
        const_dct_coefficients_table_zero[29].len = 10;
        const_dct_coefficients_table_zero[29].run = 15;
        const_dct_coefficients_table_zero[29].level = 1;
        const_dct_coefficients_table_zero[30].code = 8;
        const_dct_coefficients_table_zero[30].len = 10;
        const_dct_coefficients_table_zero[30].run = 16;
        const_dct_coefficients_table_zero[30].level = 1;
        const_dct_coefficients_table_zero[31].code = 29;
        const_dct_coefficients_table_zero[31].len = 12;
        const_dct_coefficients_table_zero[31].run = 0;
        const_dct_coefficients_table_zero[31].level = 8;
        const_dct_coefficients_table_zero[32].code = 24;
        const_dct_coefficients_table_zero[32].len = 12;
        const_dct_coefficients_table_zero[32].run = 0;
        const_dct_coefficients_table_zero[32].level = 9;
        const_dct_coefficients_table_zero[33].code = 19;
        const_dct_coefficients_table_zero[33].len = 12;
        const_dct_coefficients_table_zero[33].run = 0;
        const_dct_coefficients_table_zero[33].level = 10;
        const_dct_coefficients_table_zero[34].code = 16;
        const_dct_coefficients_table_zero[34].len = 12;
        const_dct_coefficients_table_zero[34].run = 0;
        const_dct_coefficients_table_zero[34].level = 11;
        const_dct_coefficients_table_zero[35].code = 27;
        const_dct_coefficients_table_zero[35].len = 12;
        const_dct_coefficients_table_zero[35].run = 1;
        const_dct_coefficients_table_zero[35].level = 5;
        const_dct_coefficients_table_zero[36].code = 20;
        const_dct_coefficients_table_zero[36].len = 12;
        const_dct_coefficients_table_zero[36].run = 2;
        const_dct_coefficients_table_zero[36].level = 4;
        const_dct_coefficients_table_zero[37].code = 28;
        const_dct_coefficients_table_zero[37].len = 12;
        const_dct_coefficients_table_zero[37].run = 3;
        const_dct_coefficients_table_zero[37].level = 3;
        const_dct_coefficients_table_zero[38].code = 18;
        const_dct_coefficients_table_zero[38].len = 12;
        const_dct_coefficients_table_zero[38].run = 4;
        const_dct_coefficients_table_zero[38].level = 3;
        const_dct_coefficients_table_zero[39].code = 30;
        const_dct_coefficients_table_zero[39].len = 12;
        const_dct_coefficients_table_zero[39].run = 6;
        const_dct_coefficients_table_zero[39].level = 2;
        const_dct_coefficients_table_zero[40].code = 21;
        const_dct_coefficients_table_zero[40].len = 12;
        const_dct_coefficients_table_zero[40].run = 7;
        const_dct_coefficients_table_zero[40].level = 2;
        const_dct_coefficients_table_zero[41].code = 17;
        const_dct_coefficients_table_zero[41].len = 12;
        const_dct_coefficients_table_zero[41].run = 8;
        const_dct_coefficients_table_zero[41].level = 2;
        const_dct_coefficients_table_zero[42].code = 31;
        const_dct_coefficients_table_zero[42].len = 12;
        const_dct_coefficients_table_zero[42].run = 17;
        const_dct_coefficients_table_zero[42].level = 1;
        const_dct_coefficients_table_zero[43].code = 26;
        const_dct_coefficients_table_zero[43].len = 12;
        const_dct_coefficients_table_zero[43].run = 18;
        const_dct_coefficients_table_zero[43].level = 1;
        const_dct_coefficients_table_zero[44].code = 25;
        const_dct_coefficients_table_zero[44].len = 12;
        const_dct_coefficients_table_zero[44].run = 19;
        const_dct_coefficients_table_zero[44].level = 1;
        const_dct_coefficients_table_zero[45].code = 23;
        const_dct_coefficients_table_zero[45].len = 12;
        const_dct_coefficients_table_zero[45].run = 20;
        const_dct_coefficients_table_zero[45].level = 1;
        const_dct_coefficients_table_zero[46].code = 22;
        const_dct_coefficients_table_zero[46].len = 12;
        const_dct_coefficients_table_zero[46].run = 21;
        const_dct_coefficients_table_zero[46].level = 1;
        const_dct_coefficients_table_zero[47].code = 26;
        const_dct_coefficients_table_zero[47].len = 13;
        const_dct_coefficients_table_zero[47].run = 0;
        const_dct_coefficients_table_zero[47].level = 12;
        const_dct_coefficients_table_zero[48].code = 25;
        const_dct_coefficients_table_zero[48].len = 13;
        const_dct_coefficients_table_zero[48].run = 0;
        const_dct_coefficients_table_zero[48].level = 13;
        const_dct_coefficients_table_zero[49].code = 24;
        const_dct_coefficients_table_zero[49].len = 13;
        const_dct_coefficients_table_zero[49].run = 0;
        const_dct_coefficients_table_zero[49].level = 14;
        const_dct_coefficients_table_zero[50].code = 23;
        const_dct_coefficients_table_zero[50].len = 13;
        const_dct_coefficients_table_zero[50].run = 0;
        const_dct_coefficients_table_zero[50].level = 15;
        const_dct_coefficients_table_zero[51].code = 22;
        const_dct_coefficients_table_zero[51].len = 13;
        const_dct_coefficients_table_zero[51].run = 1;
        const_dct_coefficients_table_zero[51].level = 6;
        const_dct_coefficients_table_zero[52].code = 21;
        const_dct_coefficients_table_zero[52].len = 13;
        const_dct_coefficients_table_zero[52].run = 1;
        const_dct_coefficients_table_zero[52].level = 7;
        const_dct_coefficients_table_zero[53].code = 20;
        const_dct_coefficients_table_zero[53].len = 13;
        const_dct_coefficients_table_zero[53].run = 2;
        const_dct_coefficients_table_zero[53].level = 5;
        const_dct_coefficients_table_zero[54].code = 19;
        const_dct_coefficients_table_zero[54].len = 13;
        const_dct_coefficients_table_zero[54].run = 3;
        const_dct_coefficients_table_zero[54].level = 4;
        const_dct_coefficients_table_zero[55].code = 18;
        const_dct_coefficients_table_zero[55].len = 13;
        const_dct_coefficients_table_zero[55].run = 5;
        const_dct_coefficients_table_zero[55].level = 3;
        const_dct_coefficients_table_zero[56].code = 17;
        const_dct_coefficients_table_zero[56].len = 13;
        const_dct_coefficients_table_zero[56].run = 9;
        const_dct_coefficients_table_zero[56].level = 2;
        const_dct_coefficients_table_zero[57].code = 16;
        const_dct_coefficients_table_zero[57].len = 13;
        const_dct_coefficients_table_zero[57].run = 10;
        const_dct_coefficients_table_zero[57].level = 2;
        const_dct_coefficients_table_zero[58].code = 31;
        const_dct_coefficients_table_zero[58].len = 13;
        const_dct_coefficients_table_zero[58].run = 22;
        const_dct_coefficients_table_zero[58].level = 1;
        const_dct_coefficients_table_zero[59].code = 30;
        const_dct_coefficients_table_zero[59].len = 13;
        const_dct_coefficients_table_zero[59].run = 23;
        const_dct_coefficients_table_zero[59].level = 1;
        const_dct_coefficients_table_zero[60].code = 29;
        const_dct_coefficients_table_zero[60].len = 13;
        const_dct_coefficients_table_zero[60].run = 24;
        const_dct_coefficients_table_zero[60].level = 1;
        const_dct_coefficients_table_zero[61].code = 28;
        const_dct_coefficients_table_zero[61].len = 13;
        const_dct_coefficients_table_zero[61].run = 25;
        const_dct_coefficients_table_zero[61].level = 1;
        const_dct_coefficients_table_zero[62].code = 27;
        const_dct_coefficients_table_zero[62].len = 13;
        const_dct_coefficients_table_zero[62].run = 26;
        const_dct_coefficients_table_zero[62].level = 1;
        const_dct_coefficients_table_zero[63].code = 31;
        const_dct_coefficients_table_zero[63].len = 14;
        const_dct_coefficients_table_zero[63].run = 0;
        const_dct_coefficients_table_zero[63].level = 16;
        const_dct_coefficients_table_zero[64].code = 30;
        const_dct_coefficients_table_zero[64].len = 14;
        const_dct_coefficients_table_zero[64].run = 0;
        const_dct_coefficients_table_zero[64].level = 17;
        const_dct_coefficients_table_zero[65].code = 29;
        const_dct_coefficients_table_zero[65].len = 14;
        const_dct_coefficients_table_zero[65].run = 0;
        const_dct_coefficients_table_zero[65].level = 18;
        const_dct_coefficients_table_zero[66].code = 28;
        const_dct_coefficients_table_zero[66].len = 14;
        const_dct_coefficients_table_zero[66].run = 0;
        const_dct_coefficients_table_zero[66].level = 19;
        const_dct_coefficients_table_zero[67].code = 27;
        const_dct_coefficients_table_zero[67].len = 14;
        const_dct_coefficients_table_zero[67].run = 0;
        const_dct_coefficients_table_zero[67].level = 20;
        const_dct_coefficients_table_zero[68].code = 26;
        const_dct_coefficients_table_zero[68].len = 14;
        const_dct_coefficients_table_zero[68].run = 0;
        const_dct_coefficients_table_zero[68].level = 21;
        const_dct_coefficients_table_zero[69].code = 25;
        const_dct_coefficients_table_zero[69].len = 14;
        const_dct_coefficients_table_zero[69].run = 0;
        const_dct_coefficients_table_zero[69].level = 22;
        const_dct_coefficients_table_zero[70].code = 24;
        const_dct_coefficients_table_zero[70].len = 14;
        const_dct_coefficients_table_zero[70].run = 0;
        const_dct_coefficients_table_zero[70].level = 23;
        const_dct_coefficients_table_zero[71].code = 23;
        const_dct_coefficients_table_zero[71].len = 14;
        const_dct_coefficients_table_zero[71].run = 0;
        const_dct_coefficients_table_zero[71].level = 24;
        const_dct_coefficients_table_zero[72].code = 22;
        const_dct_coefficients_table_zero[72].len = 14;
        const_dct_coefficients_table_zero[72].run = 0;
        const_dct_coefficients_table_zero[72].level = 25;
        const_dct_coefficients_table_zero[73].code = 21;
        const_dct_coefficients_table_zero[73].len = 14;
        const_dct_coefficients_table_zero[73].run = 0;
        const_dct_coefficients_table_zero[73].level = 26;
        const_dct_coefficients_table_zero[74].code = 20;
        const_dct_coefficients_table_zero[74].len = 14;
        const_dct_coefficients_table_zero[74].run = 0;
        const_dct_coefficients_table_zero[74].level = 27;
        const_dct_coefficients_table_zero[75].code = 19;
        const_dct_coefficients_table_zero[75].len = 14;
        const_dct_coefficients_table_zero[75].run = 0;
        const_dct_coefficients_table_zero[75].level = 28;
        const_dct_coefficients_table_zero[76].code = 18;
        const_dct_coefficients_table_zero[76].len = 14;
        const_dct_coefficients_table_zero[76].run = 0;
        const_dct_coefficients_table_zero[76].level = 29;
        const_dct_coefficients_table_zero[77].code = 17;
        const_dct_coefficients_table_zero[77].len = 14;
        const_dct_coefficients_table_zero[77].run = 0;
        const_dct_coefficients_table_zero[77].level = 30;
        const_dct_coefficients_table_zero[78].code = 16;
        const_dct_coefficients_table_zero[78].len = 14;
        const_dct_coefficients_table_zero[78].run = 0;
        const_dct_coefficients_table_zero[78].level = 31;
        const_dct_coefficients_table_zero[79].code = 24;
        const_dct_coefficients_table_zero[79].len = 15;
        const_dct_coefficients_table_zero[79].run = 0;
        const_dct_coefficients_table_zero[79].level = 32;
        const_dct_coefficients_table_zero[80].code = 23;
        const_dct_coefficients_table_zero[80].len = 15;
        const_dct_coefficients_table_zero[80].run = 0;
        const_dct_coefficients_table_zero[80].level = 33;
        const_dct_coefficients_table_zero[81].code = 22;
        const_dct_coefficients_table_zero[81].len = 15;
        const_dct_coefficients_table_zero[81].run = 0;
        const_dct_coefficients_table_zero[81].level = 34;
        const_dct_coefficients_table_zero[82].code = 21;
        const_dct_coefficients_table_zero[82].len = 15;
        const_dct_coefficients_table_zero[82].run = 0;
        const_dct_coefficients_table_zero[82].level = 35;
        const_dct_coefficients_table_zero[83].code = 20;
        const_dct_coefficients_table_zero[83].len = 15;
        const_dct_coefficients_table_zero[83].run = 0;
        const_dct_coefficients_table_zero[83].level = 36;
        const_dct_coefficients_table_zero[84].code = 19;
        const_dct_coefficients_table_zero[84].len = 15;
        const_dct_coefficients_table_zero[84].run = 0;
        const_dct_coefficients_table_zero[84].level = 37;
        const_dct_coefficients_table_zero[85].code = 18;
        const_dct_coefficients_table_zero[85].len = 15;
        const_dct_coefficients_table_zero[85].run = 0;
        const_dct_coefficients_table_zero[85].level = 38;
        const_dct_coefficients_table_zero[86].code = 17;
        const_dct_coefficients_table_zero[86].len = 15;
        const_dct_coefficients_table_zero[86].run = 0;
        const_dct_coefficients_table_zero[86].level = 39;
        const_dct_coefficients_table_zero[87].code = 16;
        const_dct_coefficients_table_zero[87].len = 15;
        const_dct_coefficients_table_zero[87].run = 0;
        const_dct_coefficients_table_zero[87].level = 40;
        const_dct_coefficients_table_zero[88].code = 31;
        const_dct_coefficients_table_zero[88].len = 15;
        const_dct_coefficients_table_zero[88].run = 1;
        const_dct_coefficients_table_zero[88].level = 8;
        const_dct_coefficients_table_zero[89].code = 30;
        const_dct_coefficients_table_zero[89].len = 15;
        const_dct_coefficients_table_zero[89].run = 1;
        const_dct_coefficients_table_zero[89].level = 9;
        const_dct_coefficients_table_zero[90].code = 29;
        const_dct_coefficients_table_zero[90].len = 15;
        const_dct_coefficients_table_zero[90].run = 1;
        const_dct_coefficients_table_zero[90].level = 10;
        const_dct_coefficients_table_zero[91].code = 28;
        const_dct_coefficients_table_zero[91].len = 15;
        const_dct_coefficients_table_zero[91].run = 1;
        const_dct_coefficients_table_zero[91].level = 11;
        const_dct_coefficients_table_zero[92].code = 27;
        const_dct_coefficients_table_zero[92].len = 15;
        const_dct_coefficients_table_zero[92].run = 1;
        const_dct_coefficients_table_zero[92].level = 12;
        const_dct_coefficients_table_zero[93].code = 26;
        const_dct_coefficients_table_zero[93].len = 15;
        const_dct_coefficients_table_zero[93].run = 1;
        const_dct_coefficients_table_zero[93].level = 13;
        const_dct_coefficients_table_zero[94].code = 25;
        const_dct_coefficients_table_zero[94].len = 15;
        const_dct_coefficients_table_zero[94].run = 1;
        const_dct_coefficients_table_zero[94].level = 14;
        const_dct_coefficients_table_zero[95].code = 19;
        const_dct_coefficients_table_zero[95].len = 16;
        const_dct_coefficients_table_zero[95].run = 1;
        const_dct_coefficients_table_zero[95].level = 15;
        const_dct_coefficients_table_zero[96].code = 18;
        const_dct_coefficients_table_zero[96].len = 16;
        const_dct_coefficients_table_zero[96].run = 1;
        const_dct_coefficients_table_zero[96].level = 16;
        const_dct_coefficients_table_zero[97].code = 17;
        const_dct_coefficients_table_zero[97].len = 16;
        const_dct_coefficients_table_zero[97].run = 1;
        const_dct_coefficients_table_zero[97].level = 17;
        const_dct_coefficients_table_zero[98].code = 16;
        const_dct_coefficients_table_zero[98].len = 16;
        const_dct_coefficients_table_zero[98].run = 1;
        const_dct_coefficients_table_zero[98].level = 18;
        const_dct_coefficients_table_zero[99].code = 20;
        const_dct_coefficients_table_zero[99].len = 16;
        const_dct_coefficients_table_zero[99].run = 6;
        const_dct_coefficients_table_zero[99].level = 3;
        const_dct_coefficients_table_zero[100].code = 26;
        const_dct_coefficients_table_zero[100].len = 16;
        const_dct_coefficients_table_zero[100].run = 11;
        const_dct_coefficients_table_zero[100].level = 2;
        const_dct_coefficients_table_zero[101].code = 25;
        const_dct_coefficients_table_zero[101].len = 16;
        const_dct_coefficients_table_zero[101].run = 12;
        const_dct_coefficients_table_zero[101].level = 2;
        const_dct_coefficients_table_zero[102].code = 24;
        const_dct_coefficients_table_zero[102].len = 16;
        const_dct_coefficients_table_zero[102].run = 13;
        const_dct_coefficients_table_zero[102].level = 2;
        const_dct_coefficients_table_zero[103].code = 23;
        const_dct_coefficients_table_zero[103].len = 16;
        const_dct_coefficients_table_zero[103].run = 14;
        const_dct_coefficients_table_zero[103].level = 2;
        const_dct_coefficients_table_zero[104].code = 22;
        const_dct_coefficients_table_zero[104].len = 16;
        const_dct_coefficients_table_zero[104].run = 15;
        const_dct_coefficients_table_zero[104].level = 2;
        const_dct_coefficients_table_zero[105].code = 21;
        const_dct_coefficients_table_zero[105].len = 16;
        const_dct_coefficients_table_zero[105].run = 16;
        const_dct_coefficients_table_zero[105].level = 2;
        const_dct_coefficients_table_zero[106].code = 31;
        const_dct_coefficients_table_zero[106].len = 16;
        const_dct_coefficients_table_zero[106].run = 27;
        const_dct_coefficients_table_zero[106].level = 1;
        const_dct_coefficients_table_zero[107].code = 30;
        const_dct_coefficients_table_zero[107].len = 16;
        const_dct_coefficients_table_zero[107].run = 28;
        const_dct_coefficients_table_zero[107].level = 1;
        const_dct_coefficients_table_zero[108].code = 29;
        const_dct_coefficients_table_zero[108].len = 16;
        const_dct_coefficients_table_zero[108].run = 29;
        const_dct_coefficients_table_zero[108].level = 1;
        const_dct_coefficients_table_zero[109].code = 28;
        const_dct_coefficients_table_zero[109].len = 16;
        const_dct_coefficients_table_zero[109].run = 30;
        const_dct_coefficients_table_zero[109].level = 1;
        const_dct_coefficients_table_zero[110].code = 27;
        const_dct_coefficients_table_zero[110].len = 16;
        const_dct_coefficients_table_zero[110].run = 31;
        const_dct_coefficients_table_zero[110].level = 1;

        // Table B14, reordered for an optimized huffman scan
        // intra_vlc_format == 1, macroblock_intra == 0
        const_dct_coefficients_table_zero_len16[0].code = 16;
        const_dct_coefficients_table_zero_len16[0].len = 16;
        const_dct_coefficients_table_zero_len16[0].run = 1;
        const_dct_coefficients_table_zero_len16[0].level = 18;
        const_dct_coefficients_table_zero_len16[1].code = 17;
        const_dct_coefficients_table_zero_len16[1].len = 16;
        const_dct_coefficients_table_zero_len16[1].run = 1;
        const_dct_coefficients_table_zero_len16[1].level = 17;
        const_dct_coefficients_table_zero_len16[2].code = 18;
        const_dct_coefficients_table_zero_len16[2].len = 16;
        const_dct_coefficients_table_zero_len16[2].run = 1;
        const_dct_coefficients_table_zero_len16[2].level = 16;
        const_dct_coefficients_table_zero_len16[3].code = 19;
        const_dct_coefficients_table_zero_len16[3].len = 16;
        const_dct_coefficients_table_zero_len16[3].run = 1;
        const_dct_coefficients_table_zero_len16[3].level = 15;
        const_dct_coefficients_table_zero_len16[4].code = 20;
        const_dct_coefficients_table_zero_len16[4].len = 16;
        const_dct_coefficients_table_zero_len16[4].run = 6;
        const_dct_coefficients_table_zero_len16[4].level = 3;
        const_dct_coefficients_table_zero_len16[5].code = 21;
        const_dct_coefficients_table_zero_len16[5].len = 16;
        const_dct_coefficients_table_zero_len16[5].run = 16;
        const_dct_coefficients_table_zero_len16[5].level = 2;
        const_dct_coefficients_table_zero_len16[6].code = 22;
        const_dct_coefficients_table_zero_len16[6].len = 16;
        const_dct_coefficients_table_zero_len16[6].run = 15;
        const_dct_coefficients_table_zero_len16[6].level = 2;
        const_dct_coefficients_table_zero_len16[7].code = 23;
        const_dct_coefficients_table_zero_len16[7].len = 16;
        const_dct_coefficients_table_zero_len16[7].run = 14;
        const_dct_coefficients_table_zero_len16[7].level = 2;
        const_dct_coefficients_table_zero_len16[8].code = 24;
        const_dct_coefficients_table_zero_len16[8].len = 16;
        const_dct_coefficients_table_zero_len16[8].run = 13;
        const_dct_coefficients_table_zero_len16[8].level = 2;
        const_dct_coefficients_table_zero_len16[9].code = 25;
        const_dct_coefficients_table_zero_len16[9].len = 16;
        const_dct_coefficients_table_zero_len16[9].run = 12;
        const_dct_coefficients_table_zero_len16[9].level = 2;
        const_dct_coefficients_table_zero_len16[10].code = 26;
        const_dct_coefficients_table_zero_len16[10].len = 16;
        const_dct_coefficients_table_zero_len16[10].run = 11;
        const_dct_coefficients_table_zero_len16[10].level = 2;
        const_dct_coefficients_table_zero_len16[11].code = 27;
        const_dct_coefficients_table_zero_len16[11].len = 16;
        const_dct_coefficients_table_zero_len16[11].run = 31;
        const_dct_coefficients_table_zero_len16[11].level = 1;
        const_dct_coefficients_table_zero_len16[12].code = 28;
        const_dct_coefficients_table_zero_len16[12].len = 16;
        const_dct_coefficients_table_zero_len16[12].run = 30;
        const_dct_coefficients_table_zero_len16[12].level = 1;
        const_dct_coefficients_table_zero_len16[13].code = 29;
        const_dct_coefficients_table_zero_len16[13].len = 16;
        const_dct_coefficients_table_zero_len16[13].run = 29;
        const_dct_coefficients_table_zero_len16[13].level = 1;
        const_dct_coefficients_table_zero_len16[14].code = 30;
        const_dct_coefficients_table_zero_len16[14].len = 16;
        const_dct_coefficients_table_zero_len16[14].run = 28;
        const_dct_coefficients_table_zero_len16[14].level = 1;
        const_dct_coefficients_table_zero_len16[15].code = 31;
        const_dct_coefficients_table_zero_len16[15].len = 16;
        const_dct_coefficients_table_zero_len16[15].run = 27;
        const_dct_coefficients_table_zero_len16[15].level = 1;

        const_dct_coefficients_table_zero_len15[0].code = 16;
        const_dct_coefficients_table_zero_len15[0].len = 15;
        const_dct_coefficients_table_zero_len15[0].run = 0;
        const_dct_coefficients_table_zero_len15[0].level = 40;
        const_dct_coefficients_table_zero_len15[1].code = 17;
        const_dct_coefficients_table_zero_len15[1].len = 15;
        const_dct_coefficients_table_zero_len15[1].run = 0;
        const_dct_coefficients_table_zero_len15[1].level = 39;
        const_dct_coefficients_table_zero_len15[2].code = 18;
        const_dct_coefficients_table_zero_len15[2].len = 15;
        const_dct_coefficients_table_zero_len15[2].run = 0;
        const_dct_coefficients_table_zero_len15[2].level = 38;
        const_dct_coefficients_table_zero_len15[3].code = 19;
        const_dct_coefficients_table_zero_len15[3].len = 15;
        const_dct_coefficients_table_zero_len15[3].run = 0;
        const_dct_coefficients_table_zero_len15[3].level = 37;
        const_dct_coefficients_table_zero_len15[4].code = 20;
        const_dct_coefficients_table_zero_len15[4].len = 15;
        const_dct_coefficients_table_zero_len15[4].run = 0;
        const_dct_coefficients_table_zero_len15[4].level = 36;
        const_dct_coefficients_table_zero_len15[5].code = 21;
        const_dct_coefficients_table_zero_len15[5].len = 15;
        const_dct_coefficients_table_zero_len15[5].run = 0;
        const_dct_coefficients_table_zero_len15[5].level = 35;
        const_dct_coefficients_table_zero_len15[6].code = 22;
        const_dct_coefficients_table_zero_len15[6].len = 15;
        const_dct_coefficients_table_zero_len15[6].run = 0;
        const_dct_coefficients_table_zero_len15[6].level = 34;
        const_dct_coefficients_table_zero_len15[7].code = 23;
        const_dct_coefficients_table_zero_len15[7].len = 15;
        const_dct_coefficients_table_zero_len15[7].run = 0;
        const_dct_coefficients_table_zero_len15[7].level = 33;
        const_dct_coefficients_table_zero_len15[8].code = 24;
        const_dct_coefficients_table_zero_len15[8].len = 15;
        const_dct_coefficients_table_zero_len15[8].run = 0;
        const_dct_coefficients_table_zero_len15[8].level = 32;
        const_dct_coefficients_table_zero_len15[9].code = 25;
        const_dct_coefficients_table_zero_len15[9].len = 15;
        const_dct_coefficients_table_zero_len15[9].run = 1;
        const_dct_coefficients_table_zero_len15[9].level = 14;
        const_dct_coefficients_table_zero_len15[10].code = 26;
        const_dct_coefficients_table_zero_len15[10].len = 15;
        const_dct_coefficients_table_zero_len15[10].run = 1;
        const_dct_coefficients_table_zero_len15[10].level = 13;
        const_dct_coefficients_table_zero_len15[11].code = 27;
        const_dct_coefficients_table_zero_len15[11].len = 15;
        const_dct_coefficients_table_zero_len15[11].run = 1;
        const_dct_coefficients_table_zero_len15[11].level = 12;
        const_dct_coefficients_table_zero_len15[12].code = 28;
        const_dct_coefficients_table_zero_len15[12].len = 15;
        const_dct_coefficients_table_zero_len15[12].run = 1;
        const_dct_coefficients_table_zero_len15[12].level = 11;
        const_dct_coefficients_table_zero_len15[13].code = 29;
        const_dct_coefficients_table_zero_len15[13].len = 15;
        const_dct_coefficients_table_zero_len15[13].run = 1;
        const_dct_coefficients_table_zero_len15[13].level = 10;
        const_dct_coefficients_table_zero_len15[14].code = 30;
        const_dct_coefficients_table_zero_len15[14].len = 15;
        const_dct_coefficients_table_zero_len15[14].run = 1;
        const_dct_coefficients_table_zero_len15[14].level = 9;
        const_dct_coefficients_table_zero_len15[15].code = 31;
        const_dct_coefficients_table_zero_len15[15].len = 15;
        const_dct_coefficients_table_zero_len15[15].run = 1;
        const_dct_coefficients_table_zero_len15[15].level = 8;

        const_dct_coefficients_table_zero_len14[0].code = 16;
        const_dct_coefficients_table_zero_len14[0].len = 14;
        const_dct_coefficients_table_zero_len14[0].run = 0;
        const_dct_coefficients_table_zero_len14[0].level = 31;
        const_dct_coefficients_table_zero_len14[1].code = 17;
        const_dct_coefficients_table_zero_len14[1].len = 14;
        const_dct_coefficients_table_zero_len14[1].run = 0;
        const_dct_coefficients_table_zero_len14[1].level = 30;
        const_dct_coefficients_table_zero_len14[2].code = 18;
        const_dct_coefficients_table_zero_len14[2].len = 14;
        const_dct_coefficients_table_zero_len14[2].run = 0;
        const_dct_coefficients_table_zero_len14[2].level = 29;
        const_dct_coefficients_table_zero_len14[3].code = 19;
        const_dct_coefficients_table_zero_len14[3].len = 14;
        const_dct_coefficients_table_zero_len14[3].run = 0;
        const_dct_coefficients_table_zero_len14[3].level = 28;
        const_dct_coefficients_table_zero_len14[4].code = 20;
        const_dct_coefficients_table_zero_len14[4].len = 14;
        const_dct_coefficients_table_zero_len14[4].run = 0;
        const_dct_coefficients_table_zero_len14[4].level = 27;
        const_dct_coefficients_table_zero_len14[5].code = 21;
        const_dct_coefficients_table_zero_len14[5].len = 14;
        const_dct_coefficients_table_zero_len14[5].run = 0;
        const_dct_coefficients_table_zero_len14[5].level = 26;
        const_dct_coefficients_table_zero_len14[6].code = 22;
        const_dct_coefficients_table_zero_len14[6].len = 14;
        const_dct_coefficients_table_zero_len14[6].run = 0;
        const_dct_coefficients_table_zero_len14[6].level = 25;
        const_dct_coefficients_table_zero_len14[7].code = 23;
        const_dct_coefficients_table_zero_len14[7].len = 14;
        const_dct_coefficients_table_zero_len14[7].run = 0;
        const_dct_coefficients_table_zero_len14[7].level = 24;
        const_dct_coefficients_table_zero_len14[8].code = 24;
        const_dct_coefficients_table_zero_len14[8].len = 14;
        const_dct_coefficients_table_zero_len14[8].run = 0;
        const_dct_coefficients_table_zero_len14[8].level = 23;
        const_dct_coefficients_table_zero_len14[9].code = 25;
        const_dct_coefficients_table_zero_len14[9].len = 14;
        const_dct_coefficients_table_zero_len14[9].run = 0;
        const_dct_coefficients_table_zero_len14[9].level = 22;
        const_dct_coefficients_table_zero_len14[10].code = 26;
        const_dct_coefficients_table_zero_len14[10].len = 14;
        const_dct_coefficients_table_zero_len14[10].run = 0;
        const_dct_coefficients_table_zero_len14[10].level = 21;
        const_dct_coefficients_table_zero_len14[11].code = 27;
        const_dct_coefficients_table_zero_len14[11].len = 14;
        const_dct_coefficients_table_zero_len14[11].run = 0;
        const_dct_coefficients_table_zero_len14[11].level = 20;
        const_dct_coefficients_table_zero_len14[12].code = 28;
        const_dct_coefficients_table_zero_len14[12].len = 14;
        const_dct_coefficients_table_zero_len14[12].run = 0;
        const_dct_coefficients_table_zero_len14[12].level = 19;
        const_dct_coefficients_table_zero_len14[13].code = 29;
        const_dct_coefficients_table_zero_len14[13].len = 14;
        const_dct_coefficients_table_zero_len14[13].run = 0;
        const_dct_coefficients_table_zero_len14[13].level = 18;
        const_dct_coefficients_table_zero_len14[14].code = 30;
        const_dct_coefficients_table_zero_len14[14].len = 14;
        const_dct_coefficients_table_zero_len14[14].run = 0;
        const_dct_coefficients_table_zero_len14[14].level = 17;
        const_dct_coefficients_table_zero_len14[15].code = 31;
        const_dct_coefficients_table_zero_len14[15].len = 14;
        const_dct_coefficients_table_zero_len14[15].run = 0;
        const_dct_coefficients_table_zero_len14[15].level = 16;

        const_dct_coefficients_table_zero_len13[0].code = 16;
        const_dct_coefficients_table_zero_len13[0].len = 13;
        const_dct_coefficients_table_zero_len13[0].run = 10;
        const_dct_coefficients_table_zero_len13[0].level = 2;
        const_dct_coefficients_table_zero_len13[1].code = 17;
        const_dct_coefficients_table_zero_len13[1].len = 13;
        const_dct_coefficients_table_zero_len13[1].run = 9;
        const_dct_coefficients_table_zero_len13[1].level = 2;
        const_dct_coefficients_table_zero_len13[2].code = 18;
        const_dct_coefficients_table_zero_len13[2].len = 13;
        const_dct_coefficients_table_zero_len13[2].run = 5;
        const_dct_coefficients_table_zero_len13[2].level = 3;
        const_dct_coefficients_table_zero_len13[3].code = 19;
        const_dct_coefficients_table_zero_len13[3].len = 13;
        const_dct_coefficients_table_zero_len13[3].run = 3;
        const_dct_coefficients_table_zero_len13[3].level = 4;
        const_dct_coefficients_table_zero_len13[4].code = 20;
        const_dct_coefficients_table_zero_len13[4].len = 13;
        const_dct_coefficients_table_zero_len13[4].run = 2;
        const_dct_coefficients_table_zero_len13[4].level = 5;
        const_dct_coefficients_table_zero_len13[5].code = 21;
        const_dct_coefficients_table_zero_len13[5].len = 13;
        const_dct_coefficients_table_zero_len13[5].run = 1;
        const_dct_coefficients_table_zero_len13[5].level = 7;
        const_dct_coefficients_table_zero_len13[6].code = 22;
        const_dct_coefficients_table_zero_len13[6].len = 13;
        const_dct_coefficients_table_zero_len13[6].run = 1;
        const_dct_coefficients_table_zero_len13[6].level = 6;
        const_dct_coefficients_table_zero_len13[7].code = 23;
        const_dct_coefficients_table_zero_len13[7].len = 13;
        const_dct_coefficients_table_zero_len13[7].run = 0;
        const_dct_coefficients_table_zero_len13[7].level = 15;
        const_dct_coefficients_table_zero_len13[8].code = 24;
        const_dct_coefficients_table_zero_len13[8].len = 13;
        const_dct_coefficients_table_zero_len13[8].run = 0;
        const_dct_coefficients_table_zero_len13[8].level = 14;
        const_dct_coefficients_table_zero_len13[9].code = 25;
        const_dct_coefficients_table_zero_len13[9].len = 13;
        const_dct_coefficients_table_zero_len13[9].run = 0;
        const_dct_coefficients_table_zero_len13[9].level = 13;
        const_dct_coefficients_table_zero_len13[10].code = 26;
        const_dct_coefficients_table_zero_len13[10].len = 13;
        const_dct_coefficients_table_zero_len13[10].run = 0;
        const_dct_coefficients_table_zero_len13[10].level = 12;
        const_dct_coefficients_table_zero_len13[11].code = 27;
        const_dct_coefficients_table_zero_len13[11].len = 13;
        const_dct_coefficients_table_zero_len13[11].run = 26;
        const_dct_coefficients_table_zero_len13[11].level = 1;
        const_dct_coefficients_table_zero_len13[12].code = 28;
        const_dct_coefficients_table_zero_len13[12].len = 13;
        const_dct_coefficients_table_zero_len13[12].run = 25;
        const_dct_coefficients_table_zero_len13[12].level = 1;
        const_dct_coefficients_table_zero_len13[13].code = 29;
        const_dct_coefficients_table_zero_len13[13].len = 13;
        const_dct_coefficients_table_zero_len13[13].run = 24;
        const_dct_coefficients_table_zero_len13[13].level = 1;
        const_dct_coefficients_table_zero_len13[14].code = 30;
        const_dct_coefficients_table_zero_len13[14].len = 13;
        const_dct_coefficients_table_zero_len13[14].run = 23;
        const_dct_coefficients_table_zero_len13[14].level = 1;
        const_dct_coefficients_table_zero_len13[15].code = 31;
        const_dct_coefficients_table_zero_len13[15].len = 13;
        const_dct_coefficients_table_zero_len13[15].run = 22;
        const_dct_coefficients_table_zero_len13[15].level = 1;

        const_dct_coefficients_table_zero_len12[0].code = 16;
        const_dct_coefficients_table_zero_len12[0].len = 12;
        const_dct_coefficients_table_zero_len12[0].run = 0;
        const_dct_coefficients_table_zero_len12[0].level = 11;
        const_dct_coefficients_table_zero_len12[1].code = 17;
        const_dct_coefficients_table_zero_len12[1].len = 12;
        const_dct_coefficients_table_zero_len12[1].run = 8;
        const_dct_coefficients_table_zero_len12[1].level = 2;
        const_dct_coefficients_table_zero_len12[2].code = 18;
        const_dct_coefficients_table_zero_len12[2].len = 12;
        const_dct_coefficients_table_zero_len12[2].run = 4;
        const_dct_coefficients_table_zero_len12[2].level = 3;
        const_dct_coefficients_table_zero_len12[3].code = 19;
        const_dct_coefficients_table_zero_len12[3].len = 12;
        const_dct_coefficients_table_zero_len12[3].run = 0;
        const_dct_coefficients_table_zero_len12[3].level = 10;
        const_dct_coefficients_table_zero_len12[4].code = 20;
        const_dct_coefficients_table_zero_len12[4].len = 12;
        const_dct_coefficients_table_zero_len12[4].run = 2;
        const_dct_coefficients_table_zero_len12[4].level = 4;
        const_dct_coefficients_table_zero_len12[5].code = 21;
        const_dct_coefficients_table_zero_len12[5].len = 12;
        const_dct_coefficients_table_zero_len12[5].run = 7;
        const_dct_coefficients_table_zero_len12[5].level = 2;
        const_dct_coefficients_table_zero_len12[6].code = 22;
        const_dct_coefficients_table_zero_len12[6].len = 12;
        const_dct_coefficients_table_zero_len12[6].run = 21;
        const_dct_coefficients_table_zero_len12[6].level = 1;
        const_dct_coefficients_table_zero_len12[7].code = 23;
        const_dct_coefficients_table_zero_len12[7].len = 12;
        const_dct_coefficients_table_zero_len12[7].run = 20;
        const_dct_coefficients_table_zero_len12[7].level = 1;
        const_dct_coefficients_table_zero_len12[8].code = 24;
        const_dct_coefficients_table_zero_len12[8].len = 12;
        const_dct_coefficients_table_zero_len12[8].run = 0;
        const_dct_coefficients_table_zero_len12[8].level = 9;
        const_dct_coefficients_table_zero_len12[9].code = 25;
        const_dct_coefficients_table_zero_len12[9].len = 12;
        const_dct_coefficients_table_zero_len12[9].run = 19;
        const_dct_coefficients_table_zero_len12[9].level = 1;
        const_dct_coefficients_table_zero_len12[10].code = 26;
        const_dct_coefficients_table_zero_len12[10].len = 12;
        const_dct_coefficients_table_zero_len12[10].run = 18;
        const_dct_coefficients_table_zero_len12[10].level = 1;
        const_dct_coefficients_table_zero_len12[11].code = 27;
        const_dct_coefficients_table_zero_len12[11].len = 12;
        const_dct_coefficients_table_zero_len12[11].run = 1;
        const_dct_coefficients_table_zero_len12[11].level = 5;
        const_dct_coefficients_table_zero_len12[12].code = 28;
        const_dct_coefficients_table_zero_len12[12].len = 12;
        const_dct_coefficients_table_zero_len12[12].run = 3;
        const_dct_coefficients_table_zero_len12[12].level = 3;
        const_dct_coefficients_table_zero_len12[13].code = 29;
        const_dct_coefficients_table_zero_len12[13].len = 12;
        const_dct_coefficients_table_zero_len12[13].run = 0;
        const_dct_coefficients_table_zero_len12[13].level = 8;
        const_dct_coefficients_table_zero_len12[14].code = 30;
        const_dct_coefficients_table_zero_len12[14].len = 12;
        const_dct_coefficients_table_zero_len12[14].run = 6;
        const_dct_coefficients_table_zero_len12[14].level = 2;
        const_dct_coefficients_table_zero_len12[15].code = 31;
        const_dct_coefficients_table_zero_len12[15].len = 12;
        const_dct_coefficients_table_zero_len12[15].run = 17;
        const_dct_coefficients_table_zero_len12[15].level = 1;

        const_dct_coefficients_table_zero_len10[0].code = 8;
        const_dct_coefficients_table_zero_len10[0].len = 10;
        const_dct_coefficients_table_zero_len10[0].run = 16;
        const_dct_coefficients_table_zero_len10[0].level = 1;
        const_dct_coefficients_table_zero_len10[1].code = 9;
        const_dct_coefficients_table_zero_len10[1].len = 10;
        const_dct_coefficients_table_zero_len10[1].run = 5;
        const_dct_coefficients_table_zero_len10[1].level = 2;
        const_dct_coefficients_table_zero_len10[2].code = 10;
        const_dct_coefficients_table_zero_len10[2].len = 10;
        const_dct_coefficients_table_zero_len10[2].run = 0;
        const_dct_coefficients_table_zero_len10[2].level = 7;
        const_dct_coefficients_table_zero_len10[3].code = 11;
        const_dct_coefficients_table_zero_len10[3].len = 10;
        const_dct_coefficients_table_zero_len10[3].run = 2;
        const_dct_coefficients_table_zero_len10[3].level = 3;
        const_dct_coefficients_table_zero_len10[4].code = 20;
        const_dct_coefficients_table_zero_len10[4].len = 10;
        const_dct_coefficients_table_zero_len10[4].run = 1;
        const_dct_coefficients_table_zero_len10[4].level = 4;
        const_dct_coefficients_table_zero_len10[5].code = 13;
        const_dct_coefficients_table_zero_len10[5].len = 10;
        const_dct_coefficients_table_zero_len10[5].run = 15;
        const_dct_coefficients_table_zero_len10[5].level = 1;
        const_dct_coefficients_table_zero_len10[6].code = 14;
        const_dct_coefficients_table_zero_len10[6].len = 10;
        const_dct_coefficients_table_zero_len10[6].run = 14;
        const_dct_coefficients_table_zero_len10[6].level = 1;
        const_dct_coefficients_table_zero_len10[7].code = 15;
        const_dct_coefficients_table_zero_len10[7].len = 10;
        const_dct_coefficients_table_zero_len10[7].run = 4;
        const_dct_coefficients_table_zero_len10[7].level = 2;

        const_dct_coefficients_table_zero_len8[0].code = 32;
        const_dct_coefficients_table_zero_len8[0].len = 8;
        const_dct_coefficients_table_zero_len8[0].run = 13;
        const_dct_coefficients_table_zero_len8[0].level = 1;
        const_dct_coefficients_table_zero_len8[1].code = 33;
        const_dct_coefficients_table_zero_len8[1].len = 8;
        const_dct_coefficients_table_zero_len8[1].run = 0;
        const_dct_coefficients_table_zero_len8[1].level = 6;
        const_dct_coefficients_table_zero_len8[2].code = 34;
        const_dct_coefficients_table_zero_len8[2].len = 8;
        const_dct_coefficients_table_zero_len8[2].run = 12;
        const_dct_coefficients_table_zero_len8[2].level = 1;
        const_dct_coefficients_table_zero_len8[3].code = 35;
        const_dct_coefficients_table_zero_len8[3].len = 8;
        const_dct_coefficients_table_zero_len8[3].run = 11;
        const_dct_coefficients_table_zero_len8[3].level = 1;
        const_dct_coefficients_table_zero_len8[4].code = 36;
        const_dct_coefficients_table_zero_len8[4].len = 8;
        const_dct_coefficients_table_zero_len8[4].run = 3;
        const_dct_coefficients_table_zero_len8[4].level = 2;
        const_dct_coefficients_table_zero_len8[5].code = 37;
        const_dct_coefficients_table_zero_len8[5].len = 8;
        const_dct_coefficients_table_zero_len8[5].run = 1;
        const_dct_coefficients_table_zero_len8[5].level = 3;
        const_dct_coefficients_table_zero_len8[6].code = 38;
        const_dct_coefficients_table_zero_len8[6].len = 8;
        const_dct_coefficients_table_zero_len8[6].run = 0;
        const_dct_coefficients_table_zero_len8[6].level = 5;
        const_dct_coefficients_table_zero_len8[7].code = 39;
        const_dct_coefficients_table_zero_len8[7].len = 8;
        const_dct_coefficients_table_zero_len8[7].run = 10;
        const_dct_coefficients_table_zero_len8[7].level = 1; 

        const_dct_coefficients_table_zero_len7[0].code = 4;
        const_dct_coefficients_table_zero_len7[0].len = 7;
        const_dct_coefficients_table_zero_len7[0].run = 2;
        const_dct_coefficients_table_zero_len7[0].level = 2;
        const_dct_coefficients_table_zero_len7[1].code = 5;
        const_dct_coefficients_table_zero_len7[1].len = 7;
        const_dct_coefficients_table_zero_len7[1].run = 9;
        const_dct_coefficients_table_zero_len7[1].level = 1;
        const_dct_coefficients_table_zero_len7[2].code = 6;
        const_dct_coefficients_table_zero_len7[2].len = 7;
        const_dct_coefficients_table_zero_len7[2].run = 0;
        const_dct_coefficients_table_zero_len7[2].level = 4;
        const_dct_coefficients_table_zero_len7[3].code = 7;
        const_dct_coefficients_table_zero_len7[3].len = 7;
        const_dct_coefficients_table_zero_len7[3].run = 8;
        const_dct_coefficients_table_zero_len7[3].level = 1;

        const_dct_coefficients_table_zero_len6[0].code = 4;
        const_dct_coefficients_table_zero_len6[0].len = 6;
        const_dct_coefficients_table_zero_len6[0].run = 7;
        const_dct_coefficients_table_zero_len6[0].level = 1;
        const_dct_coefficients_table_zero_len6[1].code = 5;
        const_dct_coefficients_table_zero_len6[1].len = 6;
        const_dct_coefficients_table_zero_len6[1].run = 6;
        const_dct_coefficients_table_zero_len6[1].level = 1;
        const_dct_coefficients_table_zero_len6[2].code = 6;
        const_dct_coefficients_table_zero_len6[2].len = 6;
        const_dct_coefficients_table_zero_len6[2].run = 1;
        const_dct_coefficients_table_zero_len6[2].level = 2;
        const_dct_coefficients_table_zero_len6[3].code = 7;
        const_dct_coefficients_table_zero_len6[3].len = 6;
        const_dct_coefficients_table_zero_len6[3].run = 5;
        const_dct_coefficients_table_zero_len6[3].level = 1;

        const_dct_coefficients_table_zero_len5[0].code = 5;
        const_dct_coefficients_table_zero_len5[0].len = 5;
        const_dct_coefficients_table_zero_len5[0].run = 0;
        const_dct_coefficients_table_zero_len5[0].level = 3;
        const_dct_coefficients_table_zero_len5[1].code = 6;
        const_dct_coefficients_table_zero_len5[1].len = 5;
        const_dct_coefficients_table_zero_len5[1].run = 4;
        const_dct_coefficients_table_zero_len5[1].level = 1;
        const_dct_coefficients_table_zero_len5[2].code = 7;
        const_dct_coefficients_table_zero_len5[2].len = 5;
        const_dct_coefficients_table_zero_len5[2].run = 3;
        const_dct_coefficients_table_zero_len5[2].level = 1;

        const_dct_coefficients_table_zero_len4[0].code = 4;
        const_dct_coefficients_table_zero_len4[0].len = 4;
        const_dct_coefficients_table_zero_len4[0].run = 0;
        const_dct_coefficients_table_zero_len4[0].level = 2;
        const_dct_coefficients_table_zero_len4[1].code = 5;
        const_dct_coefficients_table_zero_len4[1].len = 4;
        const_dct_coefficients_table_zero_len4[1].run = 2;
        const_dct_coefficients_table_zero_len4[1].level = 1;

        const_dct_coefficients_table_zero_len3[0].code = 3;
        const_dct_coefficients_table_zero_len3[0].len = 3;
        const_dct_coefficients_table_zero_len3[0].run = 1;
        const_dct_coefficients_table_zero_len3[0].level = 1;

        const_dct_coefficients_table_zero_len2[0].code = 3;
        const_dct_coefficients_table_zero_len2[0].len = 2;
        const_dct_coefficients_table_zero_len2[0].run = 0;
        const_dct_coefficients_table_zero_len2[0].level = 1;
                                        
    }
}
/*
 * Copyright 2005 by the Massachusetts Institute of Technology.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in
 * advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 */

/**
 * @description
 * This file contains components for converting between various different
 * color spaces.
 *
 * @author <a href="mailto:madrake@gmail.com">Matthew Drake</a>
 * @file ColorSpace.str
 * @version 1.0
 */

int->int pipeline ColorSpaceConversion_YCbCrtoRGB {
    add YCbCrtoRGB;
    add BestSaturation(0, 255, -384, 639);
    // See mpeg2dec in the reference implementation, Clip[]
}

int->int pipeline ColorSpaceConversion_RGBtoYCbCr {
    add RGBtoYCbCr;
}         


/**
 * Converts a pixel in RGB format to a pixel in YCbCr format according to Recommendation
 * ITU-R BT.709 for color space transformations. This is the default transformation that should
 * be used for MPEG-2 videos. This transformation is given in Table 6-9 on P.47 of the MPEG-2 13818-2
 * IEEE specification (entry #1). 
 * @input Three integers in RGB color space and order.
 * @output Three integers in YCbCr color space and order.
 */
int->int filter RGBtoYCbCr {
    work pop 3 push 3 {
        int R = pop();
        int G = pop();
        int B = pop();

        float ER = ((float) R)/256.0;
        float EG = ((float) G)/256.0;
        float EB = ((float) B)/256.0;

        float Ey =   0.715400*EG + 0.072100*EB + 0.212500*ER;
        float Epb = -0.386000*EG + 0.500000*EB - 0.115000*ER;
        float Epr = -0.454000*EG - 0.046000*EB + 0.500000*ER;

        int Y = (int) round((219*Ey) + 16);
        int Cb = (int) round((224*Epb) + 128);
        int Cr = (int) round((224*Epr) + 128);

        // My values are centered between +/- 128 and it outputs values in the
        // 0 to 255 range, so we compute and then subtract.

        push(Y-128);
        push(Cb-128);
        push(Cr-128);
    }
}

/**
 * Converts a pixel in YCbCr format to a pixel in RGB format according to Recommendation
 * ITU-R BT.709 for color space transformations. This is the default transformation that should
 * be used for MPEG-2 videos. This transformation is given in Table 6-9 on P.47 of the MPEG-2 13818-2
 * IEEE specification (entry #1). The recommendation specifies the transform from RGB to YCbCR. This
 * function's transformation coefficients were calculated using MATLAB and an inverse matrix transform
 * based on the RGB to YCbCr conversion.
 * @input Three integers in YCbCr color space and order.
 * @output Three integers in RGB color space and order.
 */
int->int filter YCbCrtoRGB {
    // My values are centered between +/- 128, and it expects values in the 
    // 0 to 255 range, so we add first and then compute.
    // Saturation of the output is performed downstream.

    work pop 3 push 3 {

        int Y = 76309 * (pop() + 112);
        int U = pop();
        int V = pop();
        int R = (Y + 117504*V + 32768)>>16;
        int G = (Y - 13954*U - 34903*V + 32768)>>16;
        int B = (Y + 138453*U + 32786)>>16;

        push(R);
        push(G);
        push(B);

    }
}
/*
 * Copyright 2005 by the Massachusetts Institute of Technology.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in
 * advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 */

/**
 * @description
 * This file contains various functions that are used by a variety of
 * other stream components.
 *
 * @author <a href="mailto:madrake@gmail.com">Matthew Drake</a>
 * @file Misc.str
 * @version 1.0
 */

/*
 * Saturates a stream of integers known to lie within some larger
 * range, forcing them to lie within a specified range. Values greater
 * than the maximum are saturated to have the max value, and values
 * less than the minimum are saturated to have the minimum value. If a
 * value lies outside of the great range behavior is undefined.
 *
 * Depending on the size of the range, dispatches to either the
 * general saturation procedure or the array-lookup saturation.
 *
 * @param min The minimum value any integer in the stream is allowed to assume.
 * @param max The maximum value any integer in the stream is allowed to assume.
 * @param worst_input_min The absolute minimum value any input could ever take on.
 * @param worst_input_max The absolute maximum value any input could ever take on.
 * @input A stream of integers.
 * @output A stream of integers lying between min and max, inclusive.
 */
int->int pipeline BestSaturation(int min, int max, int worst_input_min, int worst_input_max) {
    // we know:
    //  - range of <= 521  does better with bounded saturation
    //  - range of >= 1024 does better with plain saturation
    int range = worst_input_max - worst_input_min + 1;
    if (range < 600) {
        add BoundedSaturation(min, max, worst_input_min, worst_input_max);
    } else {
        add Saturation(min, max);
    }
}

/**
 * Saturates a stream of integers, forcing them to lie within a specified range. Values
 * greater than the maximum are saturated to have the max value, and values less than the
 * minimum are saturated to have the minimum value.
 * @param min The minimum value any integer in the stream is allowed to assume.
 * @param max The maximum value any integer in the stream is allowed to assume.
 * @input A stream of integers.
 * @output A stream of integers lying between min and max, inclusive.
 */
int->int filter Saturation(int min, int max) {
    work pop 1 push 1 {
        int val = pop();
        if (val > max) {
            push(max); 
        } else if (val < min) {
            push(min);
        } else {
            push(val);
        }
    }
}

/**
 * Saturates a stream of integers known to lie within some larger range, 
 * forcing them to lie within a specified range. Values
 * greater than the maximum are saturated to have the max value, and values less than 
 * the minimum are saturated to have the minimum value. If a value lies outside
 * of the great range behavior is undefined.
 * @param min The minimum value any integer in the stream is allowed to assume.
 * @param max The maximum value any integer in the stream is allowed to assume.
 * @param worst_input_min The absolute minimum value any input could ever take on.
 * @param worst_input_max The absolute maximum value any input could ever take on.
 * @input A stream of integers.
 * @output A stream of integers lying between min and max, inclusive.
 */
int->int filter BoundedSaturation(int min, int max, int worst_input_min, int worst_input_max) {
    int range;
    int[2*(worst_input_max - worst_input_min + 1)] saturate; // TODO - fix static variables propogating in library
    init {
        range = worst_input_max - worst_input_min + 1; // Should come earlier but range not set correctly
        for (int i = 0; i < range*2; i++) {
            int val = i + worst_input_min;
            if (val < min) {
                saturate[i] = min;
            } else if (val > max) {
                saturate[i] = max;
            } else {
                saturate[i] = val;
            }
        }   
    }
    work pop 1 push 1 {
        push(saturate[pop()-worst_input_min]);
    }
}

/** 
 * Duplicates a sequence of data items a given number of times.
 * @param numitems The number of items in a sequence.
 * @param numtimes The number of times the sequence should be repeated.
 * @input A sequence of numitems values.
 * @output A sequence of numitems values repeated numtimes.
 */
/*
int->int splitjoin Repeat(int numitems, int numtimes) {
  split duplicate;
  for (int i = 0; i < numtimes; i++)
    add Identity<int>;
  join roundrobin(numitems);
}
*/

int->int filter Repeat(int numitems, int numtimes) {

    work pop numitems push numitems * numtimes {
        int[numitems] dataArray;
        for (int i = 0; i < numitems; i++) {
            dataArray[i] = pop();
        }
        for (int j = 0; j < numtimes; j++) {
            for (int i = 0; i < numitems; i++) {
                push(dataArray[i]);
            }
        }
    }
}


/** 
 * Divide every value in the stream by a given number, truncating to the nearest
 * integer.
 * @param div The denominator in the division.
 * @input An integer
 * @output An integer related to the input by output = floor(input / div)
 */
int->int filter DivideBy(int div) {
    work pop 1 push 1 {
        push(pop()/div);
    }
}

/**
 * @internal
 */
int->int filter Add(int num) {
    work pop num push 1 {
        int sum = 0;
        for (int i = 0; i < num; i++)
            sum += pop();
        push(sum);
    }
}
/*
 * Copyright 2005 by the Massachusetts Institute of Technology.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in
 * advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 */

/**
 * @description
 * This file contains functions that allow one to read and write binary files
 * within StreamIt without the presence of a FileReader<bit> built-in stream.
 * Instead, a FileReader/Writer<int> can be used, immediately followed by the 
 * appropriate conversion. 
 *
 * @author <a href="mailto:madrake@gmail.com">Matthew Drake</a>
 * @file BinaryFile.str.pre
 * @version 1.0
 */

/**
 * Converts a sequence of integers read from a file with FileReader<int> into a bit stream
 * matching the underlying bit representation of the original file. It does this by 
 * reordering the bits back into their original order.
 * @input An integer read from a file.
 * @output 32 bits representing the original bit data that the integer was generated from.
 */
int->bit filter IntStream2BitStream() {
  work pop 1 push 32 {
    int some_int = pop();
    int b0 = ((some_int >> 24) & 0x000000FF);
    int b1 = (some_int & 0x00FF0000) >> 8;
    int b2 = (some_int & 0x0000FF00) << 8;
    int b3 = (some_int & 0x000000FF) << 24;
    some_int = (b0 | b1 | b2 | b3);
    {
      int pushs_int = some_int << (32-32);
      for (int pushs_i = 0; pushs_i < 32; pushs_i++) {
        if (pushs_int >= 0) {
          push(0);
        } else {
          push(1);
        }
        pushs_int <<= 1;
      }
    }
  }
}

/** 
 * Converts a bit stream into a sequence of integers suitable for writing to a file with a 
 * FileWriter<int>. The integers written by the FileWriter will create a file matching the
 * underlying representation of the bit stream. Note that if less than full 32 bits is 
 * sent to this filter it won't generate output, so components which generate bit streams
 * for use by this filter must be careful to generate output in multiples of 32 bits, or be
 * aware of the truncation that will happen.
 * @input 32 bits representing bit data to be stored in a file.
 * @output An integer suitable for file writing equivalent to the original 32 bits.
 */
bit->int filter BitStream2IntStream() {
  work pop 32 push 1 {
    int some_int;
    some_int = 0;
    for (int pops_i = 0; pops_i < (32-1); pops_i++) {
      some_int += pop();
      some_int <<= 1;
    }
    some_int += pop();
    int b0 = ((some_int >> 24) & 0x000000FF);
    int b1 = (some_int & 0x00FF0000) >> 8;
    int b2 = (some_int & 0x0000FF00) << 8;
    int b3 = (some_int & 0x000000FF) << 24;
    some_int = (b0 | b1 | b2 | b3);
    push(some_int);
  }
}

int->int filter IntStreamReorder() {
    work pop 1 push 1 {
        int some_int = pop();
        int b0 = ((some_int >> 24) & 0x000000FF);
        int b1 = (some_int & 0x00FF0000) >> 8;
        int b2 = (some_int & 0x0000FF00) << 8;
        int b3 = (some_int & 0x000000FF) << 24;
        some_int = (b0 | b1 | b2 | b3);
        push(some_int);
    }
}

/*
 * Copyright 2005 by the Massachusetts Institute of Technology.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in
 * advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 */

/**
 * @description
 * This file contains functions that implement Discrete Cosine Transforms and
 * their inverses.  When reference is made to the IEEE DCT specification, it
 * is refering to the IEEE DCT specification used by both MPEG and JPEG.
 * A definition of what makes an 8x8 DCT conform to the IEEE specification, as well
 * as a pseudocode implementation, can be found in Appendix A of the MPEG-2 specification
 * (ISO/IEC 13818-2) on P. 125. 
 *
 * @author <a href="mailto:madrake@gmail.com">Matthew Drake</a>
 * @author <a href="mailto:rodric@gmail.com">Rodric Rabbah</a>
 * @file DCT.str
 * @version 1.0
 */

/**
 * Transforms an 8x8 signal from the frequency domain to the signal domain
 * using an inverse Discrete Cosine Transform in accordance with
 * the IEEE specification for a 2-dimensional 8x8 iDCT.
 * @input 64 values representing an 8x8 array of values in the 
 *        frequency domain, ordered
 *        by row and then column. Vertical frequency increases 
 *        along each row and horizontal frequency along each column.
 * @output 64 values representing an 8x8 array of values in the
 *        signal domain, ordered by row and then column.
 * @param mode indicates algorithm to use;
 *        mode == 0: reference, coarse implementation
 *        mode == 1: reference, fine (parallel) implementation
 *        mode == 2: fast, coarse implementation
 *        mode == 3: fast, fine (parallel) implementation
 */
int->int pipeline iDCT8x8_ieee(int mode) {
    // modes:
    // 0: reference, coarse
    // 1: reference, fine (parallel)
    // 2: fast, coarse
    // 3: fast, fine (parallel)
    if (mode == 0)
        add iDCT_2D_reference_coarse(8);
    else if (mode == 1)
        add iDCT_2D_reference_fine(8);
    else if (mode == 2)
        add iDCT8x8_2D_fast_coarse();
    else
        add iDCT8x8_2D_fast_fine();
}

/**
 * Transforms an 8x8 signal from the signal domain to the frequency domain
 * using a Discrete Cosine Transform in accordance with the IEEE
 * specification for a 2-dimensional 8x8 DCT.
 * @input 64 values representing an 8x8 array of values in the signal
 *        domain, ordered by row and then column.
 * @output 64 values representing an 8x8 array of values in the 
 *         frequency domain, ordered by row and then column. Vertical frequency
 *         increases along each row and horizontal frequency along each column.
 * @param mode indicates algorithm to use;
 *        mode == 0: reference, coarse implementation,
 *        mode == 1: reference, fine (parallel) implementation
 */
int->int pipeline DCT8x8_ieee(int mode) {
    // modes:
    // 0: reference, coarse
    // 1: reference, fine (parallel)
    if (mode == 0)
        add DCT_2D_reference_coarse(8);
    else
        add DCT_2D_reference_fine(8);
}

/**
 * Transforms a 2D signal from the frequency domain to the signal domain
 * using an inverse Discrete Cosine Transform.
 * @param size The number of elements in each dimension of the signal.
 * @input size x size values, representing an array of values in the frequency 
 *        domain, ordered by row and then column. Vertical frequency increases
 *        along each row and horizontal frequency along each column.
 * @output size x size values representing an array of values in the signal
 *         domain, ordered by row and then column.
 */
int->int pipeline iDCT_2D_reference_fine(int size) {
    add int->float filter {
        work pop 1 push 1 {
            push((float) pop());
        }
    }
    add iDCT_1D_Y_reference_fine(size);
    add iDCT_1D_X_reference_fine(size);
}

/**
 * Transforms a 2D signal from the frequency domain to the signal domain
 * using a FAST inverse Discrete Cosine Transform.
 * @input size x size values, representing an array of values in the frequency 
 *        domain, ordered by row and then column. Vertical frequency increases
 *        along each row and horizontal frequency along each column.
 * @output size x size values representing an array of values in the signal
 *         domain, ordered by row and then column.
 */
int->int pipeline iDCT8x8_2D_fast_coarse() {
    add iDCT8x8_1D_row_fast(); 
    add iDCT8x8_1D_col_fast();
}

/**
 * Transforms a 2D signal from the frequency domain to the signal domain
 * using a FAST inverse Discrete Cosine Transform.
 * @input size x size values, representing an array of values in the frequency 
 *        domain, ordered by row and then column. Vertical frequency increases
 *        along each row and horizontal frequency along each column.
 * @output size x size values representing an array of values in the signal
 *         domain, ordered by row and then column.
 */
int->int pipeline iDCT8x8_2D_fast_fine() {
    add iDCT8x8_1D_X_fast_fine(); 
    add iDCT8x8_1D_Y_fast_fine();
}

/**
 * Transforms a 2D signal from the signal domain to the frequency domain
 * using a Discrete Cosine Transform. 
 * @param size The number of elements in each dimension of the signal. 
 * @input size x size values, representing an array of values in the signal
 *        domain, ordered by row and then column.
 * @output size x size values representing an array of values in the 
 *         frequency domain, ordered by row and then column. Vertical frequency
 *         increases along each row and horizontal frequency along each column.
 */
int->int pipeline DCT_2D_reference_fine(int size) {
    add int->float filter {
        work pop 1 push 1 {
            int v = pop();
            push((float) v);
        }
    }
    add DCT_1D_X_reference_fine(size);
    add DCT_1D_Y_reference_fine(size);
    add float->int filter {
        work pop 1 push 1 {
            float v =  floor(pop() + 0.5);
            push((int) v);
        }
    }
}

/**
 * @internal
 */
float->int splitjoin iDCT_1D_X_reference_fine(int size) {
    split roundrobin(size);
    for (int i = 0; i < size; i++) {
	add pipeline 
	    {
		add iDCT_1D_reference_fine(size); 
		add float->int filter {
		    work pop 1 push 1 {
			push((int) floor(pop() + 0.5));
		    }
		}
	    }
    }
    join roundrobin(size);
}

/**
 * @internal
 */
float->float splitjoin iDCT_1D_Y_reference_fine(int size) {
    split roundrobin(1);
    for (int i = 0; i < size; i++) {
        add iDCT_1D_reference_fine(size); 
    }
    join roundrobin(1);
}

/**
 * @internal
 */
int->int splitjoin iDCT8x8_1D_X_fast_fine() {
    split roundrobin(8);
    for (int i = 0; i < 8; i++) {
        add iDCT8x8_1D_row_fast(); 
    }
    join roundrobin(8);
}

/**
 * @internal
 */
int->int splitjoin iDCT8x8_1D_Y_fast_fine() {
    split roundrobin(1);
    for (int i = 0; i < 8; i++) {
        add iDCT8x8_1D_col_fast_fine(); 
    }
    join roundrobin(1);
}

/**
 * @internal
 */
float->float splitjoin DCT_1D_X_reference_fine(int size) {
    split roundrobin(size);
    for (int i = 0; i < size; i++) {
        add DCT_1D_reference_fine(size);
    }
    join roundrobin(size);
}

/**
 * @internal
 */
float->float splitjoin DCT_1D_Y_reference_fine(int size) {
    split roundrobin(1);
    for (int i = 0; i < size; i++) {
        add DCT_1D_reference_fine(size);
    }
    join roundrobin(1);
}

/**
 * @internal
 * Based on the implementation given in the C MPEG-2 reference implementation
 */
int->int filter iDCT_2D_reference_coarse(int size) {
    float[size][size] coeff;
    
    init {
        for (int freq = 0; freq < size; freq++) {
            float scale = (freq == 0) ? sqrt(0.125) : 0.5;
            for (int time = 0; time < size; time++)
                coeff[freq][time] = scale * cos((pi/(float)size) * freq * (time + 0.5));
        }
    }
    
    work pop size*size push size*size {
        float[size][size] block_x;
        int i, j, k;

        for (i = 0; i < size; i++)
            for (j = 0; j < size; j++) {
                block_x[i][j] = 0;
                for (k = 0; k < size; k++) {
                    block_x[i][j] += coeff[k][j] * peek(size*i + k /* that is buffer[i][k] */);
                }
            }

        for (i = 0; i < size; i++) {
            for (j = 0; j < size; j++) {
                float block_y = 0.0;
                for (k = 0; k < size; k++) {
                    block_y += coeff[k][i] * block_x[k][j];
                }
                block_y = floor(block_y + 0.5);
                push((int) block_y);
            }
        }

        for (i = 0; i < size*size; i++) pop();
    }
}

/**
 * Transforms a 2D signal from the signal domain to the frequency domain
 * using a Discrete Cosine Transform. 
 * @param size The number of elements in each dimension of the signal. 
 * @input size values, representing an array of values in the signal
 *        domain, ordered by row and then column.
 * @output size values representing an array of values in the 
 *         frequency domain, ordered by row and then column. Vertical frequency
 *         increases along each row and horizontal frequency along each column.
 */
int->int filter DCT_2D_reference_coarse(int size) {
    float[size][size] coeff;
    
    init {
        for (int i = 0; i < size; i++) {
            float s = (i == 0) ? sqrt(0.125) : 0.5;
            for (int j = 0; j < size; j++)
                coeff[i][j] = s * cos((pi / size) * i * (j + 0.5));
        }
    }

    work pop size*size push size*size {
        float[size][size] block_x;
        int i, j, k;


        for (i = 0; i < size; i++)
            for (j = 0; j < size; j++) {
                block_x[i][j] = 0.0;
                for (k = 0; k < size; k++) {
                    block_x[i][j] += coeff[j][k] * peek(size*i + k);
                }
            }

        for (i = 0; i < size; i++) {
            for (j = 0; j < size; j++) {
                float block_y = 0.0;
                for (k = 0; k < size; k++) {
                    block_y += coeff[i][k] * block_x[k][j];
                }
                block_y = floor(block_y + 0.5);
                push((int) block_y);
            }
        }

        for (i = 0; i < size*size; i++) pop();
    }
}

/**
 * Transforms a 1D signal from the frequency domain to the signal domain
 * using an inverse Discrete Cosine Transform.
 * @param size The number of elements in each dimension of the signal.
 * @input size values, representing an array of values in the frequency 
 *        domain, ordered by row and then column. Vertical frequency increases
 *        along each row and horizontal frequency along each column.
 * @output size values representing an array of values in the signal
 *         domain, ordered by row and then column.
 */
float->float filter iDCT_1D_reference_fine(int size) {
    float[size][size] coeff;
    
    init {
        for (int x = 0; x < size; x++) {
            for (int u = 0; u < size; u++) {
                float Cu = 1;
                if (u == 0) Cu = 1/sqrt(2);
                coeff[x][u] = 0.5 * Cu * cos(u * pi * (2.0 * x+1) / (2.0 * size));
            }
        }
    }

    work pop size push size {
        for (int x = 0; x < size; x++) {
            float tempsum = 0;
            for (int u = 0; u < size; u++) {
                tempsum += coeff[x][u] * peek(u);
            }
            push(tempsum);
        }
    }
}

/**
 * Transforms a 1D horizontal signal from the frequency domain to the signal
 * domain using a FAST inverse Discrete Cosine Transform.
 * @input size values, representing an array of values in the frequency 
 *        domain, ordered by row and then column. Vertical frequency increases
 *        along each row and horizontal frequency along each column.
 * @output size values representing an array of values in the signal
 *         domain, ordered by row and then column.
 */
int->int filter iDCT8x8_1D_row_fast() {
    int size = 8;

    int W1 = 2841; /* 2048*sqrt(2)*cos(1*pi/16) */
    int W2 = 2676; /* 2048*sqrt(2)*cos(2*pi/16) */
    int W3 = 2408; /* 2048*sqrt(2)*cos(3*pi/16) */
    int W5 = 1609; /* 2048*sqrt(2)*cos(5*pi/16) */
    int W6 = 1108; /* 2048*sqrt(2)*cos(6*pi/16) */
    int W7 = 565;  /* 2048*sqrt(2)*cos(7*pi/16) */
    
    work pop size push size {
        int x0 = peek(0);
        int x1 = peek(4) << 11;
        int x2 = peek(6);
        int x3 = peek(2);
        int x4 = peek(1);
        int x5 = peek(7);
        int x6 = peek(5);
        int x7 = peek(3);
        int x8;

        /* shortcut */
        if ((x1 == 0) && (x2 == 0) && (x3 == 0) && 
            (x4 == 0) && (x5 == 0) && (x6 == 0) && (x7 == 0)) {
            x0 = x0 << 3;
            for (int i = 0; i < size; i++) {
                push(x0);
            }
        }
        else {
            /* for proper rounding in the fourth stage */
            x0 = (x0 << 11) + 128; 

            /* first stage */
            x8 = W7 * (x4 + x5);
            x4 = x8 + (W1 - W7) * x4;
            x5 = x8 - (W1 + W7) * x5;
            x8 = W3 * (x6 + x7);
            x6 = x8 - (W3 - W5) * x6;
            x7 = x8 - (W3 + W5) * x7;

            /* second stage */
            x8 = x0 + x1;
            x0 = x0 - x1;
            x1 = W6 * (x3 + x2);
            x2 = x1 - (W2 + W6) * x2;
            x3 = x1 + (W2 - W6) * x3;
            x1 = x4 + x6;
            x4 = x4 - x6;
            x6 = x5 + x7;
            x5 = x5 - x7;

            /* third stage */
            x7 = x8 + x3;
            x8 = x8 - x3;
            x3 = x0 + x2;
            x0 = x0 - x2;
            x2 = (181 * (x4 + x5) + 128) >> 8;
            x4 = (181 * (x4 - x5) + 128) >> 8;

            /* fourth stage */
            push((x7 + x1) >> 8);
            push((x3 + x2) >> 8);
            push((x0 + x4) >> 8);
            push((x8 + x6) >> 8);
            push((x8 - x6) >> 8);
            push((x0 - x4) >> 8);
            push((x3 - x2) >> 8);
            push((x7 - x1) >> 8);
        }
        for (int i = 0; i < size; i++) pop();
    }
}


/**
 * Transforms a 1D vertical signal from the frequency domain to the signal
 * domain using a FAST inverse Discrete Cosine Transform.
 * @input size*size values, representing an array of values in the frequency 
 *        domain, ordered by row and then column. Vertical frequency increases
 *        along each row and horizontal frequency along each column.
 * @output size values representing an array of values in the signal
 *         domain, ordered by row and then column.
 */
int->int filter iDCT8x8_1D_col_fast() {
    int size = 8;
    int[8*8] buffer;

    int W1 = 2841; /* 2048*sqrt(2)*cos(1*pi/16) */
    int W2 = 2676; /* 2048*sqrt(2)*cos(2*pi/16) */
    int W3 = 2408; /* 2048*sqrt(2)*cos(3*pi/16) */
    int W5 = 1609; /* 2048*sqrt(2)*cos(5*pi/16) */
    int W6 = 1108; /* 2048*sqrt(2)*cos(6*pi/16) */
    int W7 = 565;  /* 2048*sqrt(2)*cos(7*pi/16) */
    
    work pop size*size push size*size {
        for (int c = 0; c < size; c++) {
            int x0 = peek(c + size * 0);
            int x1 = peek(c + size * 4) << 8;
            int x2 = peek(c + size * 6);
            int x3 = peek(c + size * 2);
            int x4 = peek(c + size * 1);
            int x5 = peek(c + size * 7);
            int x6 = peek(c + size * 5);
            int x7 = peek(c + size * 3);
            int x8;

            /* shortcut */
            if ((x1 == 0) && (x2 == 0) && (x3 == 0) && 
                (x4 == 0) && (x5 == 0) && (x6 == 0) && (x7 == 0)) {
                x0 = (x0 + 32) >> 6;
                for (int i = 0; i < size; i++) {
                    buffer[c + size * i] = x0;
                }
            }
            else {
                /* for proper rounding in the fourth stage */
                x0 = (x0 << 8) + 8192; 
                
                /* first stage */
                x8 = W7 * (x4 + x5) + 4;
                x4 = (x8 + (W1 - W7) * x4) >> 3;
                x5 = (x8 - (W1 + W7) * x5) >> 3;
                x8 = W3 * (x6 + x7) + 4;
                x6 = (x8 - (W3 - W5) * x6) >> 3;
                x7 = (x8 - (W3 + W5) * x7) >> 3;
                
                /* second stage */
                x8 = x0 + x1;
                x0 = x0 - x1;
                x1 = W6 * (x3 + x2) + 4;
                x2 = (x1 - (W2 + W6) * x2) >> 3;
                x3 = (x1 + (W2 - W6) * x3) >> 3;
                x1 = x4 + x6;
                x4 = x4 - x6;
                x6 = x5 + x7;
                x5 = x5 - x7;
                
                /* third stage */
                x7 = x8 + x3;
                x8 = x8 - x3;
                x3 = x0 + x2;
                x0 = x0 - x2;
                x2 = (181 * (x4 + x5) + 128) >> 8;
                x4 = (181 * (x4 - x5) + 128) >> 8;
                
                /* fourth stage */
                buffer[c + size * 0] = ((x7 + x1) >> 14);
                buffer[c + size * 1] = ((x3 + x2) >> 14);
                buffer[c + size * 2] = ((x0 + x4) >> 14);
                buffer[c + size * 3] = ((x8 + x6) >> 14);
                buffer[c + size * 4] = ((x8 - x6) >> 14);
                buffer[c + size * 5] = ((x0 - x4) >> 14);
                buffer[c + size * 6] = ((x3 - x2) >> 14);
                buffer[c + size * 7] = ((x7 - x1) >> 14);
            }
        }
        for (int i = 0; i < size*size; i++) {
            pop();
            push(buffer[i]);
        }
    }
}

/**
 * Transforms a 1D vertical signal from the frequency domain to the signal
 * domain using a FAST inverse Discrete Cosine Transform.
 * @param size The number of elements in each dimension of the signal.
 * @input size values, representing an array of values in the frequency 
 *        domain, ordered by row and then column. Vertical frequency increases
 *        along each row and horizontal frequency along each column.
 * @output size values representing an array of values in the signal
 *         domain, ordered by row and then column.
 */
int->int filter iDCT8x8_1D_col_fast_fine() {
    int size = 8;

    int W1 = 2841; /* 2048*sqrt(2)*cos(1*pi/16) */
    int W2 = 2676; /* 2048*sqrt(2)*cos(2*pi/16) */
    int W3 = 2408; /* 2048*sqrt(2)*cos(3*pi/16) */
    int W5 = 1609; /* 2048*sqrt(2)*cos(5*pi/16) */
    int W6 = 1108; /* 2048*sqrt(2)*cos(6*pi/16) */
    int W7 = 565;  /* 2048*sqrt(2)*cos(7*pi/16) */
    
    work pop size push size {
        int x0 = peek(0);
        int x1 = peek(4) << 8;
        int x2 = peek(6);
        int x3 = peek(2);
        int x4 = peek(1);
        int x5 = peek(7);
        int x6 = peek(5);
        int x7 = peek(3);
        int x8;

        /* shortcut */
        if ((x1 == 0) && (x2 == 0) && (x3 == 0) && 
            (x4 == 0) && (x5 == 0) && (x6 == 0) && (x7 == 0)) {
            x0 = (x0 + 32) >> 6;
            for (int i = 0; i < size; i++) {
                push(x0);
            }
        }
        else {
            /* for proper rounding in the fourth stage */
            x0 = (x0 << 8) + 8192; 

            /* first stage */
            x8 = W7 * (x4 + x5) + 4;
            x4 = (x8 + (W1 - W7) * x4) >> 3;
            x5 = (x8 - (W1 + W7) * x5) >> 3;
            x8 = W3 * (x6 + x7) + 4;
            x6 = (x8 - (W3 - W5) * x6) >> 3;
            x7 = (x8 - (W3 + W5) * x7) >> 3;

            /* second stage */
            x8 = x0 + x1;
            x0 = x0 - x1;
            x1 = W6 * (x3 + x2) + 4;
            x2 = (x1 - (W2 + W6) * x2) >> 3;
            x3 = (x1 + (W2 - W6) * x3) >> 3;
            x1 = x4 + x6;
            x4 = x4 - x6;
            x6 = x5 + x7;
            x5 = x5 - x7;

            /* third stage */
            x7 = x8 + x3;
            x8 = x8 - x3;
            x3 = x0 + x2;
            x0 = x0 - x2;
            x2 = (181 * (x4 + x5) + 128) >> 8;
            x4 = (181 * (x4 - x5) + 128) >> 8;

            /* fourth stage */
            push((x7 + x1) >> 14);
            push((x3 + x2) >> 14);
            push((x0 + x4) >> 14);
            push((x8 + x6) >> 14);
            push((x8 - x6) >> 14);
            push((x0 - x4) >> 14);
            push((x3 - x2) >> 14);
            push((x7 - x1) >> 14);
        }
        for (int i = 0; i < size; i++) pop();
    }
}


/**
 * Transforms a 1D signal from the signal domain to the frequency domain
 * using a Discrete Cosine Transform. 
 * @param size The number of elements in each dimension of the signal. 
 * @input size values, representing an array of values in the signal
 *        domain, ordered by row and then column.
 * @output size values representing an array of values in the 
 *         frequency domain, ordered by row and then column. Vertical frequency
 *         increases along each row and horizontal frequency along each column.
 */
float->float filter DCT_1D_reference_fine(int size) {
    float[size][size] coeff;

    init {
        for (int u = 0; u < size; u++) {
            float Cu = 1;
            if (u == 0) Cu = 1/sqrt(2);

            for (int x = 0; x < size; x++) {
                coeff[u][x] = 0.5 * Cu * cos(u * pi * (2.0 * x+1) / (2.0 * size));
            }
        }
    }
    
    work pop size push size {
        for (int u = 0; u < size; u++) {
            float tempsum = 0;
            for (int x = 0; x < size; x++) {
                tempsum += peek(x) * coeff[u][x];
            }
            push(tempsum);
        }
    }
}
