/*
 * [Shirley]
 * This file contains the various functions for generating the 4
 * prediction modes for a 16x16 intra prediction block. 
 *
 * This is new to MPEG-2
 *  
 * Note that all prediction modes can be calculated independently
 * of each other and therefore can be parallelized.
 * 
 * Reference: http://www.rgu.ac.uk/files/h264_intrapred.pdf
 */

/**
 * @description
 * This file contains various functions that takes in a total of 
 * 32 pixels, 16 'H'orizontal and 16 'V'ertical pixels on the top
 * and left side of the prediction block. 
 * 
 * Various functions calculate all 4 prediction modes such that the 
 * best one can be used for a luminance block. Not all modes will 
 * require all 32 pixels. These filters will assume the input will give 
 * luminance values 'H' and 'V', giving an output that is
 * denoted by numbers, in the order below (not in zig-zag).
 * 
 * The series of luminance values for 'H' is an array of length 16,
 * representing the values from left to right. Indexed from 0 - 15.
 * The series of luminance values for 'V' is an array of length 16,
 * representing the values from top to bottom. Indexed from 0 - 15.
 * 
 * X H H H H H H H H H H H H H H H H 
 * V 0 1 2 3 4 5 6 7 8 9 .......
 * V
 * V
 * V
 * V
 * V
 * V
 * V
 * V
 * V
 * V
 * V
 * V
 * V
 * V
 * V ............................. 256
 * 
 * 
 * The number represents the order of output for the prediction block.
 * 
 * The cost function is the residual between the original block
 * and the predicted block. The encoder will choose the prediction
 * mode that minimizes the residual.
 * 
 * Be aware that the more complex prediction algorithms requires
 * the use of a matrix to store all calcuated values, then the
 * matrix is spit out at each row, from left to right, going downwards
 * at each row.
 *
 * @author <a href="mailto:shirley.mit07@gmail.com">Shirley Fung</a>
 * @file PredictionModes16x16Luma.str
 * @version 1.0
 */

/**
 * This constructs the pipeline for all the four 16x16 prediction
 * modes, find the mininum SAE and output the corresponding predidtion
 * mode.
 * 
 * Note that the children of this splitjoin are pipelines that would
 * prepare the 'H' + 'V' + 256 pixels for the prediction mode filters.
 *
 * @input 'H' + 'V' + 256 pixels from the original block (total: 29 pixels)
 * @output recommended 4x4 luma prediction mode (possible: 0 to 8)
 */
int-int pipeline BestPredictionMode4x4 {
	add CalculatePredictionModes4x4;
	add FindBestPredictionMode();
}

/**
 * This constructs the splitjoin for all the different prediction
 * modes, and gather them up so that the SAE can be compared.
 * 
 * Note that the children of this splitjoin are pipelines that would
 * prepare the A-M + 16 pixels for the prediction mode filters.
 *
 * @input A-M + 16 pixels from the original block (total: 29 pixels)
 * @output stream of all "sum of absolute errors" (9 values)
 */
int->int splitjoin CalculatePredictionModes4x4 {
	split duplicate;
	add PredictionMode0Pipeline;
	add PredictionMode1Pipeline;
	add PredictionMode2Pipeline;
	add PredictionMode3Pipeline;
	add PredictionMode4Pipeline;
	add PredictionMode5Pipeline;
	add PredictionMode6Pipeline;
	add PredictionMode7Pipeline;
	add PredictionMode8Pipeline;
	join roundrobin;
}


/**
 * This filter gathers all the sum of absolute errors from 
 * all the prediction modes, and find the mininum - then output
 * the prediction mode. 
 * 
 * @input stream of all "sum of absolute errors" (mode0 to mode8 in order)
 * @output recommended 4x4 luma prediction mode (possible: 0 to 8)
 */
int->int splitjoin FindBestPredictionMode() {
	work pop 9 push 1 {
		int currentMinSAE = peek(0);
		int minPredictionMode = 0;
		for (int i=1; i<=8; i++) {
			if (peek(i) < peek(0)) {
				minPredictionMode = i;
			}
		}
		push minPredictionMode;
	}
}

/**
 * This function calculates prediction mode 0 for a 16x16 luminance
 * block. Note that only the 'H'orizontal pixels is required.
 * 
 * @input A stream of 32 pixels 'H' and 'V' + 256 original pixels
 * @output sum of absolute errors for mode 0
 */
int->int filter PredictionMode0() {

	work pop 32 peek 32 push 256 {
	  

}

