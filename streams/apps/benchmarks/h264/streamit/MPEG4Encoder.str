/**
 * @description
 * This is the main file that contains all the filters required to encode
 * MPEG-4 compliant video. The specification for MPEG-4 (Part 10) used is 
 * the ITU-T H-Series Recommendation for H.264.
 * 
 * @author <a href="mailto:shirleyf@gmail.com">Shirley Fung</a>
 * @file MPEG4Encoder.str
 * @version 1.0
 */

/** 
 * List of TODOs
 * -remove any parameterizable structs
 * -decide on a fix resolution that the encoder will work for, FIX ARRAY SIZES!
 */

/**
 * Interprets an input stream of raw video and encodes a compressed MPEG-4 
 * compliant bit stream, in accordance with the ITU-T specification.
 * 
 * The encoder is limited to work only with CIF videos in YCrCb 4:2:0 format,
 * with resolution of 288w x 352h. However, with small changes in the code, it
 * can work with QCIF files as well. It is important that the width and height
 * dimensions must be in multiples of 16 for macroblock division to work. The
 * reason why the input video resolution is fixed due to the fact that there
 * is no parameterizable structs, arrays of macroblocks must be of a fixed size.
 * 
 * @input VOID
 * @output An MPEG-4 compliant bit stream of variable length.
 */ 
void->bit pipeline rawImageStream_to_MPEGStream() {
	
	// video parameters
	int width = 352;
	int height = 288;
	int numPictures = 300; 
	
	// useful variables
	// int numOfMacroblocks = (width/16)*(height/16); // number of macroblocks in a frame
	
	//portal<SendBackReconstructedFrame> portal_intraReconstructedFrame;
	portal<SendBackReconstructedFrame> portal_referenceFrame;
	//deprecated for now
	//portal<SendBackReconstructedFrame> portal_backwardReferenceFrame;
	
	
	add VideoProcessor(width, height, numPictures); // similar to mpeg2
	// see VideoProcessor.str, for testing purposes, it currently does not
	// take the W,H,numPictures as parameters
		
	add Prediction(portal_forwardReferenceFrame);
				   //portal_backwardReferenceFrame); // deprecated
	// may have to modify parameters, and portals
	// numOfMacroblocks? width? height? 
	/* Prediction:
	 * Prediction block here should have at least the following portals.
	 * portal_forwardReferenceFrame
	 * portal_backwardReferenceFrame
	 */ 
	add TransformAndQuantization; // add parameters
	add splitjoin {
		duplicate;
		add Identity<CodedFrame>;
		add pipeline {
			add InverseTransformAndQuantization; // add parameters
			add SendBackReconstructedFrame to portal_referenceFrame;
										 	  //portal_backwardReferenceFrame;  deprecated for now
											  // portals to send appropriate frames
		}
			
		join roundrobin(1);
	}
									 	 
	/* Note:
	 * These frames are sent back to the Prediction filter because the 
	 * transform and quantization stages produce a distorted frame 
	 * (process is lossy)
	 */
	 
	add ReorderFrames; 
	add EntropyEncoding;
	// write to file!
}




/**
 * Interprets an input stream of successive frames (in macroblock form), and produces a 
 * stream of predicted frames (P slices).
 * @param parameters has not been set in stone yet...
 * @input A series of frames in macroblock order
 * @output A stream of predicted frames (defined new struct: PredictedFrame).
 */
Frame->PredictedFrame pipeline Prediction(
								 //portal<SendBackReconstructedFrame> 
								 //	portal_intraReconstructedFrame,
								 portal<SendBackReconstructedFrame> 
								 	portal_referenceFrame {
								 //portal<SendBackReconstructedFrame> 
								 //	portal_backwardReferenceFrame) {
	
}

/**
 * Interprets an input stream of predicted frames, and produces a 
 * stream of coded frames.
 * @param parameters has not been set in stone yet...
 * @input A stream of predicted frames 
 * @output A stream of coded frames (defined new struct: PredictedFrame).
 */
PredictedFrame->CodedFrame pipeline TransformAndQuantization() {
	
}

/**
 * Interprets an input stream of coded frames, and produces a 
 * stream of reconstructed frames.
 * @param parameters has not been set in stone yet...
 * @input A stream of coded frames 
 * @output A stream of coded frames.
 */
CodedFrame->CodedFrame pipeline InverseTransformAndQuantization() {
	
}

/**
 * Interprets an input stream of coded frames, and produces a 
 * stream of coded frames. Note that this handles sending back 
 * reconstructed frames for intra and inter prediction. The stream
 * of coded frames will be OUT OF ORDER for final entropy encoding.
 * 
 * Note that inter prediction will require filtered blocks.
 * 
 * @param parameters has not been set in stone yet...
 * @input A stream of coded frames 
 * @output A stream of coded frames
 */
CodedFrame->CodedFrame filter SendBackReconstructedFrame() {
	
}

// ReorderFrames && EntropyEncoding needed here


/* ********************************************************
 * STRUCTS FOR VARIOUS DATA TYPES
 * Note: more structs will be needed for intra/inter 
 * prediction to tag the necessary labels for block sizes
 * *********************************************************/


/**
 * This is the container for a frame, using 4:2:0 sampling scheme.
 * It may be modified easily for a different sampling scheme.
 * 
 * Note that in the StreamIt Language Specification 2.1, user initiated 
 * parameterized types is listed as a future extension.
 * 
 * @param numOfMacroblocks number of macroblocks in a frame is needed 
 * 						   to size the array for the frame
 * 						   DEPRECATED, NO PARAMETERIZABLE STRUCTS
 * 
 * @frameNumber used for temporal reference
 * @sliceType labeling of I, P,or B slice types
 * @macroblock samples coded using 4:2:0 scheme
 */
struct Frame {
	int frameNumber;
	int sliceType;
	// QCIF 22w x 16h blocks
	// For clarification, first number will index the row
	// and second number will index the column
	Macroblock[16][22] macroblocks;
}


/**
 * This is the container for a predicted frame, using 4:2:0 sampling scheme.
 * It may be modified easily for a different sampling scheme.
 * 
 * Note that in the StreamIt Language Specification 2.1, user initiated 
 * parameterized types is listed as a future extension.
 * 
 * @param numOfMacroblocks number of macroblocks in a frame is needed 
 * 						   to size the array for the frame
 * 						   DEPRECATED, NO PARAMETERIZABLE STRUCTS
 * @??? motion vectors
 * @??? residuals
 * @??? intraprediction modes
 * @??? block size, and others?
 * @frameNumber used for temporal reference
 * @sliceType labeling of I, P,or B slice types
 * @predictedBlocks samples coded using 4:2:0 scheme
 */
struct PredictedFrame {
	// need more here...
	int frameNumber;
	int sliceType;
	// For clarification, first number will index the row
	// and second number will index the column
	Macroblock[16][22] predictedBlocks;
}

/**
 * This is the container for a coded frame. It contains information such as:
 * entropy-encoded coefficients, macroblock prediction modes, quanitzer step size,
 * motion vectors, etc.
 * 
 * Note that in the StreamIt Language Specification 2.1, user initiated 
 * parameterized types is listed as a future extension.
 * 
 * @param numOfMacroblocks number of macroblocks in a frame is needed 
 * 						   to size the array for the frame
 * 						   DEPRECATED, NO PARAMETERIZABLE STRUCTS
 * 
 * @??? motion vectors
 * @??? residuals
 * @??? intraprediction modes
 * @??? block size and others?
 * @frameNumber used for temporal reference
 * @sliceType labeling of I, P,or B slice types
 * @encodedBlocks samples coded using 4:2:0 scheme
 */
struct CodedFrame {
	// need more here...
	int frameNumber;
	int sliceType;
	// For clarification, first number will index the row
	// and second number will index the column
	Macroblock[16][22] encodedBlocks;
}

/**
 * This is the container for a reconstructed frame. 
 * It can be filtered or unfiltered.
 * It is a distorted version of the original frame
 * 
 * Note that in the StreamIt Language Specification 2.1, user initiated 
 * parameterized types is listed as a future extension.
 * 
 * @param numOfMacroblocks number of macroblocks in a frame is needed 
 * 						   to size the array for the frame
 * 						   DEPRECATED, NO PARAMETERIZABLE STRUCTS
 * @reconstructedBlocks samples coded using 4:2:0 scheme
 */
struct DistortedFrame {
	int frameNumber;
	int sliceType;
	// For clarification, first number will index the row
	// and second number will index the column
	Macroblock[16][22] reconstructedBlocks;
}

/* ********************************************************
 * STRUCTS FOR VARIOUS DATA TYPES
 * Note: more structs will be needed for intra/inter 
 * prediction to tag the necessary labels for block sizes
 * *********************************************************/



/**
 * This is the container for a macroblock, used for 4:2:0 sampling scheme.
 * It may be modified easily for a different sampling scheme.
 *
 * @YSamples 16x16 luma samples block
 * @CbSamples 8x8 blue chroma samples block
 * @CrSamples 8x8 red chroma samples block
 */
struct Macroblock {
	Block16x16 YSamples;
	Block8x8 CbSamples;
	Block8x8 CrSamples;
}

