/*
 * [Shirley]
 * This file contains the various functions for generating the 9
 * prediction modes for a 4x4 intra prediction block. 
 *
 * This is new to MPEG-2
 *  
 * Note that all prediction modes can be calculated independently
 * of each other and therefore can be parallelized.
 * 
 * Reference: http://www.rgu.ac.uk/files/h264_intrapred.pdf
 */

/**
 * @description
 * This file contains various functions that takes in 13 pixels
 * and calculate all 9 prediction modes such that the best one 
 * can be used for a luminance block. Not all modes will require
 * all 13 pixels. These filters will assume the input will give 
 * luminance values from A through M (if needed), giving the 
 * 'Sum of Absolute Errors' as the output of the filter.
 * 
 * 
 * M  A  B  C  D  E  F  G  H 
 * 
 * I  0  1  2  3  x  x  x  x
 * 
 * J  4  5  6  7  x  x  x  x
 * 
 * K  8  9 10 11  x  x  x  x
 * 
 * L 12 13 14 15  x  x  x  x
 * 
 * The number represents the indices of the original block.
 *  * 
 * The cost function is the residual between the original block
 * and the predicted block. The encoder will choose the prediction
 * mode that minimizes the residual.
 * 
 * Be aware that the more complex prediction algorithms requires
 * the use of a matrix to store all calcuated values, then the
 * matrix is spit out at each row, from left to right, going downwards
 * at each row. 
 *
 * @author <a href="mailto:shirley.mit07@gmail.com">Shirley Fung</a>
 * @file PredictionModes4x4Luma.str
 * @version 1.0
 */



/**
 * This function calculates prediction mode 0 for a 4x4 luminance
 * block. This is also called: vertical. 
 * 
 * Note that only pixels A, B, C, and D is required.
 * 
 * Note: there is an alternate implementation to this filter.
 *
 * @input A,B,C,D + 16 pixels from the original block
 * @output sum of absolute errors for mode 0
 */
int->int filter PredictionMode0() {
	
	// A,B,C,D 			peek(0-3);
	// originalBlk 		peek(4,19);
	work pop 20 push 1 {
		int sae; // sum of absolute errors
		for (int i=4; i<19; i++) {
			int predicted = peek(i%4);
			int original = peek(i);
			sae += abs(predicted-original);
		}
		push(sae);
		
		for (int i=0; i<=19; i++) {
			pop();
		}
	}
}


/**
 * This function calculates prediction mode 1 for a 4x4 luminance
 * block. This is also called: horizontal.
 * 
 * Note that only pixels I, J, K, and L is required.
 * 
 * @input I,J,K,L + 16 pixels from the original block
 * @output sum of absolute errors for mode 0
 */
int->int filter PredictionMode1() {

	// I,J,K,L			peek(0-3);
	// originalBlk 		peek(4,19);
	work pop 20 push 1 {
		int sae; // sum of absolute errors
		for (int rowCount=0; rowCount<4; rowCount++) {
			int original = peek(i); // gives you I,J,K, or L
			// interate though out values for each column
			for (int colCount=0; colCount<4; colCount++) {
				// note the peek index:
				// for a rowCount of 0, 
				// 4*(rowCount+1) gives you the offset to start at peek(4);
				// and so on...
				int predicted = peek(colCount + 4*(rowCount+1));
				sae += abs(predicted-original);
			}
		}
		push(sae);
		
		for (int i=0; i<=19; i++) {
			pop();
		}
	}
	
}

/**
 * This function calculates prediction mode 2 for a 4x4 luminance
 * block. This is a DC interpolation where the entire output stream
 * has the mean value of all luminance values from A to M.
 * In other words: result luminance value = sum{A,B,C,D,I,J,K,L}/8 
 * Consequently, A known values are required to generate the 16
 * predicted pixels.
 * @input I through L + 16 original pixels 
 * @output sum of aboslute errors for mode 2
 */
int->int filter PredictionMode2() {
	
	// I,J,K,L			peek(0-3);
	// originalBlk 		peek(4,19);	
	work pop 24 push 1 {
		int cumulativeAvg = 0;
		int sae = 0;
		for (int i=0; i<8; i++) {
			cumulativeAvg =+ (int) pop()/8;
		}
		
		for (int origCounter=8; origCounter<24; origCounter++) {
			int original = peek(origCounter);
			sae += cumulativeAvg - original;
		}
		
		push(sae);
		
		for (int i=0; i<=19; i++) {
			pop();
		}
	}   
}




/**
 * This function calculates prediction mode 3 for a 4x4 luminance
 * block. This is also called: diagonal down-left.
 * @input A,B,C,D,E,F,G,H + 16 original pixels
 * @output sum of aboslute errors for mode 3
 */
int->int filter PredictionMode3() {
	
	// A,B,C,D,E,F,G,H		peek(0-7);
	// originalBlk 			peek(8,23);

	work pop 24 push 1 {
		
		int sae = 0;
		int[16] predictionBlock;
		// calculate values for the 4x4 matrix
		predictionBlock[0] = (int) (peek(0) + 2*peek(1) + peek(2) + 2) / 4; 
		predictionBlock[1] =
		predictionBlock[4] = (int) (peek(1) + 2*input(2) + peek(3) + 2) / 4; 
		predictionBlock[2] =
		predictionBlock[5] =
		predictionBlock[8] = (int) (peek(2) + 2*peek(3) + peek(4) + 2) / 4; 
		predictionBlock[3] =
		predictionBlock[6] =
		predictionBlock[9] =
		predictionBlock[12] = (int) (peek(3) + 2*peek(4) + peek(5) + 2) / 4;
		predictionBlock[7] =
		predictionBlock[10] =
		predictionBlock[13] = (int) (peek(4) + 2*peek(5) + peek(6) + 2) / 4; 
		predictionBlock[11] =
		predictionBlock[14] = (int) (peek(5) + 2*peek(6) + peek(7) + 2) / 4; 
		predictionBlock[15] = (int) (peek(6) + 3*peek(7) + 2) / 4;
		
		for (int i=8; i<=23; i++) {
			sae += predictionBlock[i] - peek(i);
		}
		
		push(sae);
		
		for (int i=0; i<=23; i++) {
			pop();
		}
	}   
}


/**
 * This function calculates prediction mode 4 for a 4x4 luminance
 * block. This is also called: diagonal down-right.
 * @input A,B,C,D,I,J,K,L,M + 16 original pixels
 * @output sum of aboslute errors for mode 4
 */
int->int filter PredictionMode4() {
	
	// A,B,C,D,I,J,K,L,M	peek(0-8);
	// originalBlk 			peek(9,24);

	work pop 25 push 1 {
		
		int sae;
		int[16] predictionBlock;
		// calculate values for the 4x4 matrix
		predictionBlock[0] = 
		predictionBlock[5] =
		predictionBlock[10] =
		predictionBlock[15] = (int) (peek(4) + 2*peek(8) + peek(0) + 2) / 4; 
		predictionBlock[4] =
		predictionBlock[9] =
		predictionBlock[14] = (int) (peek(5) + 2*peek(4) + peek(8)] + 2) / 4;
		predictionBlock[8] =
		predictionBlock[13] = (int) (peek(6) + 2*peek(5) + peek(4) + 2) / 4;
		predictionBlock[12] = (int) (peek(7) + 2*peek(6) + peek(5) + 2) / 4;
		predictionBlock[1] =
		predictionBlock[6] =
		predictionBlock[11] = (int) (peek(8) + 2*peek(0) + peek(1) + 2) / 4;
		predictionBlock[2] =
		predictionBlock[7] = (int) (peek(0) + 2*peek(1) + peek(2) + 2) / 4;
		predictionBlock[3] = (int) (peek(1) + 2*peek(2) + peek(3) + 2) / 4;
		

		for (int i=9; i<=24; i++) {
			sae += predictionBlock[i] - peek(i);
		}
		
		push(sae);
		
		for (int i=0; i<=24; i++) {
			pop();
		}
	}   
}

/**
 * This function calculates prediction mode 5 for a 4x4 luminance
 * block. This is also called: vertical-right.
 * @input A,B,C,D,I,J,K,M + 16 original pixels
 * @output sum of aboslute errors for mode 5
 */
int->int filter PredictionMode5() {
	
	// A,B,C,D,I,J,K,M		peek(0-7);
	// originalBlk 			peek(8,23);
	
	work pop 24 push 1 {
		
		int sae;
		int[16] predictionBlock;
		// calculate values for the 4x4 matrix
		predictionBlock[0] = 
		predictionBlock[9] = (int) (peek(7) + peek(0) + 1) / 2; 
		predictionBlock[1] =
		predictionBlock[10] = (int) (peek(0) + peek(1) + 1) / 2; 
		predictionBlock[2] =
		predictionBlock[11] = (int) (peek(1) + peek(2) + 1) / 2;
		predictionBlock[3] = (int) (peek(2) + peek(3) + 1) / 2;
		predictionBlock[4] =
		predictionBlock[13] = (int) (peek(4) + 2*peek(7) + peek(0) + 2) / 4;
		predictionBlock[5] =
		predictionBlock[14] = (int) (peek(7) + 2*peek(0) + peek(1) + 2) / 4;
		predictionBlock[6] =
		predictionBlock[15] = (int) (peek(0) + 2*peek(1) + peek(2) + 2) / 4;
		predictionBlock[7] = (int) (peek(1) + 2*peek(2) + peek(3) + 2) / 4;
		predictionBlock[8] = (int) (peek(7) + 2*peek(4) + peek(5) + 2) / 4;
		predictionBlock[12] = (int) (peek(4) + 2*peek(5) + peek(6) + 2) / 4;

		for (int i=8; i<=23; i++) {
			sae += predictionBlock[i] - peek(i);
		}
		
		push(sae);
		
		for (int i=0; i<=23; i++) {
			pop();
		}
	} 
}


/**
 * This function calculates prediction mode 6 for a 4x4 luminance
 * block. This is also called: horizontal-down.
 * @input A,B,C,I,J,K,L,M + 16 original pixels
 * @output sum of aboslute errors for mode 6
 */
int->int filter PredictionMode6() {
	
	// A,B,C,I,J,K,L,M		peek(0-7);
	// originalBlk 			peek(8,23);

	work pop 24 push 1 {
		
		int sae;
		int[16] predictionBlock;
		// calculate values for the 4x4 matrix
		predictionBlock[0] = 
		predictionBlock[6] = (int) (peek(7) + peek(3) + 1) / 2; 
		predictionBlock[1] =
		predictionBlock[7] = (int) (peek(3) + 2*peek(7) + peek(0) + 2) / 4; 
		predictionBlock[2] =
		predictionBlock[2] = (int) (peek(7) + 2*peek(0) + peek(1) + 2) / 4; 
		predictionBlock[3] = (int) (peek(7) + 2*peek(0) + peek(1) + 2) / 4;
		predictionBlock[4] =
		predictionBlock[10] = (int) (peek(3) + peek(4) + 1) / 2;
		predictionBlock[5] =
		predictionBlock[11] = (int) (peek(7) + 2*peek(3) + peek(4) + 2) / 4;
		predictionBlock[8] =
		predictionBlock[14] = (int) (peek(4) + peek(5) + 1) / 2;
		predictionBlock[9] = 
		predictionBlock[15] = (int) (peek(3) + 2*peek(4) + peek(5) + 2) / 4;
		predictionBlock[12] = (int) (peek(4) + 2*peek(5) + peek(6) + 2) / 4;


		for (int i=8; i<=23; i++) {
			sae += predictionBlock[i] - peek(i);
		}
		
		push(sae);
		
		for (int i=0; i<=23; i++) {
			pop();
		}
	} 
}


/**
 * This function calculates prediction mode 7 for a 4x4 luminance
 * block. This is also called: vertical-left.
 * @input A,B,C,D,E,F,G + 16 original pixels
 * @output sum of aboslute errors for mode 7
 */
int->int filter PredictionMode7() {
	
	// A,B,C,I,J,K,L,M		peek(0-6);
	// originalBlk 			peek(7,22);
	work pop 16 peek 12 push 16 {
		
		int sae;
		int[16] predictionBlock;		
		// calculate values for the 4x4 matrix
		predictionBlock[0] = (int) (peek(0) + peek(1) + 1) / 2; 
		predictionBlock[1] =  
		predictionBlock[8] = (int) (peek(1) + peek(2) + 1) / 2;
		predictionBlock[2] = 
		predictionBlock[9] = (int) (peek(2) + peek(3) + 1) / 2;
		predictionBlock[3] = 
		predictionBlock[10] = (int) (peek(3) + peek(4) + 1) / 2;
		predictionBlock[11] = (int) (peek(4) + peek(5) + 1) / 2;
		predictionBlock[4] = (int) (peek(0) + 2*peek(1) + peek(2) + 2) / 4; 
		predictionBlock[5] =
		predictionBlock[12] = (int) (peek(1) + 2*peek(2) + peek(3) + 2) / 4; 
		predictionBlock[6] =
		predictionBlock[13] = (int) (peek(2) + 2*peek(3) + peek(4) + 2) / 4; 
		predictionBlock[7] =
		predictionBlock[14] = (int) (peek(3) + 2*peek(4) + peek(5) + 2) / 4;
		predictionBlock[15] = (int) (peek(4) + 2*peek(5) + peek(6) + 2) / 4;  

		for (int i=7; i<=22; i++) {
			sae += predictionBlock[i] - peek(i);
		}
		
		push(sae);
		
		for (int i=0; i<=23; i++) {
			pop();
		}
	} 
}

/**
 * This function calculates prediction mode 8 for a 4x4 luminance
 * block. This is also called: horizontal-up.
 * @input I,J,K,L + 16 original pixels
 * @output sum of aboslute errors for mode 8
 */
int->int filter PredictionMode8() {
	
	work pop 20 push 1 {
		
		// I,J,K,L				peek(0-3);
		// originalBlk 			peek(4,19);
		int sae;
		int[16] predictionBlock;
		// calculate values for the 4x4 matrix
		predictionBlock[0] = (int) (peek(0) + peek(1) + 1) / 2; 
		predictionBlock[1] = (int) (peek(0) + 2*peek(1) + peek(2) + 2) / 4;
		predictionBlock[2] = 
		predictionBlock[4] = (int) (peek(1) + peek(2) + 1) / 2;
		predictionBlock[3] = 
		predictionBlock[5] = (int) (peek(2) + 2*peek(3) + peek(4) + 2) / 4;
		predictionBlock[6] = 
		predictionBlock[8] = (int) (peek(3) + peek(4) + 1) / 2;
		predictionBlock[7] = 
		predictionBlock[9] = (int) (peek(3) + 3*peek(4) + 2) / 4;
		predictionBlock[11] =
		predictionBlock[13] =
		predictionBlock[14] =
		predictionBlock[15] = input[11];


		for (int i=4; i<=19; i++) {
			sae += predictionBlock[i] - peek(i);
		}
		
		push(sae);
		
		for (int i=0; i<=19; i++) {
			pop();
		}
	} 
}





