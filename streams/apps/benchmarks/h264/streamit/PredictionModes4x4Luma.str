/*
 * [Shirley]
 * This file contains the various functions for generating the 9
 * prediction modes for a 4x4 intra prediction block. 
 *
 * This is new to MPEG-2
 *  
 * Note that all prediction modes can be calculated independently
 * of each other and therefore can be parallelized.
 * 
 * Reference: http://www.rgu.ac.uk/files/h264_intrapred.pdf
 */

/**
 * @description
 * This file contains various functions that takes in 13 pixels
 * and calculate all 9 prediction modes such that the best one 
 * can be used for a luminance block. Not all modes will require
 * all 13 pixels. These filters will assume the input will give 
 * luminance values from A through M, giving an output that is
 * denoted by numbers, in the order below (not in zig-zag).
 * 
 * 
 * M  A  B  C  D  E  F  G  H 
 * 
 * I  0  1  2  3  x  x  x  x
 * 
 * J  4  5  6  7  x  x  x  x
 * 
 * K  8  9 10 11  x  x  x  x
 * 
 * L 12 13 14 15  x  x  x  x
 * 
 * The number represents the indices of the prediction block.
 * 
 * The cost function is the residual between the original block
 * and the predicted block. The encoder will choose the prediction
 * mode that minimizes the residual.
 * 
 * Be aware that the more complex prediction algorithms requires
 * the use of a matrix to store all calcuated values, then the
 * matrix is spit out at each row, from left to right, going downwards
 * at each row.
 * 
 *
 * @author <a href="mailto:shirley.mit07@gmail.com">Shirley Fung</a>
 * @file PredictionModes4x4Luma.str
 * @version 1.0
 */



/**
 * This function calculates prediction mode 0 for a 4x4 luminance
 * block. This is also called: vertical. 
 * 
 * Note that only pixels A, B, C, and D is required.
 * 
 * Note: there is an alternate implementation to this filter. The
 * filter can spit out pixels 4-16 very quickly since the data for
 * them is already known once pixels A-D had been looked at. I am
 * not sure of the consequences of pushing quickly versus having
 * the data pushed one by one at each execution of the work function.
 *
 * @input A stream of 13 luminance data for pixels A through M.
 * @output A stream of 16 pixels predicted by mode 0
 */
int->int filter PredictionMode0() {
	init {
		int[4] AtoD;
	}
	
	work pop 12 peek 12 push 16 {

	for (int AtoDCount = 0; AtoDCount<12; AtoDCount++) {
		if (AtoDCount <= 0 && ItoLCount >= 4) { // I to L pixels
			AtoD[AtoDCount-8] = peek(AtoDCount);
		}
		pop();
	}
	for (int i=0; i<4; i++) { // each row
		for (int j=0; j<4; j++) { // each element
			push(AtoD[j]);
		}
	}
}


/**
 * This function calculates prediction mode 1 for a 4x4 luminance
 * block. This is also called: horizontal.
 * 
 * Note that only pixels I, J, K, and L is required.
 * 
 * @input A stream of 13 luminance data for pixels A through M.
 * @output A stream of 16 pixels predicted by mode 1
 */
int->int filter PredictionMode1() {
	init {
		int ItoL[4];
   	}
	work pop 12 peek 12 push 16 {
	
	for (int ItoLCount = 0; ItoLCount<12; ItoLCount++) {
		if (ItoLCount <= 8 && ItoLCount >= 11) { // I to L pixels
			ItoL[ItoLCount-8] = peek(ItoLCount);
		}
		pop();
	}
	for (int i=0; i<4; i++) { // each row
		for (int j=0; j<4; j++) { // each element 4 times
			push(AtoD[i]); // same for entire row
		}
	}
	
}

/**
 * This function calculates prediction mode 2 for a 4x4 luminance
 * block. This is a DC interpolation where the entire output stream
 * has the mean value of all luminance values from A to M.
 * In other words: result luminance value = sum{A,B,C,D,I,J,K,L}/8 
 * Consequently, 8 input values are required to generate the 16
 * output pixels.
 * @input A stream of 13 luminance data for pixels A through M.
 * @output A stream of 16 pixels predicted by mode 2
 */
int->int filter PredictionMode2() {
	init {

		int counter = 0; 
		// to keep track of where you are in the input stream
		// from 0 to 3, input values are popped to calculate avg
		// from 4 to 7, input values are popped and skipped
		// from 8 to 11, input values are popped to calculate avg
		// at 11, values are ready to be pushed
		// otherwise (12), input value is skipped
		int cumulativeAvg = 0;
	
	}
	work pop 1 push [0, 16] {
	if ((counter >= 0 && counter <= 3) || 
		(counter >= 8 && counter <= 11)) {
		cumulativeAvg =+ (int) pop()/8;
		counter++;
		if (counter == 12) {
			// ready to push 16 of the avg luminance value
			for (int i = 0; i < 16; i++) {
				push(cumulativeAvg);
			}
		}

	} else if (counter >= 4 && counter <= 7) {
		pop();
		counter++;
	} else { // count is at 12
		pop();
		// no more input data is required
		counter = 0; // resets counter
	}

	}   
}




/**
 * This function calculates prediction mode 3 for a 4x4 luminance
 * block. This is also called: diagonal down-left.
 * @input A stream of 13 luminance data for pixels A through M.
 * @predictionBlock A stream of 16 pixels predicted by mode 3
 */
int->int filter PredictionMode3() {
	init {
		int[12] input; // A, B, C, D, E, F, G, H, I, J, K, M
		int[16] predictionBlock; // predictionBlock 4x4 matrix, in an array
	}
	work pop 16 peek 12 push 16 {
		// store input values into an array
		for (int i = 0; i < 12; i++) {
			input[i] = peek(i);
		}
		
		// calculate values for the 4x4 matrix
		predictionBlock[0] = (int) (input[0] + 2*input[1] + input[2] + 2) / 4; 
		predictionBlock[1] =
		predictionBlock[4] = (int) (input[1] + 2*input[2] + input[3] + 2) / 4; 
		predictionBlock[2] =
		predictionBlock[5] =
		predictionBlock[8] = (int) (input[2] + 2*input[3] + input[4] + 2) / 4; 
		predictionBlock[3] =
		predictionBlock[6] =
		predictionBlock[9] =
		predictionBlock[12] = (int) (input[3] + 2*input[4] + input[5] + 2) / 4;
		predictionBlock[7] =
		predictionBlock[10] =
		predictionBlock[13] = (int) (input[4] + 2*input[5] + input[6] + 2) / 4; 
		predictionBlock[11] =
		predictionBlock[14] = (int) (input[5] + 2*input[6] + input[7] + 2) / 4; 
		predictionBlock[15] = (int) (input[6] + 3*input[7] + 2) / 4;
		
		// pushing the predictionBlock
		for (int i = 0; i < 16; i++) {
			push(predictionBlock[i]);
		}
	}
}


/**
 * This function calculates prediction mode 4 for a 4x4 luminance
 * block. This is also called: diagonal down-right.
 * @input A stream of 13 luminance data for pixels A through M.
 * @predictionBlock A stream of 16 pixels predicted by mode 4
 */
int->int filter PredictionMode4() {
	init {
		int[12] input; // A, B, C, D, E, F, G, H, I, J, K, M
		int[16] predictionBlock; // predictionBlock 4x4 matrix, in an array
	}
	work pop 16 peek 12 push 16 {
		// store input values into an array
		for (int i = 0; i < 12; i++) {
			input[i] = peek(i);
		}
		
		// calculate values for the 4x4 matrix
		predictionBlock[0] = 
		predictionBlock[5] =
		predictionBlock[10] =
		predictionBlock[15] = (int) (input[8] + 2*input[12] + input[0] + 2) / 4; 
		predictionBlock[4] =
		predictionBlock[9] =
		predictionBlock[14] = (int) (input[9] + 2*input[8] + input[12] + 2) / 4;
		predictionBlock[8] =
		predictionBlock[13] = (int) (input[10] + 2*input[9] + input[8] + 2) / 4;
		predictionBlock[12] = (int) (input[11] + 2*input[10] + input[9] + 2) / 4;
		predictionBlock[1] =
		predictionBlock[6] =
		predictionBlock[11] = (int) (input[12] + 2*input[0] + input[1] + 2) / 4;
		predictionBlock[2] =
		predictionBlock[7] = (int) (input[0] + 2*input[1] + input[2] + 2) / 4;
		predictionBlock[3] = (int) (input[1] + 2*input[2] + input[3] + 2) / 4;
		
		
		// pushing the predictionBlock
		for (int i = 0; i < 16; i++) {
			push(predictionBlock[i]);
		}
	}
}

/**
 * This function calculates prediction mode 5 for a 4x4 luminance
 * block. This is also called: vertical-right.
 * @input A stream of 13 luminance data for pixels A through M.
 * @predictionBlock A stream of 16 pixels predicted by mode 4
 */
int->int filter PredictionMode5() {
	init {
		int[12] input; // A, B, C, D, E, F, G, H, I, J, K, M
		int[16] predictionBlock; // predictionBlock 4x4 matrix, in an array
	}
	work pop 16 peek 12 push 16 {
		// store input values into an array
		for (int i = 0; i < 12; i++) {
			input[i] = peek(i);
		}
		
		// calculate values for the 4x4 matrix
		predictionBlock[0] = 
		predictionBlock[9] = (int) (input[12] + input[0] + 1) / 2; 
		predictionBlock[1] =
		predictionBlock[10] = (int) (input[0] + input[1] + 1) / 2; 
		predictionBlock[2] =
		predictionBlock[11] = (int) (input[1] + input[2] + 1) / 2;
		predictionBlock[3] = (int) (input[2] + input[3] + 1) / 2;
		predictionBlock[4] =
		predictionBlock[13] = (int) (input[8] + 2*input[12] + input[0] + 2) / 4;
		predictionBlock[5] =
		predictionBlock[14] = (int) (input[12] + 2*input[0] + input[1] + 2) / 4;
		predictionBlock[6] =
		predictionBlock[15] = (int) (input[0] + 2*input[1] + input[2] + 2) / 4;
		predictionBlock[7] = (int) (input[1] + 2*input[2] + input[3] + 2) / 4;
		predictionBlock[8] = (int) (input[12] + 2*input[8] + input[9] + 2) / 4;
		predictionBlock[12] = (int) (input[8] + 2*input[9] + input[10] + 2) / 4;


		
		// pushing the predictionBlock
		for (int i = 0; i < 16; i++) {
			push(predictionBlock[i]);
		}
	}
}


/**
 * This function calculates prediction mode 6 for a 4x4 luminance
 * block. This is also called: horizontal-down.
 * @input A stream of 13 luminance data for pixels A through M.
 * @predictionBlock A stream of 16 pixels predicted by mode 4
 */
int->int filter PredictionMode6() {
	init {
		int[12] input; // A, B, C, D, E, F, G, H, I, J, K, M
		int[16] predictionBlock; // predictionBlock 4x4 matrix, in an array
	}
	work pop 16 peek 12 push 16 {
		// store input values into an array
		for (int i = 0; i < 12; i++) {
			input[i] = peek(i);
		}
		
		// calculate values for the 4x4 matrix
		predictionBlock[0] = 
		predictionBlock[6] = (int) (input[12] + input[8] + 1) / 2; 
		predictionBlock[1] =
		predictionBlock[7] = (int) (input[8] + 2*input[12] + input[0] + 2) / 4; 
		predictionBlock[2] =
		predictionBlock[2] = (int) (input[12] + 2*input[0] + input[1] + 2) / 4; 
		predictionBlock[3] = (int) (input[1] + 2*input[0] + input[1] + 2) / 4;
		predictionBlock[4] =
		predictionBlock[10] = (int) (input[8] + input[9] + 1) / 2;
		predictionBlock[5] =
		predictionBlock[11] = (int) (input[12] + 2*input[8] + input[9] + 2) / 4;
		predictionBlock[8] =
		predictionBlock[14] = (int) (input[9] + input[10] + 1) / 2;
		predictionBlock[9] = 
		predictionBlock[15] = (int) (input[8] + 2*input[9] + input[10] + 2) / 4;
		predictionBlock[12] = (int) (input[9] + 2*input[10] + input[11] + 2) / 4;


		
		// pushing the predictionBlock
		for (int i = 0; i < 16; i++) {
			push(predictionBlock[i]);
		}
	}
}


/**
 * This function calculates prediction mode 7 for a 4x4 luminance
 * block. This is also called: vertical-left.
 * @input A stream of 13 luminance data for pixels A through M.
 * @predictionBlock A stream of 16 pixels predicted by mode 4
 */
int->int filter PredictionMode7() {
	init {
		int[12] input; // A, B, C, D, E, F, G, H, I, J, K, M
		int[16] predictionBlock; // predictionBlock 4x4 matrix, in an array
	}
	work pop 16 peek 12 push 16 {
		// store input values into an array
		for (int i = 0; i < 12; i++) {
			input[i] = peek(i);
		}
		
		// calculate values for the 4x4 matrix
		predictionBlock[0] = (int) (input[0] + input[1] + 1) / 2; 
		predictionBlock[1] =  
		predictionBlock[8] = (int) (input[1] + input[2] + 1) / 2;
		predictionBlock[2] = 
		predictionBlock[9] = (int) (input[2] + input[3] + 1) / 2;
		predictionBlock[3] = 
		predictionBlock[10] = (int) (input[3] + input[4] + 1) / 2;
		predictionBlock[11] = (int) (input[4] + input[5] + 1) / 2;
		predictionBlock[4] = (int) (input[0] + 2*input[1] + input[2] + 2) / 4; 
		predictionBlock[5] =
		predictionBlock[12] = (int) (input[1] + 2*input[2] + input[3] + 2) / 4; 
		predictionBlock[6] =
		predictionBlock[13] = (int) (input[2] + 2*input[3] + input[4] + 2) / 4; 
		predictionBlock[7] =
		predictionBlock[14] = (int) (input[3] + 2*input[4] + input[5] + 2) / 4;
		predictionBlock[15] = (int) (input[4] + 2*input[5] + input[6] + 2) / 4;  

		
		// pushing the predictionBlock
		for (int i = 0; i < 16; i++) {
			push(predictionBlock[i]);
		}
	}
}

/**
 * This function calculates prediction mode 8 for a 4x4 luminance
 * block. This is also called: horizontal-up.
 * @input A stream of 13 luminance data for pixels A through M.
 * @predictionBlock A stream of 16 pixels predicted by mode 4
 */
int->int filter PredictionMode8() {
	init {
		int[12] input; // A, B, C, D, E, F, G, H, I, J, K, M
		int[16] predictionBlock; // predictionBlock 4x4 matrix, in an array
	}
	work pop 16 peek 12 push 16 {
		// store input values into an array
		for (int i = 0; i < 12; i++) {
			input[i] = peek(i);
		}
		
		// calculate values for the 4x4 matrix
		predictionBlock[0] = (int) (input[8] + input[9] + 1) / 2; 
		predictionBlock[1] = (int) (input[8] + 2*input[9] + input[10] + 2) / 4;
		predictionBlock[2] = 
		predictionBlock[4] = (int) (input[9] + input[10] + 1) / 2;
		predictionBlock[3] = 
		predictionBlock[5] = (int) (input[9] + 2*input[10] + input[11] + 2) / 4;
		predictionBlock[6] = 
		predictionBlock[8] = (int) (input[10] + input[11] + 1) / 2;
		predictionBlock[7] = 
		predictionBlock[9] = (int) (input[10] + 3*input[11] + 2) / 4;
		predictionBlock[11] =
		predictionBlock[13] =
		predictionBlock[14] =
		predictionBlock[15] = input[11];


		
		// pushing the predictionBlock
		for (int i = 0; i < 16; i++) {
			push(predictionBlock[i]);
		}
	}
}





