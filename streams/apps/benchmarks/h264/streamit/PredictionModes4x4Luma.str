/*
 * [Shirley]
 * This file contains the various functions for generating the 9
 * prediction modes for a 4x4 intra prediction block. 
 *
 * This is new to MPEG-2
 *  
 * Note that all prediction modes can be calculated independently
 * of each other and therefore can be parallelized.
 * 
 * Reference: http://www.rgu.ac.uk/files/h264_intrapred.pdf
 */

/**
 * @description
 * This file contains various functions that takes in 13 pixels
 * and calculate all 9 prediction modes such that the best one 
 * can be used for a luminance block. Not all modes will require
 * all 13 pixels. These filters will assume the input will give 
 * luminance values from A through M, giving an output that is
 * denoted by numbers, in the order below (not in zig-zag).
 * 
 * 
 * M  A  B  C  D  E  F  G  H 
 * 
 * I  0  1  2  3  x  x  x  x
 * 
 * J  4  5  6  7  x  x  x  x
 * 
 * K  8  9 10 11  x  x  x  x
 * 
 * L 12 13 14 15  x  x  x  x
 * 
 * The number represents the indices of the prediction block.
 * 
 * The cost function is the residual between the original block
 * and the predicted block. The encoder will choose the prediction
 * mode that minimizes the residual.
 * 
 * Be aware that the more complex prediction algorithms requires
 * the use of a matrix to store all calcuated values, then the
 * matrix is spit out at each row, from left to right, going downwards
 * at each row.
 * 
 *
 * @author <a href="mailto:shirley.mit07@gmail.com">Shirley Fung</a>
 * @file PredictionModes4x4Luma.str
 * @version 1.0
 */



/**
 * This function calculates prediction mode 0 for a 4x4 luminance
 * block. This is also called: vertical. 
 * 
 * Note that only pixels A, B, C, and D is required.
 * 
 * Note: there is an alternate implementation to this filter. The
 * filter can spit out pixels 4-16 very quickly since the data for
 * them is already known once pixels A-D had been looked at. I am
 * not sure of the consequences of pushing quickly versus having
 * the data pushed one by one at each execution of the work function.
 *
 * @input A stream of 13 luminance data for pixels A through M.
 * @output A stream of 16 pixels predicted by mode 0
 */
int->int filter PredictionMode0() {
	init {
		int counter = 0; 
		// to keep track of where you are in the input & output 
		// stream
		// from 0 to 3, luminance value from A to D is stored
		// otherwise, skip
		int[4] AtoD;
	}
	
	work pop [0, 1] peek [0, 1] push 1 {
	  
	if (counter >= 0 && counter <= 3) {
		int luminVal = peek(0);
		push(luminVal);
		AtoD[counter] = luminVal;
		pop();
		counter++;
	} else {
		push[counter%4]; // continue pushing the rest
		if (counter <= 12) {
			pop(); // skip values
		}
		// all 13 input values from stream has been pushed
		// no pop() is needed
		// resetting counter    
		if (counter == 15) {
			counter = 0;
		} else {
			counter++;
		}
	}
}

/* ALTERNATE IMPLEMENTATION for work function
 * in this case, the counter only keeps track of the input stream
 */

/*
	work pop 1 peek [0, 1] push [1, 12] {
     
	if (counter >= 0 && counter <= 3) {
		int luminVal = peek(0);
		push(luminVal);
		AtoD[counter] = luminVal;
		pop();
        	counter++;

        	if (counter == 3) {
        		for (i = 0, i < 3, i++) {
        		// 3 more rows (4 pixels each) to push
                		for (j = 0, i < 4, i++) {
                			push[j]; // push each row
                		}
			}
        	

	} else {

		if (counter <= 12) {
			pop(); // skip values
        	}

		// all 13 input values from stream has been pushed
		// no pop() is needed
		// resetting counter   
		if (counter == 12) {
			counter = 0;
        	} else {
			counter++;
        	}
	}
*/

}

/**
 * This function calculates prediction mode 1 for a 4x4 luminance
 * block. This is also called: horizontal.
 * 
 * Note that only pixels I, J, K, and L is required.
 * 
 * @input A stream of 13 luminance data for pixels A through M.
 * @output A stream of 16 pixels predicted by mode 1
 */
int->int filter PredictionMode1() {
	init {
		int counter = 0; 
		// to keep track of where you are in the input stream
		// from 0 to 7, luminance value from A to H is skipped
		// from 8 to 11, luminance values are pushed
		// otherwise (12), skip luminance value
    	}
	work pop [0, 1] peek [0, 1] push [0, 4] {
	
	if (counter >= 0 && counter <= 7 ) {
		pop();
		counter++;
	} else if (counter >= 8 && counter <= 11) {
		counter++;
		// push 4 copies of the current pixel
		push(peek(0)); 
		push(peek(0));
		push(peek(0));
		push(peek(0));
		pop();
	} else {
		// no more input data is required
		counter = 0; // resets counter
	}

	}   
}

/**
 * This function calculates prediction mode 2 for a 4x4 luminance
 * block. This is a DC interpolation where the entire output stream
 * has the mean value of all luminance values from A to M.
 * In other words: result luminance value = sum{A,B,C,D,I,J,K,L}/8 
 * Consequently, 8 input values are required to generate the 16
 * output pixels.
 * @input A stream of 13 luminance data for pixels A through M.
 * @output A stream of 16 pixels predicted by mode 2
 */
int->int filter PredictionMode2() {
	init {

		int counter = 0; 
		// to keep track of where you are in the input stream
		// from 0 to 3, input values are popped to calculate avg
		// from 4 to 7, input values are popped and skipped
		// from 8 to 11, input values are popped to calculate avg
		// at 11, values are ready to be pushed
		// otherwise (12), input value is skipped
		int cumulativeAvg = 0;
	
	}
	work pop 1 push [0, 16] {
	if ((counter >= 0 && counter <= 3) || 
		(counter >= 8 && counter <= 11)) {
		cumulativeAvg =+ (int) pop()/8;
		counter++;
		if (counter == 12) {
			// ready to push 16 of the avg luminance value
			for (int i = 0; i < 16; i++) {
				push(cumulativeAvg);
			}
		}

	} else if (counter >= 4 && counter <= 7) {
		pop();
		counter++;
	} else { // count is at 12
		pop();
		// no more input data is required
		counter = 0; // resets counter
	}

	}   
}




/**
 * This function calculates prediction mode 3 for a 4x4 luminance
 * block. This is also called: diagonal down-left.
 * @input A stream of 13 luminance data for pixels A through M.
 * @predictionBlock A stream of 16 pixels predicted by mode 3
 */
int->int filter PredictionMode3() {
	init {
		int[12] input; // A, B, C, D, E, F, G, H, I, J, K, M
		int[16] predictionBlock; // predictionBlock 4x4 matrix, in an array
	}
	work pop 16 peek 12 push 16 {
		// store input values into an array
		for (int i = 0; i < 12; i++) {
			input[i] = peek(i);
		}
		
		// calculate values for the 4x4 matrix
		predictionBlock[0] = (int) (input[0] + 2*input[1] + input[2] + 2) / 4; 
		predictionBlock[1] =
		predictionBlock[4] = (int) (input[1] + 2*input[2] + input[3] + 2) / 4; 
		predictionBlock[2] =
		predictionBlock[5] =
		predictionBlock[8] = (int) (input[2] + 2*input[3] + input[4] + 2) / 4; 
		predictionBlock[3] =
		predictionBlock[6] =
		predictionBlock[9] =
		predictionBlock[12] = (int) (input[3] + 2*input[4] + input[5] + 2) / 4;
		predictionBlock[7] =
		predictionBlock[10] =
		predictionBlock[13] = (int) (input[4] + 2*input[5] + input[6] + 2) / 4; 
		predictionBlock[11] =
		predictionBlock[14] = (int) (input[5] + 2*input[6] + input[7] + 2) / 4; 
		predictionBlock[15] = (int) (input[6] + 3*input[7] + 2) / 4;
		
		// pushing the predictionBlock
		for (int i = 0; i < 16; i++) {
			push(predictionBlock[i]);
		}
	}
}


/**
 * This function calculates prediction mode 4 for a 4x4 luminance
 * block. This is also called: diagonal down-right.
 * @input A stream of 13 luminance data for pixels A through M.
 * @predictionBlock A stream of 16 pixels predicted by mode 4
 */
int->int filter PredictionMode4() {
	init {
		int[12] input; // A, B, C, D, E, F, G, H, I, J, K, M
		int[16] predictionBlock; // predictionBlock 4x4 matrix, in an array
	}
	work pop 16 peek 12 push 16 {
		// store input values into an array
		for (int i = 0; i < 12; i++) {
			input[i] = peek(i);
		}
		
		// calculate values for the 4x4 matrix
		predictionBlock[0] = 
		predictionBlock[5] =
		predictionBlock[10] =
		predictionBlock[15] = (int) (input[8] + 2*input[12] + input[0] + 2) / 4; 
		predictionBlock[4] =
		predictionBlock[9] =
		predictionBlock[14] = (int) (input[9] + 2*input[8] + input[12] + 2) / 4;
		predictionBlock[8] =
		predictionBlock[13] = (int) (input[10] + 2*input[9] + input[8] + 2) / 4;
		predictionBlock[12] = (int) (input[11] + 2*input[10] + input[9] + 2) / 4;
		predictionBlock[1] =
		predictionBlock[6] =
		predictionBlock[11] = (int) (input[12] + 2*input[0] + input[1] + 2) / 4;
		predictionBlock[2] =
		predictionBlock[7] = (int) (input[0] + 2*input[1] + input[2] + 2) / 4;
		predictionBlock[3] = (int) (input[1] + 2*input[2] + input[3] + 2) / 4;
		
		
		// pushing the predictionBlock
		for (int i = 0; i < 16; i++) {
			push(predictionBlock[i]);
		}
	}
}

/**
 * This function calculates prediction mode 5 for a 4x4 luminance
 * block. This is also called: vertical-right.
 * @input A stream of 13 luminance data for pixels A through M.
 * @predictionBlock A stream of 16 pixels predicted by mode 4
 */
int->int filter PredictionMode5() {
	init {
		int[12] input; // A, B, C, D, E, F, G, H, I, J, K, M
		int[16] predictionBlock; // predictionBlock 4x4 matrix, in an array
	}
	work pop 16 peek 12 push 16 {
		// store input values into an array
		for (int i = 0; i < 12; i++) {
			input[i] = peek(i);
		}
		
		// calculate values for the 4x4 matrix
		predictionBlock[0] = 
		predictionBlock[9] = (int) (input[12] + input[0] + 1) / 2; 
		predictionBlock[1] =
		predictionBlock[10] = (int) (input[0] + input[1] + 1) / 2; 
		predictionBlock[2] =
		predictionBlock[11] = (int) (input[1] + input[2] + 1) / 2;
		predictionBlock[3] = (int) (input[2] + input[3] + 1) / 2;
		predictionBlock[4] =
		predictionBlock[13] = (int) (input[8] + 2*input[12] + input[0] + 2) / 4;
		predictionBlock[5] =
		predictionBlock[14] = (int) (input[12] + 2*input[0] + input[1] + 2) / 4;
		predictionBlock[6] =
		predictionBlock[15] = (int) (input[0] + 2*input[1] + input[2] + 2) / 4;
		predictionBlock[7] = (int) (input[1] + 2*input[2] + input[3] + 2) / 4;
		predictionBlock[8] = (int) (input[12] + 2*input[8] + input[9] + 2) / 4;
		predictionBlock[12] = (int) (input[8] + 2*input[9] + input[10] + 2) / 4;


		
		// pushing the predictionBlock
		for (int i = 0; i < 16; i++) {
			push(predictionBlock[i]);
		}
	}
}


/**
 * This function calculates prediction mode 6 for a 4x4 luminance
 * block. This is also called: horizontal-down.
 * @input A stream of 13 luminance data for pixels A through M.
 * @predictionBlock A stream of 16 pixels predicted by mode 4
 */
int->int filter PredictionMode6() {
	init {
		int[12] input; // A, B, C, D, E, F, G, H, I, J, K, M
		int[16] predictionBlock; // predictionBlock 4x4 matrix, in an array
	}
	work pop 16 peek 12 push 16 {
		// store input values into an array
		for (int i = 0; i < 12; i++) {
			input[i] = peek(i);
		}
		
		// calculate values for the 4x4 matrix
		predictionBlock[0] = 
		predictionBlock[6] = (int) (input[12] + input[8] + 1) / 2; 
		predictionBlock[1] =
		predictionBlock[7] = (int) (input[8] + 2*input[12] + input[0] + 2) / 4; 
		predictionBlock[2] =
		predictionBlock[2] = (int) (input[12] + 2*input[0] + input[1] + 2) / 4; 
		predictionBlock[3] = (int) (input[1] + 2*input[0] + input[1] + 2) / 4;
		predictionBlock[4] =
		predictionBlock[10] = (int) (input[8] + input[9] + 1) / 2;
		predictionBlock[5] =
		predictionBlock[11] = (int) (input[12] + 2*input[8] + input[9] + 2) / 4;
		predictionBlock[8] =
		predictionBlock[14] = (int) (input[9] + input[10] + 1) / 2;
		predictionBlock[9] = 
		predictionBlock[15] = (int) (input[8] + 2*input[9] + input[10] + 2) / 4;
		predictionBlock[12] = (int) (input[9] + 2*input[10] + input[11] + 2) / 4;


		
		// pushing the predictionBlock
		for (int i = 0; i < 16; i++) {
			push(predictionBlock[i]);
		}
	}
}


/**
 * This function calculates prediction mode 7 for a 4x4 luminance
 * block. This is also called: vertical-left.
 * @input A stream of 13 luminance data for pixels A through M.
 * @predictionBlock A stream of 16 pixels predicted by mode 4
 */
int->int filter PredictionMode7() {
	init {
		int[12] input; // A, B, C, D, E, F, G, H, I, J, K, M
		int[16] predictionBlock; // predictionBlock 4x4 matrix, in an array
	}
	work pop 16 peek 12 push 16 {
		// store input values into an array
		for (int i = 0; i < 12; i++) {
			input[i] = peek(i);
		}
		
		// calculate values for the 4x4 matrix
		predictionBlock[0] = (int) (input[0] + input[1] + 1) / 2; 
		predictionBlock[1] =  
		predictionBlock[8] = (int) (input[1] + input[2] + 1) / 2;
		predictionBlock[2] = 
		predictionBlock[9] = (int) (input[2] + input[3] + 1) / 2;
		predictionBlock[3] = 
		predictionBlock[10] = (int) (input[3] + input[4] + 1) / 2;
		predictionBlock[11] = (int) (input[4] + input[5] + 1) / 2;
		predictionBlock[4] = (int) (input[0] + 2*input[1] + input[2] + 2) / 4; 
		predictionBlock[5] =
		predictionBlock[12] = (int) (input[1] + 2*input[2] + input[3] + 2) / 4; 
		predictionBlock[6] =
		predictionBlock[13] = (int) (input[2] + 2*input[3] + input[4] + 2) / 4; 
		predictionBlock[7] =
		predictionBlock[14] = (int) (input[3] + 2*input[4] + input[5] + 2) / 4;
		predictionBlock[15] = (int) (input[4] + 2*input[5] + input[6] + 2) / 4;  

		
		// pushing the predictionBlock
		for (int i = 0; i < 16; i++) {
			push(predictionBlock[i]);
		}
	}
}

/**
 * This function calculates prediction mode 8 for a 4x4 luminance
 * block. This is also called: horizontal-up.
 * @input A stream of 13 luminance data for pixels A through M.
 * @predictionBlock A stream of 16 pixels predicted by mode 4
 */
int->int filter PredictionMode8() {
	init {
		int[12] input; // A, B, C, D, E, F, G, H, I, J, K, M
		int[16] predictionBlock; // predictionBlock 4x4 matrix, in an array
	}
	work pop 16 peek 12 push 16 {
		// store input values into an array
		for (int i = 0; i < 12; i++) {
			input[i] = peek(i);
		}
		
		// calculate values for the 4x4 matrix
		predictionBlock[0] = (int) (input[8] + input[9] + 1) / 2; 
		predictionBlock[1] = (int) (input[8] + 2*input[9] + input[10] + 2) / 4;
		predictionBlock[2] = 
		predictionBlock[4] = (int) (input[9] + input[10] + 1) / 2;
		predictionBlock[3] = 
		predictionBlock[5] = (int) (input[9] + 2*input[10] + input[11] + 2) / 4;
		predictionBlock[6] = 
		predictionBlock[8] = (int) (input[10] + input[11] + 1) / 2;
		predictionBlock[7] = 
		predictionBlock[9] = (int) (input[10] + 3*input[11] + 2) / 4;
		predictionBlock[11] =
		predictionBlock[13] =
		predictionBlock[14] =
		predictionBlock[15] = input[11];


		
		// pushing the predictionBlock
		for (int i = 0; i < 16; i++) {
			push(predictionBlock[i]);
		}
	}
}





