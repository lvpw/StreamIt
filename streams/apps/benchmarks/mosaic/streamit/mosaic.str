/*StreamIT program designed to 

INSERT NEW COMMENTS HERE -> CHANGE FROM JUST FEATURE EXTRACTION TO CORRELATION TOO
take in a ppm file, extract significant
features according to the Kanade-Lucas-Tomasi (KLT) algorithm, and 
print out a ppm where those features are highlighted.

It also 
*/

/*12/20/06 - note that many of the array values that were static vars
had to be changed to hard-coded numbers like 320 (imageWidth) and 
240 (imageHeight) and 20 (iters)*/


/*compared to Feature 9-26, we added more comments*/

/*1/3/07 - change it from being [320][240] 6-element yiqstructs to just 
 6 matrices of [320][240]- in java, we are instantiating a new object for
 each yiqStruct, and so we have 320*240*6 new objects.  instead, we are now
 going to have just 6 objects that we instantiate when pushing/popping*/


/**************
****GLOBALS****
**************/

static {
	int patchsize = 3; // must be odd-valued -- 
					// the size of each feature square's side
	int imageWidth = 320; // width of the ppm image
	int imageHeight = 240; // height of the ppm image
	int iters = 60;
	int numImages = 2; //this is fixed for now, but eventually we want to 
					  // change the program so as to take an indeterminate number
	float iweight = 0.0; 
	float qweight = 0.0;
	float ransacThreshold = 0.001;	
	float probOutliers = 0.99; //desired probability of choosing at least one sample free from outliers
	int maxTrials = 1000; //maximum number of trials before we give up
	int maxDataTrials = 100; //max number of attempts to select a non-degenerate data set
	int s = 8;
	float muP = 1.0/100000;
	float muN = -1.0/100000;
	float eps = pow(2,-52);
	init {}

}

/**************
****STRUCTS****
**************/

/*
struct for each pixel of an image, including the yiq values, its minor eigen
value (if set), and its x and y coordinates indicated by 'ex' and 'yi'*/


/*struct yiqStruct{

    float y;
    float i;
    float q;
    float eigen;
    int ex;
    int yi;

}*/

struct bestFeatures{

	int x;
	int y;
	int z;
	float val;

}

struct normArray{
	float x;
	float y;
	float z;
}

struct featureListPair{

	bestFeatures[60] x1;
	bestFeatures[60] x2;
	int firstZeroIndex;
	
	normArray[60] n1;
	normArray[60] n2;
	
	normArray[8] nI1;
	normArray[8] nI2;
	
	float frame1scaleInd;
	float frame1c1Ind;
	float frame1c2Ind;
	float frame2scaleInd;
	float frame2c1Ind;
	float frame2c2Ind;
	
	float frame1scaleFeat;
	float frame1c1Feat;
	float frame1c2Feat;
	float frame2scaleFeat;
	float frame2c1Feat;
	float frame2c2Feat;
	
	float[3][3] bestF;
	float[3][3] tempF;
	int[8] ind; // s = 8
	int[60] bestInliers;
	int[60] tempInliers;
	float[60] d;
	int ninliers;
	int bestScore;
	int trialCount;
	float N;

	
}

struct imageAndFeatures{

	float[320][240] yImage;
	float[320][240] iImage;
	float[320][240] qImage;
	bestFeatures[60] myBest;
	int goodPts;

}
/*this struct is for gradient sums.  each pixel has a corresponding patch for which
the gradient is calculated.  this is done by taking each pixel, finding the gxx, gyy, and gxy,
and summing these values down a column.  then the values from each column within the patch are
added up, and this way a total value is arrived at for each pixel.  we generate a 2x2 matrix,
[gxx gxy; gxy gyy] and then find the eigenvalues to deem the original pixel's worth with respect
to tracking value.
*/

/*the Gstruct is a struct used for gradient calculations during the feature extraction process.*/

struct Gstruct{

    float gxx;
    float gyy;
    float gxy;

}



/*~~~~~~~~~~~~~~~~~~~
~~~~MAIN PIPELINE~~~~
~~~~~~~~~~~~~~~~~~~*/

/*Here we specify parameters that are hard-coded; perhaps later we can deal with these more
flexibly*/

void->void pipeline mosaic{

	int startx = patchsize + 1; 
	int starty = patchsize + 1;
    int winWidth  = imageWidth - patchsize - startx - 1; 
	int winHeight = imageHeight - patchsize - starty - 1;
	int corrWindowSize = 13;

	//  initial work
	
	add fileRead();
	
	add RGB2YIQ();
	add makeMatrices();
	
	//grunt work 
	add featureExtraction(startx, starty, imageWidth, imageHeight, 
					winWidth, winHeight, iweight, qweight, patchsize);
	add splitjoin{
		split duplicate;
		add IAFID();			
		add pipeline{
			//add sharpen(corrWindowSize);
			add correlation(corrWindowSize);
		}
		join roundrobin(1,2);
	};
	add imageAndFeatures->imageAndFeatures filter
	{	
		imageAndFeatures temp0;
		imageAndFeatures temp1;
		imageAndFeatures temp2;
		imageAndFeatures temp3;
		work pop 3 peek 4 push 2
		{
			temp0 = peek(0);
			temp1 = peek(1);
			temp2 = peek(2);
			temp3 = peek(3);
			temp0.myBest = temp1.myBest;
			temp3.myBest = temp2.myBest;			
			pop();
			pop();
			pop();			
			push(temp0);
			push(temp3);
		}
	};
	add splitjoin{
		split duplicate;
		add IAFID();		
		add pipeline{
			add makeFeatureListPairs();
			add ransac();
			add featureListPair->imageAndFeatures filter{
				featureListPair fLP;
				imageAndFeatures iAF1;			
				imageAndFeatures iAF2;			

				work pop 1 push 2{
					fLP = pop();
					println("Homography");
					println(fLP.bestF[0][0] + "		" + fLP.bestF[0][1] + "		" + fLP.bestF[0][2]);
					println(fLP.bestF[1][0] + "		" + fLP.bestF[1][1] + "		" + fLP.bestF[1][2]);
					println(fLP.bestF[2][0] + "		" + fLP.bestF[2][1] + "		" + fLP.bestF[2][2]);
					iAF1.myBest = fLP.x1;
					iAF2.myBest = fLP.x2;
					push(iAF1);
					push(iAF2);					
				}
			
			}
		}
		join roundrobin(2,2);
	};
	add imageAndFeatures->imageAndFeatures filter {
		imageAndFeatures A;
		imageAndFeatures B;
		imageAndFeatures C;
		imageAndFeatures D;
		work pop 4 push 2 {
		
			A = pop();
			B = pop();
			C = pop();
			D = pop();
			A.myBest = C.myBest;
			B.myBest = D.myBest;
			push(A);
			push(B);
			
		}
		
	}
	
	add plotFeatures(patchsize);	
		
	//  finishing work 
	add backToJustMatrices();
	add unmakeMatrices();
	add YIQ2RGB();
	add fileWrite();
	//add FileWriter<int>("1out.bin");
}

imageAndFeatures->imageAndFeatures filter IAFID(){
	work pop 1 push 1{
		push(pop());
	}
}

featureListPair->featureListPair filter FLPID(){
	work pop 1 push 1{

		push(pop());
	}
}

/*~~~~~~~~~~~~~~ 
~~~~fileRead~~~~
~~~~~~~~~~~~~~*/

void->int splitjoin fileRead()
{	
	split roundrobin(0);
	for(int i=1; i<=numImages; i++)
	{ 	 
		add FileReader<int>("bin/" + i + "b.bin");
	}
	join roundrobin(imageWidth*imageHeight*3);
}

/*~~~~~~~~~~~~~~~
~~~~fileWrite~~~~
~~~~~~~~~~~~~~~*/

int->void splitjoin fileWrite()
{
	split roundrobin(imageWidth*imageHeight*3);
	for(int i=1; i<=numImages; i++)
	{  
		add FileWriter<int>(i + "out.bin");
	}
	join roundrobin(0);	
}


/*~~~~~~~~~~~~~~~~~~~~~~~~
~~~~backToJustMatrices~~~~
~~~~~~~~~~~~~~~~~~~~~~~~*/


imageAndFeatures->float[320][240] filter backToJustMatrices(){
	imageAndFeatures tempIAndF;
	work pop 1 push 3
	{
		tempIAndF = pop();
		push(tempIAndF.yImage);
		push(tempIAndF.iImage);
		push(tempIAndF.qImage);
	}	
	
}

/*~~~~~~~~~~~~~
~~~~RGB2YIQ~~~~
~~~~~~~~~~~~~*/

/*
This takes in a stream of ints from, say, a .bin file, that come as R,G,and B values for each pixel.
This converts those values to YIQ values and pushes them, 3 at a time, into a struct that is easier
to deal with.
*/

int->float filter RGB2YIQ()
{ 	
	work pop 3 peek 3 push 3
	{	
		push(peek(0) * 0.299 + peek(1) * 0.587 + peek(2) * 0.114);
		push(peek(0) * 0.596 - peek(1) * 0.275 - peek(2) * 0.321);
		push(peek(0) * 0.212 - peek(1) * 0.523 + peek(2) * 0.311);
		pop();pop();pop();
	}
}


/*~~~~~~~~~~~~~
~~~~YIQ2RGB~~~~
~~~~~~~~~~~~~*/

/*
This takes in a stream of structs, with each struct having the values y,i,and q, of a pixel 
in the original image, and converts those to rgb values, and then pushes those values
individually into the stream, effectively performing the inverse process of the 
rgb2yiq function.
*/

float->int filter YIQ2RGB()
{ 	
	int temp1;
	int temp2;
	int temp3;
	work pop 3 peek 3 push 3
	{	
		temp1 = (int)(peek(0) + peek(1)*0.956 + peek(2)*0.621);
		temp2 = (int)(peek(0) - peek(1)*0.272 - peek(2)*0.647);
		temp3 = (int)(peek(0) - peek(1)*1.105 + peek(2)*1.702);
		if(temp1<0) { temp1 = 0; }
		if(temp2<0) { temp2 = 0; }
		if(temp3<0) { temp3 = 0; }
		push(temp1);
		push(temp2);
		push(temp3);
		pop();pop();pop();

	}
}

/*~~~~~~~~~~~~~~~~~~
~~~~makeMatrices~~~~
~~~~~~~~~~~~~~~~~~*/
/*gets an incoming stream of floats, in the order y,i,q, and puts all
of them into 3 matrices corresponding to the y, i, and q values*/

float->float[320][240] filter makeMatrices()
{
	float[320][240] yMatrix;
	float[320][240] iMatrix;
	float[320][240] qMatrix;
	
    work pop imageHeight*imageWidth*3 push 3 {
	for(int i = 0; i < imageHeight; i++){
		  for(int  j = 0; j < imageWidth; j++){
		   	yMatrix[j][i] = pop();
			iMatrix[j][i] = pop();
			qMatrix[j][i] = pop();
		  }
	}
	//println("before matrix push");
	push(yMatrix);
	push(iMatrix);
	push(qMatrix);
	//println("after matrix push");
    }
}

/*~~~~~~~~~~~~~~~~~~~~
~~~~unmakeMatrices~~~~
~~~~~~~~~~~~~~~~~~~~*/

/*gets 3 incoming matrices of and converts them to a stream of y,i,q, floats*/

/*this inverts the action of the makeMatrices filter*/

float[320][240]->float filter unmakeMatrices()
{	
	float[320][240] yMatrix;
	float[320][240] iMatrix;
	float[320][240] qMatrix;
	work pop 3 push imageHeight*imageWidth*3 
	{
		yMatrix = pop();
		iMatrix = pop();
		qMatrix = pop();
		//println("before unmatrix push");
		 for(int i = 0; i < imageHeight; i++){
		  for(int  j = 0; j < imageWidth; j++){
			    	push(yMatrix[j][i]);
					push(iMatrix[j][i]);
					push(qMatrix[j][i]);
			
		  }
		  }
		//println("after unmatrix pushes");
	}
}

imageAndFeatures->imageAndFeatures filter plotFeatures(int patchsize)
{
	/* This filter takes in a image and list of coordinates
	 * and patchsize and returns the same thing but with the image
	 * highlighted at those coordinates with blue boxes of size patchsize
	 */
	float[320][240] yMatrix;
	float[320][240] iMatrix;
	float[320][240] qMatrix;
	bestFeatures[60]   best;
	imageAndFeatures myImgAndFeat;
	int r;
	
	work pop 1 push 1
	{
		
		myImgAndFeat = pop();
		
		yMatrix = myImgAndFeat.yImage;
		iMatrix = myImgAndFeat.iImage;
		qMatrix = myImgAndFeat.qImage;
		
		best = myImgAndFeat.myBest;
		
		r= (patchsize-1)/2;
		
		for(int k=0; k <iters; k++)
		{
		 if(best[k].val!=0){	// correlation algorithm
								// effect taken into account
								// here
			for(int i=best[k].x-r; i<=best[k].x+r; i++)
			{
				yMatrix[i][best[k].y-r] = 255*0.114;
				iMatrix[i][best[k].y-r] = 255*-0.322;
				qMatrix[i][best[k].y-r] = 255*0.311;
			}
			for(int j=best[k].y-r+1; j<=best[k].y+r; j++)
			{
				yMatrix[best[k].x-r][j] = 255*0.114;
				iMatrix[best[k].x-r][j] = 255*-0.322;
				qMatrix[best[k].x-r][j] = 255*0.311;
				for(int i=best[k].x-r+1; i<=best[k].x+r; i++)
				{	
					yMatrix[i][j] = yMatrix[i][j]*k/iters;
					iMatrix[i][j] = iMatrix[i][j]*k/iters;
					qMatrix[i][j] = qMatrix[i][j]*k/iters;
				}
				yMatrix[best[k].x+r][j] = 255*0.114;
				iMatrix[best[k].x+r][j] = 255*-0.322;
				qMatrix[best[k].x+r][j] = 255*0.311;		
			} 
			
			for(int i=best[k].x-r; i<=best[k].x+r; i++)
			{
				yMatrix[i][best[k].y+r] = 255*0.114;
				iMatrix[i][best[k].y+r]= 255*-0.322;
				qMatrix[i][best[k].y+r] = 255*0.311;
			}
		 }
		}

		myImgAndFeat.yImage = yMatrix;
		myImgAndFeat.iImage = iMatrix;
		myImgAndFeat.qImage = qMatrix;
		push(myImgAndFeat);
		println("plotFeatures completed...");
	    
	}
}

imageAndFeatures->featureListPair filter makeFeatureListPairs(){
	
	imageAndFeatures temp1;
	imageAndFeatures temp2;
	featureListPair newGuy;
	int j;
	boolean zeroIndexSet;
	work pop 2 push 1{
		
		zeroIndexSet = false;
		
		temp1 = pop();
		temp2 = pop();
		
		newGuy.x1 = temp1.myBest;
		newGuy.x2 = temp2.myBest;
		
		//set all z values to 1 and set how many features were 'good' but marking the first point where
		//we have bad values
		
		//first though, rearrange the features so that all zeroed-out, trivial features, are pushed to the end of the 
		//array
		//println("i" + "\t" + "x1[i].x" + "\t" + "x1[i].y" + "\t" + "x2[i].x" + "\t" + "x2[i].y" + "\t" +"x1.val" + "\t" + "x2.val");
		for(int i = 0; i<iters; i++){
			
			if(newGuy.x1[i].val==0&&!zeroIndexSet){
				j = i;
				while(j<iters && newGuy.x1[j].val==0){
				j++;//if(newGuy.x1[i].x!=0 || newGuy.x1[i].y && newGuy.x1[i].x==0)
				}

				
				if(j!=iters && newGuy.x1[j].val!=0){
					
				newGuy.x1[i] 		= temp1.myBest[j];
				newGuy.x2[i] 		= temp2.myBest[j];
				newGuy.x1[j] 		= temp1.myBest[i];
				newGuy.x2[j] 		= temp2.myBest[i];
				
				temp1.myBest[i] 		= newGuy.x1[i];
				temp2.myBest[i]			= newGuy.x2[i];		
				temp1.myBest[j] 		= newGuy.x1[j];
				temp2.myBest[j]			= newGuy.x2[j];		
				
				}
			}
			if(j==iters && !zeroIndexSet) {
				newGuy.firstZeroIndex = i; 
				//println("firstZeroIndex is " + newGuy.firstZeroIndex); 
				zeroIndexSet = true;
			}
			
			newGuy.x1[i].z = 1;
			newGuy.x2[i].z = 1;
			
			//println("\t" + newGuy.x1[i].x + "\t" + newGuy.x1[i].y + "\t" + newGuy.x2[i].x + "\t" + newGuy.x2[i].y + "\t" + newGuy.x1[i].val + "\t" + newGuy.x2[i].val);

		}
		//println("here lies x1 and x2");
		/*for(int i = 0; i< newGuy.firstZeroIndex; i++){
					println(newGuy.x1[i].x);
					println(newGuy.x1[i].y);
					println(newGuy.x1[i].z);
		}
		for(int i = 0; i< newGuy.firstZeroIndex; i++){
					println(newGuy.x2[i].x);
					println(newGuy.x2[i].y);
					println(newGuy.x2[i].z);
		}*/
		println("firstZeroIndex = " + newGuy.firstZeroIndex);
		push(newGuy);
		
	}
}