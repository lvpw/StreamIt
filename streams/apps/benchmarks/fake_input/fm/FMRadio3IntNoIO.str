/*
 *  Copyright 2001 Massachusetts Institute of Technology
 *
 *  Permission to use, copy, modify, distribute, and sell this software and its
 *  documentation for any purpose is hereby granted without fee, provided that
 *  the above copyright notice appear in all copies and that both that
 *  copyright notice and this permission notice appear in supporting
 *  documentation, and that the name of M.I.T. not be used in advertising or
 *  publicity pertaining to distribution of the software without specific,
 *  written prior permission.  M.I.T. makes no representations about the
 *  suitability of this software for any purpose.  It is provided "as is"
 *  without express or implied warranty.
 */

int->int pipeline BandPassFilter (int rate, int low, int high, int taps) {
  add BPFCore(rate, low, high, taps);
  add Subtracter();
}
int->int splitjoin BPFCore (int rate, int low, int high, int taps) {
  split duplicate;
  add LowPassFilter(rate, low, taps, 0);
  add LowPassFilter(rate, high, taps, 0);
  join roundrobin;
}
int->int filter Subtracter {
  work pop 2 push 1 {
    push(peek(1) - peek(0));
    pop(); pop();
  }
}

int->int pipeline Equalizer(int rate, int bands, int[bands] cutoffs,
                                int[bands] gains, int taps) {
  add EqSplit(rate, bands, cutoffs, gains, taps);
  add int->int filter {
    work pop bands-1 push 1 {
      int sum = 0;
      for (int i = 0; i < bands-1; i++)
        sum += pop();
      push(sum);
    }
  };
}
int->int splitjoin EqSplit(int rate, int bands, int[bands] cutoffs,
                               int[bands] gains, int taps) {
  split duplicate;
  for (int i = 1; i < bands; i++)
    add pipeline {
      add BandPassFilter(rate, cutoffs[i-1], cutoffs[i], taps);
      add int->int filter {
        work pop 1 push 1 { push(pop() * gains[i]); }
      };
    };
  join roundrobin;
}

int->int filter LowPassFilter(int rate, int cutoff, int taps, int decimation) {
  int[taps] coeff;
  init {
    int i;
    int m = taps - 1;
    int w = (int)(2 * pi * cutoff / rate);
    for (i = 0; i < taps; i++) {
      if (i - m/2 == 0)
	  coeff[i] = (int)(w/pi);
      else
	  coeff[i] = (int)(sin(w*(i-m/2)) / pi / (i-m/2) *
			   (3 - 1 * cos(2*pi*i/m)));
    }
  }
  work pop 1+decimation push 1 peek taps {
    int sum = 0;
    for (int i = 0; i < taps; i++)
      sum += peek(i) * coeff[i];
    push(sum);
    for (int i=0; i<decimation; i++)
	pop();
    pop();
  }
}

void->int filter LowPassFilterSource(int rate, int cutoff, int taps, int decimation) {
  int[taps] coeff;
  init {
    int i;
    int m = taps - 1;
    int w = (int)(2 * pi * cutoff / rate);
    for (i = 0; i < taps; i++) {
      if (i - m/2 == 0)
	  coeff[i] = (int)(w/pi);
      else
	  coeff[i] = (int)(sin(w*(i-m/2)) / pi / (i-m/2) *
			   (4 - 2 * cos(2*pi*i/m)));
    }
  }
	
  int fake_peek(int f) {
      return 1;
      
  }

  void fake_pop(){}  

  work push 1 {
    int sum = 0;
    for (int i = 0; i < taps; i++)
      sum += fake_peek(i) * coeff[i];
    push(sum);
    for (int i=0; i<decimation; i++)
	fake_pop();
    fake_pop();
  }
}


int->int filter FMDemodulator(int sampRate, int max, int bandwidth) {
  int mGain;

  init {
      mGain = (int)(max*(sampRate/(bandwidth*pi)));
  }

  work push 1 pop 1 peek 2 {
    int temp = 0;
    //may have to switch to complex?
    temp = (int)(peek(0) * peek(1));
    //if using complex, use atan2
    temp = (int)(mGain * atan(temp));
	
    pop();
    push(temp);
  }
}


void->int filter IntOneSource {

  work push 1 pop 0 {
    push(1);
  }
}


int->void filter IntPrinter {
  work push 0 pop 1 {
    println(pop());
  }
}

void->int pipeline FMRadioCore {
    int samplingRate = 250000000; // 250 MHz sampling rate is sensible
    int cutoffFrequency = 108000000; //guess... doesn't FM freq max at 108 Mhz? 
    int numberOfTaps = 64;
    int maxAmplitude = 27000;
    int bandwidth = 10000;
    
    // determine where equalizer cuts.  Note that <eqBands> is the
    // number of CUTS; there are <eqBands>-1 bands, with parameters
    // held in slots 1..<eqBands> of associated arrays.
    int eqBands = 9;
    int[eqBands] eqCutoff;
    int[eqBands] eqGain;
    int low = 55;
    int high = 1760;

    for (int i=0; i<eqBands; i++) {
	// have exponentially spaced cutoffs
	eqCutoff[i] = (int)exp(i*(log(high)-log(low))/(eqBands-1) + log(low));
    }

    // first gain doesn't really correspond to a band
    eqGain[0] = 0;
    for (int i=1; i<eqBands; i++) {
	// the gain grows linearly towards the center bands
	int val = (((int)(i-1))-(((int)(eqBands-2))/2)) / 5;
	eqGain[i] = val > 0 ? 2-val : 2+val;
    }
    
    //decimate 4 samples after outputting 1
    add LowPassFilterSource(samplingRate, cutoffFrequency, numberOfTaps, 4);
    add FMDemodulator(samplingRate, maxAmplitude, bandwidth);
    add Equalizer(samplingRate, eqBands, eqCutoff, eqGain, numberOfTaps);
}

int->void filter IntSink() 
{
    work pop 1 
    {
	pop();
    }
}


void->void pipeline FMRadio3IntNoIO {

    //add IntOneSource();
    //add FileReader<int>("../input/input");
    add FMRadioCore();
    add FileWriter<int>("FMRadio3.out");
}
