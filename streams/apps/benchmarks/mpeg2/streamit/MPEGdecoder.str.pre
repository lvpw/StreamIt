/* MPEGdecoder.str.pre
 * Author: Matthew Drake (madrake@gmail.com)
 * Copyright 2005
 * MIT Computer Science and AI Laboratory, Computer Architecture Group
 */

/* Citations:
 * 1: ISO/IEC: 13818-2
 * 2: The Reference MPEG implementation
 */

#include "DCT.str"

void->void pipeline MPEGdecoder() {
  portal<InverseQuantization_AC_Coeff> UpdatePortal_quantiser_data_ac;
  portal<InverseQuantizationJoinerSubstitute> UpdatePortal_macroblock_intra;
  portal<InverseQuantization_DC_Intra_Coeff> UpdatePortal_quantiser_data_dc;
  portal<MotionPrediction> UpdatePortal_motion_vectors_lum;
  portal<MotionPrediction> UpdatePortal_motion_vectors_cr;
  portal<MotionPrediction> UpdatePortal_motion_vectors_cb;
  
  add FileReader<bit>("../input/cact_015.m2v");

  add MPEGStreamParser(UpdatePortal_quantiser_data_ac,
                       UpdatePortal_quantiser_data_dc,
                       UpdatePortal_macroblock_intra,
                       UpdatePortal_motion_vectors_lum,
                       UpdatePortal_motion_vectors_cr,
                       UpdatePortal_motion_vectors_cb
                      );

  // Note - Difference Decoding of DC actually happens in parser right now. With
  // Messaging TODO we can move it out into its own component. 

  // Can be parallelized eventually
  add ZigZagUnordering; // Assumes no alternate_scan
                        // Output of this corresponds to QF[v][u], (cite 1, P. 67)
                        // FEATURETODO

  add InverseQuantization(UpdatePortal_quantiser_data_ac,
                          UpdatePortal_quantiser_data_dc,
                          UpdatePortal_macroblock_intra);

  add Saturation(-2048, 2047); 

  add MismatchControl;      

  add iDCT8x8_ieee;

  add Saturation(-256, 255);

  // This next step reorders the pixels and upsamples as neccesary.
  // Assumes 4:2:0 to 4:4:4 upsampling requested
  // Each output channel is ordered left to right, top to bottom

  int width=352;
  int height=240;

  add int->int splitjoin {
    split roundrobin(64*4, 64, 64);
    add LuminanceChannelProcessing(width, height, UpdatePortal_motion_vectors_lum, 0);
    add ChrominanceChannelProcessing(width, height, UpdatePortal_motion_vectors_cr, 1);
    add ChrominanceChannelProcessing(width, height, UpdatePortal_motion_vectors_cb, 2);
    join roundrobin(1,1,1);  
  }

  add ColorSpaceConversion;
  add FlipVertically(352, 240); // Flip it to be correctly ordered for BMP processing
  add BMPStreamCreator;
  add FileWriter<bit>("./output.bmp");

}

int->int pipeline ColorSpaceConversion {
  add YCbCrtoRGB;
  add Saturation(0,255);
}

int->int pipeline LuminanceChannelProcessing(int width, 
                                             int height,
                                             portal<MotionPrediction> UpdatePortal_motion_vectors,
                                             int id) {
  add MacroBlockDescrambler(width);
  add BlockDescrambler(width);
  add MotionPrediction(width, height, 1, id) to UpdatePortal_motion_vectors;
}

int->int pipeline ChrominanceChannelProcessing(int width, 
                                               int height,
                                               portal<MotionPrediction> UpdatePortal_motion_vectors,
                                               int id) {
  add BlockDescrambler(width/2);
  // Assumes 4:2:0 to 4:4:4
  add MotionPrediction(width, height, 2, id) to UpdatePortal_motion_vectors;
  add ChannelUpsample(width/2, height/2);
}

// Assumes 4:2:0 data TODO
int->int filter MotionPrediction(int width, int height, int upsample_factor, int id) {
  int datasize = ((width/upsample_factor)*(height/upsample_factor));
  int[(width/upsample_factor)][(height/upsample_factor)] previous_pred_picture;
  int[(width/upsample_factor)][(height/upsample_factor)] next_pred_picture;
  int picture_coding_type;
  boolean has_previous_picture, has_next_picture;
  int[2][2][2] vector;  

  int count;
  
  init {
    count = 0;
    picture_coding_type = -1;
    has_previous_picture = false;
    has_next_picture = false;
  }
  
  work pop 64 push 64 {
    for (int i = 0; i < 64; i++) {
     push(pop());}
   /* pop datasize
       push datasize {
    if (picture_coding_type == 1) { // I-Picture
      if (has_previous_picture == false) {
        has_previous_picture = true;
        for (int x = 0; x < (width/upsample_factor); x++) {
          for (int y = 0; y < (height/upsample_factor); y++) { 
            int tempval = pop();
            previous_pred_picture[x][y] = tempval;
            push(tempval);
          }
        }
      } else if (has_next_picture == false) {
        has_next_picture = true;
        for (int x = 0; x < (width/upsample_factor); x++) {
          for (int y = 0; y < (height/upsample_factor); y++) { 
            int tempval = pop();
            next_pred_picture[x][y] = tempval;
            push(tempval);
          }
        }
      } else {
        for (int x = 0; x < (width/upsample_factor); x++) {
          for (int y = 0; y < (height/upsample_factor); y++) { 
            int tempval = pop();
            previous_pred_picture[x][y] = next_pred_picture[x][y];
            next_pred_picture[x][y] = tempval;
            push(tempval);
          }
        }
      }
      // Note - we always assume that P-pictures get sent after at least
      // one I-picture. TODO verify that this is the case.
    } else if (picture_coding_type == 2) { // P-Picture
      if (has_next_picture == false) {
        has_next_picture = true;
        for (int x = 0; x < (width/upsample_factor); x++) {
          for (int y = 0; y < (height/upsample_factor); y++) { 
            int tempval = pop();
            next_pred_picture[x][y] = tempval;
            push(tempval);
          }
        }
      } else {
        for (int x = 0; x < (width/upsample_factor); x++) {
          for (int y = 0; y < (height/upsample_factor); y++) { 
            int tempval = pop();
            previous_pred_picture[x][y] = next_pred_picture[x][y];
            next_pred_picture[x][y] = tempval;
            push(tempval);
          }
        }
      }
      // Note - B-pictures we don't store locally
    } else if (picture_coding_type == 3) { // B-Picture
      for (int x = 0; x < (width/upsample_factor); x++) {
        for (int y = 0; y < (height/upsample_factor); y++) { 
          int tempval = pop();
          push(tempval);
        }
      }
    } */
    count++;
  }
  handler setPictureType(int new_picture_coding_type) {
//    print(id + " " + count + " PictureType: " + new_picture_coding_type);
    picture_coding_type = new_picture_coding_type;
//    count = 0;
  }
  handler setMotionVectors(int[2][2][2] vectorp) {
    print(id + " getting motion vectors " + count);
    for (int r = 0; r < 2; r++) {
      for (int s = 0; s < 2; s++) {
        for (int t = 0; t < 2; t++) {
          vector[r][s][t] = vectorp[r][s][t]/upsample_factor;
        }
      }
    }
  }
}


int->int filter YCbCrtoRGB {
  // This function assumes that no sequence display extension was ever
  // encountered in the data stream, and the default colorspace transformations 
  // apply.
  // (cite 1, P. 47, Table 6-9): Refer to entry 1, which is
  // Recommendation ITU-R BT.709 for transformations.
  // If we take the matrix on the right side of those equations and compute
  // its inverse in MATLAB we get the values shown below for calculating
  // EG, EB, and ER
  // My values are centered between +/- 128, and it expects values in the 
  // 0 to 255 range, so we add first and then compute.
  // Saturation of the output is performed downstream.
  work pop 3 push 3 {
    int Y = pop() + 128;
    int Cb = pop() + 128;
    int Cr = pop() + 128; 	

    float Ey = (((float) Y) - 16)/219.0;
    float Epb = (((float) Cb)-128)/224.0;
    float Epr = (((float) Cr)-128)/224.0;
   
    float EG = 0.999813*Ey - 0.187227*Epb - 0.467983*Epr;
    float EB = 1.001856*Ey + 1.855625*Epb + 0.001005*Epr;
    float ER = 1.000001*Ey + 0.000715*Epb + 1.575164*Epr;
   
    int R = (int) round(ER*256);
    int G = (int) round(EG*256);
    int B = (int) round(EB*256);
    
    push(R);
    push(G);
    push(B);

  }
}

int->int splitjoin MacroBlockDescrambler(int width) {
  split roundrobin(64*2);
  add Identity<int>;
  add Identity<int>;
  join roundrobin(width*8);
}

int->int splitjoin BlockDescrambler(int width) {
  split roundrobin(8);
  for (int i = 0; i < 8; i++) {
    add Identity<int>;
  }
  join roundrobin(width);
}

int->int splitjoin FlipVertically(int width, int height) {
  split roundrobin(3);
  for (int i = 0; i < width; i++) {
    add ReversePixelOrder(height*3);
  }
  join roundrobin(3); 
}

int->int filter ReversePixelOrder(int len) {
  work pop len push len {
    int[len] order;
    for (int i = 0; i < len; i++) 
      order[i] = pop();
    for (int i = len-1; i >= 0; i--)
      push(order[i]);
  }
}

int->bit filter BMPStreamCreator {
  boolean ran;

  init {
    ran = false;
  }

  work pop 1 push 1 {
    if (!ran) {
      print("Writing BMP File...");
      ran = true;
      int width = 352;
      int height = 240;
      int colordepth = 24;    

      int tempval;
      
      tempval = 0x424D; // 'BM'
 
      pushs(16, tempval);

      // File Size
      int filesize = (width*height*colordepth/8) + 54;
      intpushs(filesize);

      // Reserved, must be 0
      pushs(32,0);
  
      // Offset to image data
      tempval = 54; // Data starts 54 bytes into file
      intpushs(tempval);
      
      // Header Size
      tempval = 40; // Header is 40 bytes in size.
      intpushs(tempval);

      // Width
      intpushs(width);

      // Height
      intpushs(height);

      // # of Color Planes, 1
      shortpushs(1);
 
      // Bits per pixel
      shortpushs(24);

      // Compression Type, 0
      pushs(32,0);

      // Image Size
      int image_size = width*height*3;
      intpushs(image_size);

      // Pixels per meter x, y, # of colors, important colors
      // All rather unimportant.
      intpushs(3780);
      intpushs(3780);
      pushs(32,0);
      pushs(32,0);

      // Now the actual data
      for (int i = 0; i < width*height*3; i++) {
        int val = pop();
        pushs(8,val);
      }

      // This just makes sure all data gets flushed properly
      // Since we currently write data as integers
      pushs(32,0);
      print("Done Writing BMP File...");
    }
  }
}

// Note: We assume we are going from 4:2:0 to 4:4:4
// Otherwise this won't work.
// Check out store.c in the mpeg reference implementation
// It has a more complicated, probably more accurate
// implementation. Only implement if needed.
int->int pipeline ChannelUpsample(int sourcewidth, int sourceheight) {
  add splitjoin {
    split roundrobin(1);
    for (int i = 0; i < sourcewidth; i++) {
      add ChannelUpsample_1D(sourceheight, 0.75, 0.25);
    }
    join roundrobin(1);
  }
  add splitjoin {
    split roundrobin(sourcewidth);
    for (int i = 0; i < sourceheight; i++) {
      add ChannelUpsample_1D(sourcewidth, 0.5, 0.5);
    }
    join roundrobin(sourcewidth*2);
  }
}

int->int filter ChannelUpsample_1D(int sourcelen, float weight1, float weight2) {
  work pop sourcelen push sourcelen*2 {
    int val1 = 0, val2 = 0;
    val1 = pop();
    push(val1);
    for (int i = 0; i < sourcelen-1; i++) {
      val2 = pop();
      float outval = (weight1*val1+weight2*val2);
      push((int) round(outval));
      outval = (weight2*val1+weight1*val2);
      push((int) round(outval));
      val1 = val2;
    }
    push(val2);
  }    
}

int->int pipeline InverseQuantization(  
         portal<InverseQuantization_AC_Coeff> UpdatePortal_quantiser_data_ac,
         portal<InverseQuantization_DC_Intra_Coeff> UpdatePortal_quantiser_data_dc,
         portal<InverseQuantizationJoinerSubstitute> UpdatePortal_macroblock_intra) {

  // NOTE - This is a case for a programmable splitjoin or some such 
  // right now we have macroblock_intra passed along with the data but it
  // really should get passed as a message and used to reprogram a splitjoin
  // or some such.
  // The handling of the intra DC coefficient is described on (cite 1, P. 69)
  add int->int splitjoin {
    split duplicate;
    // Intra Coded Macroblocks
    add int->int splitjoin {
      split roundrobin(1, 63); 
      add InverseQuantization_DC_Intra_Coeff to UpdatePortal_quantiser_data_dc; // (cite 1, P.69)
      add InverseQuantization_AC_Coeff(1) to UpdatePortal_quantiser_data_ac;
      join roundrobin(1, 63); 
    }
    // Non Intra Coded Macroblocks
    add InverseQuantization_AC_Coeff(0) to UpdatePortal_quantiser_data_ac;
    join roundrobin(64, 64);  
  }
  
  // Selects which stream - FEATURETODO eventually programmable splitjoin and only one of the two
  // above branches gets taken instead of both.
  
  add InverseQuantizationJoinerSubstitute() to UpdatePortal_macroblock_intra;
}

int->int filter InverseQuantizationJoinerSubstitute {
  int macroblock_intra;
  
  init {
    macroblock_intra = -1;
  }
  
  handler setMacroblockIntra(int new_macroblock_intra) {
    macroblock_intra = new_macroblock_intra;
  }
  
  work pop (128) push 64 {
    if (macroblock_intra == -1) {
      print("  Error: macroblock_intra should not be -1, should have recieved update message");
    } else if (macroblock_intra == 1) {
      // It was Intra Coded
      for (int i = 0; i < 64; i++) {
        push(pop());
      }
      for (int i = 0; i < 64; i++) {
        pop();
      }
    } else {
      // It was Non Intra Coded
      for (int i = 0; i < 64; i++) {
        pop();
      }
      for (int i = 0; i < 64; i++) {
        push(pop());
      }
    }
  }
}


// (cite 1, P. 69)
int->int filter InverseQuantization_DC_Intra_Coeff() {
  int[4] intra_dc_mult;
  int intra_dc_precision;

  init {
    intra_dc_mult[0] = 8;
    intra_dc_mult[1] = 4;
    intra_dc_mult[2] = 2;
    intra_dc_mult[3] = 1;
    intra_dc_precision = -1; // In case no message is received, error
  }

  work pop 1 push 1 {
    push(intra_dc_mult[intra_dc_precision] * pop());
  }

  handler setIntraDCPrecision(int new_intra_dc_precision) {
    intra_dc_precision = new_intra_dc_precision;
  }
}

// Assumes 4:2:0 data
// (cite 1, P.69)
int->int filter InverseQuantization_AC_Coeff(int macroblock_intra) {
  // intra = 1: This is dequantizing the non-DC part of an intra coded block
  // intra = 0: This is dequantizing the DC and AC part of a non-intra coded block

  // These are all assigned by messages and MUST be assigned before the first 
  // call to work()
  int quantiser_scale_code;
  int q_scale_type;
  int[64] intra_quantiser_matrix;
  int[64] non_intra_quantiser_matrix;

  int[2][32] quantiser_scale =
    // Note that quantiser_scale[x][0] is a Forbidden Value
    {{ 0,  2,  4,  6,  8, 10, 12, 14,
      16, 18, 20, 22, 24, 26, 28, 30,
      32, 34, 36, 38, 40, 42, 44, 46,
      48, 50, 52, 54, 56, 58, 60, 62},
     { 0,  1,  2,  3,  4,  5,  6,  7,
       8, 10, 12, 14, 16, 18, 20, 22,
      24, 28, 32, 36, 40, 44, 48, 52, 
      56, 64, 72, 80, 88, 96, 104, 112}};
  // (cite 1, P.70 Table 7-6)

  init {
    quantiser_scale_code = 0; // Guarantees that this throws an error
                              // if it doesn't get a quantiser message
                              // before getting some data.
    q_scale_type = -1; // Another nice error if no message received in time.
  }

  work pop (64-macroblock_intra) push (64-macroblock_intra) { 
    if (quantiser_scale_code == 0)
      print("Error - quantiser_scale_code not allowed to be 0 " + macroblock_intra);
    for (int i = macroblock_intra; i < 64; i++) {
      int QF = pop();
      // (cite 1, P. 71)
      int k = 0;
      if (macroblock_intra == 1) {
        k = 0;
      } else {
        // TODO - I think I'm interpreting this part of the spec correctly, check though.
        if (QF >= 0)
          k = 1;
        else
          k = -1;
      }
      int W = 0;
      if (macroblock_intra == 1) {
        W = intra_quantiser_matrix[i];
      } else {
        W = non_intra_quantiser_matrix[i];
      }
      int F = (2 * QF + k) * W * 
              quantiser_scale[q_scale_type][quantiser_scale_code] / 32;
      push(F);
    }
  }

  handler setQuantiserScaleCode(int new_quantiser_scale_code) {
    quantiser_scale_code = new_quantiser_scale_code;
  }

  handler setQuantiserMatrices(int[64] new_intra_quantiser_matrix, 
                               int[64] new_non_intra_quantiser_matrix) {
    for (int i = 0; i < 64; i++) {
      intra_quantiser_matrix[i] = new_intra_quantiser_matrix[i];
      non_intra_quantiser_matrix[i] = new_non_intra_quantiser_matrix[i];
    }
  }

  handler setQScaleType(int new_q_scale_type) {
    q_scale_type = new_q_scale_type;
  }
} 

// (cite 1, P. 71)
int->int filter Saturation(int min, int max) {
  work pop 1 push 1 {
    int val = pop();
    if (val > max) {
      push(max); 
    } else if (val < min) {
      push(min);
    } else {
      push(val);
    }
  }
}

// (cite 1, P.71)
int->int filter MismatchControl() {
  work pop 64 push 64 {
    int sum, val;
    sum = 0;
    for (int i = 0; i < 63; i++) {
      val = pop();
      sum += val;
      push(val);
    }
    val = pop();
    sum += val;
    if ((sum & 0x1) == 0x1) {
      push(val);
    } else {
      if ((val * 0x1) == 0x1) {
        push(val-1);
      } else {
        push(val+1);
      }
    }
  }
}

int->bit filter IntStream2BitStream() {
  work pop 1 push 32 {
    int some_int = pop();
    int b0 = ((some_int >> 24) & 0x000000FF);
    int b1 = (some_int & 0x00FF0000) >> 8;
    int b2 = (some_int & 0x0000FF00) << 8;
    int b3 = (some_int & 0x000000FF) << 24;
    some_int = (b0 | b1 | b2 | b3);
    pushs(32,some_int);
  }
}

bit->int filter BitStream2IntStream() {
  work pop 32 push 1 {
    int some_int;
    pops(32,some_int);
    int b0 = ((some_int >> 24) & 0x000000FF);
    int b1 = (some_int & 0x00FF0000) >> 8;
    int b2 = (some_int & 0x0000FF00) << 8;
    int b3 = (some_int & 0x000000FF) << 24;
    some_int = (b0 | b1 | b2 | b3);
    push(some_int);
  }
}


/* Input: A sequence of 64 integers in a diagonalized order.
   Output: A sequence of 64 integers representing an 8x8 block. */
int->int filter ZigZagUnordering {
  int[64] Ordering = {00, 01, 05, 06, 14, 15, 27, 28,
                      02, 04, 07, 13, 16, 26, 29, 42,
					            03, 08, 12, 17, 25, 30, 41, 43,
					            09, 11, 18, 24, 31, 40, 44, 53,
					            10, 19, 23, 32, 39, 45, 52, 54,
					            20, 22, 33, 38, 46, 51, 55, 60,
					            21, 34, 37, 47, 50, 56, 59, 61,
					            35, 36, 48, 49, 57, 58, 62, 63};
  work pop 64 push 64 {
    for (int i = 0; i < 64; i++)
      push(peek(Ordering[i]));
    for (int i = 0; i < 64; i++)  
      pop();
  }
}

struct vlc_table_entry {
  int code;
  int len; // Length of code in bits
  int value;
}

struct vlc_dct_table_entry { // See P. 135
  // We code a special vlc table type for the DCT coefficients because they are
  // so important.
  int code;
  int len; // Length of code in bits
  int run;
  int level;
}

/* Input: The video bitstream
   Output: The QFS quantized coefficient data
*/
bit->int filter MPEGStreamParser(
                        portal<InverseQuantization_AC_Coeff> UpdatePortal_quantiser_data_ac,
                        portal<InverseQuantization_DC_Intra_Coeff> UpdatePortal_quantiser_data_dc,
                        portal<InverseQuantizationJoinerSubstitute> UpdatePortal_macroblock_intra,
                        portal<MotionPrediction> UpdatePortal_motion_vectors_lum,
                        portal<MotionPrediction> UpdatePortal_motion_vectors_cr,
                        portal<MotionPrediction> UpdatePortal_motion_vectors_cb
                        ) {
  // FEATURETODO
  // When phases can take parameters, get rid of this definition and
  // uncomment the definition in the filter work function, and change
  // the phase PushMacroblock() to use the parameter. 
  int[64] QFS;

  boolean ran;
  int count;

  vlc_table_entry[33] const_macroblock_address_inc;  // Table B1
  int const_macroblock_address_inc_len = 33;

  vlc_table_entry[2] const_macroblock_type_Ipictures; // Table B2
  int const_macroblock_type_Ipictures_len = 2;
 
  vlc_table_entry[7] const_macroblock_type_Ppictures; // Table B3
  int const_macroblock_type_Ppictures_len = 7;

  vlc_table_entry[11] const_macroblock_type_Bpictures; // Table B4
  int const_macroblock_type_Bpictures_len = 11;

  vlc_table_entry[64] const_coded_block_patterns; // Table B9
  int const_coded_block_patterns_len = 64;

  vlc_table_entry[33] const_motion_code; // Table B10
  int const_motion_code_len = 33;

  vlc_table_entry[12] const_dct_dc_size_luminance; // Table B12
  int const_dct_dc_size_luminance_len = 12;

  vlc_table_entry[12] const_dct_dc_size_chrominance; // Table B13
  int const_dct_dc_size_chrominance_len = 12;

  vlc_dct_table_entry[114] const_dct_coefficients_table_zero; // Table B14, assuming 
  int const_dct_coefficients_table_zero_len = 112; // intra_vlc_format == 1, macroblock_intra == 0  

  init {
    ran = false;
    count = 0;
    // Initialize Constants

    const_coded_block_patterns[0].code = 0b111;
    const_coded_block_patterns[0].len = 3;
    const_coded_block_patterns[0].value = 60;
    const_coded_block_patterns[1].code = 0b1101;
    const_coded_block_patterns[1].len = 4;
    const_coded_block_patterns[1].value = 4;
    const_coded_block_patterns[2].code = 0b1100;
    const_coded_block_patterns[2].len = 4;
    const_coded_block_patterns[2].value = 8;
    const_coded_block_patterns[3].code = 0b1011;
    const_coded_block_patterns[3].len = 4;
    const_coded_block_patterns[3].value = 16;
    const_coded_block_patterns[4].code = 0b1010;
    const_coded_block_patterns[4].len = 4;
    const_coded_block_patterns[4].value = 32;
    const_coded_block_patterns[5].code = 0b10011;
    const_coded_block_patterns[5].len = 5;
    const_coded_block_patterns[5].value = 12;
    const_coded_block_patterns[6].code = 0b10010;
    const_coded_block_patterns[6].len = 5;
    const_coded_block_patterns[6].value = 48;
    const_coded_block_patterns[7].code = 0b10001;
    const_coded_block_patterns[7].len = 5;
    const_coded_block_patterns[7].value = 20;
    const_coded_block_patterns[8].code = 0b10000;
    const_coded_block_patterns[8].len = 5;
    const_coded_block_patterns[8].value = 40;
    const_coded_block_patterns[9].code = 0b01111;
    const_coded_block_patterns[9].len = 5;
    const_coded_block_patterns[9].value = 28;
    const_coded_block_patterns[10].code = 0b01110;
    const_coded_block_patterns[10].len = 5;
    const_coded_block_patterns[10].value = 44;
    const_coded_block_patterns[11].code = 0b01101;
    const_coded_block_patterns[11].len = 5;
    const_coded_block_patterns[11].value = 52;
    const_coded_block_patterns[12].code = 0b01100;
    const_coded_block_patterns[12].len = 5;
    const_coded_block_patterns[12].value = 56;
    const_coded_block_patterns[13].code = 0b01011;
    const_coded_block_patterns[13].len = 5;
    const_coded_block_patterns[13].value = 1;
    const_coded_block_patterns[14].code = 0b01010;
    const_coded_block_patterns[14].len = 5;
    const_coded_block_patterns[14].value = 61;
    const_coded_block_patterns[15].code = 0b01001;
    const_coded_block_patterns[15].len = 5;
    const_coded_block_patterns[15].value = 2;
    const_coded_block_patterns[16].code = 0b01000;
    const_coded_block_patterns[16].len = 5;
    const_coded_block_patterns[16].value = 62;
    const_coded_block_patterns[17].code = 0b001111;
    const_coded_block_patterns[17].len = 6;
    const_coded_block_patterns[17].value = 24;
    const_coded_block_patterns[18].code = 0b001110;
    const_coded_block_patterns[18].len = 6;
    const_coded_block_patterns[18].value = 36;
    const_coded_block_patterns[19].code = 0b001101;
    const_coded_block_patterns[19].len = 6;
    const_coded_block_patterns[19].value = 3;
    const_coded_block_patterns[20].code = 0b001100;
    const_coded_block_patterns[20].len = 6;
    const_coded_block_patterns[20].value = 63;
    const_coded_block_patterns[21].code = 0b0010111;
    const_coded_block_patterns[21].len = 7;
    const_coded_block_patterns[21].value = 5;
    const_coded_block_patterns[22].code = 0b0010110;
    const_coded_block_patterns[22].len = 7;
    const_coded_block_patterns[22].value = 9;
    const_coded_block_patterns[23].code = 0b0010101;
    const_coded_block_patterns[23].len = 7;
    const_coded_block_patterns[23].value = 17;
    const_coded_block_patterns[24].code = 0b0010100;
    const_coded_block_patterns[24].len = 7;
    const_coded_block_patterns[24].value = 33;
    const_coded_block_patterns[25].code = 0b0010011;
    const_coded_block_patterns[25].len = 7;
    const_coded_block_patterns[25].value = 6;
    const_coded_block_patterns[26].code = 0b0010010;
    const_coded_block_patterns[26].len = 7;
    const_coded_block_patterns[26].value = 10;
    const_coded_block_patterns[27].code = 0b0010001;
    const_coded_block_patterns[27].len = 7;
    const_coded_block_patterns[27].value = 18;
    const_coded_block_patterns[28].code = 0b0010000;
    const_coded_block_patterns[28].len = 7;
    const_coded_block_patterns[28].value = 34;
    const_coded_block_patterns[29].code = 0b00011111;
    const_coded_block_patterns[29].len = 8;
    const_coded_block_patterns[29].value = 7;
    const_coded_block_patterns[30].code = 0b00011110;
    const_coded_block_patterns[30].len = 8;
    const_coded_block_patterns[30].value = 11;
    const_coded_block_patterns[31].code = 0b00011101;
    const_coded_block_patterns[31].len = 8;
    const_coded_block_patterns[31].value = 19;
    const_coded_block_patterns[32].code = 0b00011100;
    const_coded_block_patterns[32].len = 8;
    const_coded_block_patterns[32].value = 35;
    const_coded_block_patterns[33].code = 0b00011011;
    const_coded_block_patterns[33].len = 8;
    const_coded_block_patterns[33].value = 13;
    const_coded_block_patterns[34].code = 0b00011010;
    const_coded_block_patterns[34].len = 8;
    const_coded_block_patterns[34].value = 49;
    const_coded_block_patterns[35].code = 0b00011001;
    const_coded_block_patterns[35].len = 8;
    const_coded_block_patterns[35].value = 21;
    const_coded_block_patterns[36].code = 0b00011000;
    const_coded_block_patterns[36].len = 8;
    const_coded_block_patterns[36].value = 41;
    const_coded_block_patterns[37].code = 0b00010111;
    const_coded_block_patterns[37].len = 8;
    const_coded_block_patterns[37].value = 14;
    const_coded_block_patterns[38].code = 0b00010110;
    const_coded_block_patterns[38].len = 8;
    const_coded_block_patterns[38].value = 50;
    const_coded_block_patterns[39].code = 0b00010101;
    const_coded_block_patterns[39].len = 8;
    const_coded_block_patterns[39].value = 22;
    const_coded_block_patterns[40].code = 0b00010100;
    const_coded_block_patterns[40].len = 8;
    const_coded_block_patterns[40].value = 42;
    const_coded_block_patterns[41].code = 0b00010011;
    const_coded_block_patterns[41].len = 8;
    const_coded_block_patterns[41].value = 15;
    const_coded_block_patterns[42].code = 0b00010010;
    const_coded_block_patterns[42].len = 8;
    const_coded_block_patterns[42].value = 51;
    const_coded_block_patterns[43].code = 0b00010001;
    const_coded_block_patterns[43].len = 8;
    const_coded_block_patterns[43].value = 23;
    const_coded_block_patterns[44].code = 0b00010000;
    const_coded_block_patterns[44].len = 8;
    const_coded_block_patterns[44].value = 43;
    const_coded_block_patterns[45].code = 0b00001111;
    const_coded_block_patterns[45].len = 8;
    const_coded_block_patterns[45].value = 25;
    const_coded_block_patterns[46].code = 0b00001110;
    const_coded_block_patterns[46].len = 8;
    const_coded_block_patterns[46].value = 37;
    const_coded_block_patterns[47].code = 0b00001101;
    const_coded_block_patterns[47].len = 8;
    const_coded_block_patterns[47].value = 26;
    const_coded_block_patterns[48].code = 0b00001100;
    const_coded_block_patterns[48].len = 8;
    const_coded_block_patterns[48].value = 38;
    const_coded_block_patterns[49].code = 0b00001011;
    const_coded_block_patterns[49].len = 8;
    const_coded_block_patterns[49].value = 29;
    const_coded_block_patterns[50].code = 0b00001010;
    const_coded_block_patterns[50].len = 8;
    const_coded_block_patterns[50].value = 45;
    const_coded_block_patterns[51].code = 0b00001001;
    const_coded_block_patterns[51].len = 8;
    const_coded_block_patterns[51].value = 53;
    const_coded_block_patterns[52].code = 0b00001000;
    const_coded_block_patterns[52].len = 8;
    const_coded_block_patterns[52].value = 57;
    const_coded_block_patterns[53].code = 0b00000111;
    const_coded_block_patterns[53].len = 8;
    const_coded_block_patterns[53].value = 30;
    const_coded_block_patterns[54].code = 0b00000110;
    const_coded_block_patterns[54].len = 8;
    const_coded_block_patterns[54].value = 46;
    const_coded_block_patterns[55].code = 0b00000101;
    const_coded_block_patterns[55].len = 8;
    const_coded_block_patterns[55].value = 54;
    const_coded_block_patterns[56].code = 0b00000100;
    const_coded_block_patterns[56].len = 8;
    const_coded_block_patterns[56].value = 58;
    const_coded_block_patterns[57].code = 0b000000111;
    const_coded_block_patterns[57].len = 9;
    const_coded_block_patterns[57].value = 31;
    const_coded_block_patterns[58].code = 0b000000110;
    const_coded_block_patterns[58].len = 9;
    const_coded_block_patterns[58].value = 47;
    const_coded_block_patterns[59].code = 0b000000101;
    const_coded_block_patterns[59].len = 9;
    const_coded_block_patterns[59].value = 55;
    const_coded_block_patterns[60].code = 0b000000100;
    const_coded_block_patterns[60].len = 9;
    const_coded_block_patterns[60].value = 59;
    const_coded_block_patterns[61].code = 0b000000011;
    const_coded_block_patterns[61].len = 9;
    const_coded_block_patterns[61].value = 27;
    const_coded_block_patterns[62].code = 0b000000010;
    const_coded_block_patterns[62].len = 9;
    const_coded_block_patterns[62].value = 39;
    const_coded_block_patterns[63].code = 0b000000001;
    const_coded_block_patterns[63].len = 9;
    const_coded_block_patterns[63].value = 0;

    const_motion_code[0].code = 25;
    const_motion_code[0].len = 11;
    const_motion_code[0].value = -16;
    const_motion_code[1].code = 27;
    const_motion_code[1].len = 11;
    const_motion_code[1].value = -15;
    const_motion_code[2].code = 29;
    const_motion_code[2].len = 11 ;
    const_motion_code[2].value = -14;
    const_motion_code[3].code = 31;
    const_motion_code[3].len = 11;
    const_motion_code[3].value = -13;
    const_motion_code[4].code = 33;
    const_motion_code[4].len = 11;
    const_motion_code[4].value = -12;
    const_motion_code[5].code = 35;
    const_motion_code[5].len = 11;
    const_motion_code[5].value = -11;
    const_motion_code[6].code = 19;
    const_motion_code[6].len = 10;
    const_motion_code[6].value = -10;
    const_motion_code[7].code = 21;
    const_motion_code[7].len = 10;
    const_motion_code[7].value = -9;
    const_motion_code[8].code = 23;
    const_motion_code[8].len = 10;
    const_motion_code[8].value = -8;
    const_motion_code[9].code = 7;
    const_motion_code[9].len = 8;
    const_motion_code[9].value = -7;
    const_motion_code[10].code = 9;
    const_motion_code[10].len = 8;
    const_motion_code[10].value = -6;
    const_motion_code[11].code = 11;
    const_motion_code[11].len = 8;
    const_motion_code[11].value = -5;
    const_motion_code[12].code = 7;
    const_motion_code[12].len = 7;
    const_motion_code[12].value = -4;
    const_motion_code[13].code = 3;
    const_motion_code[13].len = 5;
    const_motion_code[13].value = -3;
    const_motion_code[14].code = 3;
    const_motion_code[14].len = 4;
    const_motion_code[14].value = -2;
    const_motion_code[15].code = 3;
    const_motion_code[15].len = 3;
    const_motion_code[15].value = -1;
    const_motion_code[16].code = 1;
    const_motion_code[16].len = 1;
    const_motion_code[16].value = 0;
    const_motion_code[17].code = 2;
    const_motion_code[17].len = 3;
    const_motion_code[17].value = 1;
    const_motion_code[18].code = 2;
    const_motion_code[18].len = 4;
    const_motion_code[18].value = 2;
    const_motion_code[19].code = 2;
    const_motion_code[19].len = 5;
    const_motion_code[19].value = 3;
    const_motion_code[20].code = 6;
    const_motion_code[20].len = 7;
    const_motion_code[20].value = 4;
    const_motion_code[21].code = 10;
    const_motion_code[21].len = 8;
    const_motion_code[21].value = 5;
    const_motion_code[22].code = 8;
    const_motion_code[22].len = 8;
    const_motion_code[22].value = 6;
    const_motion_code[23].code = 6;
    const_motion_code[23].len = 8;
    const_motion_code[23].value = 7;
    const_motion_code[24].code = 22;
    const_motion_code[24].len = 10;
    const_motion_code[24].value = 8;
    const_motion_code[25].code = 20;
    const_motion_code[25].len = 10;
    const_motion_code[25].value = 9;
    const_motion_code[26].code = 18;
    const_motion_code[26].len = 10;
    const_motion_code[26].value = 10;
    const_motion_code[27].code = 34;
    const_motion_code[27].len = 11;
    const_motion_code[27].value = 11;
    const_motion_code[28].code = 32;
    const_motion_code[28].len = 11;
    const_motion_code[28].value = 12;
    const_motion_code[29].code = 30;
    const_motion_code[29].len = 11;
    const_motion_code[29].value = 13;
    const_motion_code[30].code = 28;
    const_motion_code[30].len = 11;
    const_motion_code[30].value = 14;
    const_motion_code[31].code = 26;
    const_motion_code[31].len = 11;
    const_motion_code[31].value = 15;
    const_motion_code[32].code = 24;
    const_motion_code[32].len = 11;
    const_motion_code[32].value = 16;

    const_macroblock_address_inc[0].code = 1;
    const_macroblock_address_inc[0].len = 1;
    const_macroblock_address_inc[0].value = 1;
    const_macroblock_address_inc[1].code = 3;
    const_macroblock_address_inc[1].len = 3;
    const_macroblock_address_inc[1].value = 2;
    const_macroblock_address_inc[2].code = 2;
    const_macroblock_address_inc[2].len = 3;
    const_macroblock_address_inc[2].value = 3;
    const_macroblock_address_inc[3].code = 3;
    const_macroblock_address_inc[3].len = 4;
    const_macroblock_address_inc[3].value = 4;
    const_macroblock_address_inc[4].code = 2;
    const_macroblock_address_inc[4].len = 4;
    const_macroblock_address_inc[4].value = 5;
    const_macroblock_address_inc[5].code = 3;
    const_macroblock_address_inc[5].len = 5;
    const_macroblock_address_inc[5].value = 6;
    const_macroblock_address_inc[6].code = 2;
    const_macroblock_address_inc[6].len = 5;
    const_macroblock_address_inc[6].value = 7;
    const_macroblock_address_inc[7].code = 7;
    const_macroblock_address_inc[7].len = 7;
    const_macroblock_address_inc[7].value = 8;
    const_macroblock_address_inc[8].code = 6;
    const_macroblock_address_inc[8].len = 7;
    const_macroblock_address_inc[8].value = 11;
    const_macroblock_address_inc[9].code = 11;
    const_macroblock_address_inc[9].len = 8;
    const_macroblock_address_inc[9].value = 10;
    const_macroblock_address_inc[10].code = 10;
    const_macroblock_address_inc[10].len = 8;
    const_macroblock_address_inc[10].value = 11;
    const_macroblock_address_inc[11].code = 9;
    const_macroblock_address_inc[11].len = 11;
    const_macroblock_address_inc[11].value = 12;
    const_macroblock_address_inc[12].code = 8;
    const_macroblock_address_inc[12].len = 11;
    const_macroblock_address_inc[12].value = 13;
    const_macroblock_address_inc[13].code = 7;
    const_macroblock_address_inc[13].len = 11;
    const_macroblock_address_inc[13].value = 14;
    const_macroblock_address_inc[14].code = 6;
    const_macroblock_address_inc[14].len = 11;
    const_macroblock_address_inc[14].value = 15;
    const_macroblock_address_inc[15].code = 23;
    const_macroblock_address_inc[15].len = 10;
    const_macroblock_address_inc[15].value = 16;
    const_macroblock_address_inc[16].code = 22;
    const_macroblock_address_inc[16].len = 10;
    const_macroblock_address_inc[16].value = 17;
    const_macroblock_address_inc[17].code = 21;
    const_macroblock_address_inc[17].len = 10;
    const_macroblock_address_inc[17].value = 18;
    const_macroblock_address_inc[18].code = 20;
    const_macroblock_address_inc[18].len = 10;
    const_macroblock_address_inc[18].value = 19;
    const_macroblock_address_inc[19].code = 19;
    const_macroblock_address_inc[19].len = 10;
    const_macroblock_address_inc[19].value = 20;
    const_macroblock_address_inc[20].code = 18;
    const_macroblock_address_inc[20].len = 10;
    const_macroblock_address_inc[20].value = 21;
    const_macroblock_address_inc[21].code = 35;
    const_macroblock_address_inc[21].len = 11;
    const_macroblock_address_inc[21].value = 22;
    const_macroblock_address_inc[22].code = 34;
    const_macroblock_address_inc[22].len = 11;
    const_macroblock_address_inc[22].value = 23;
    const_macroblock_address_inc[23].code = 33;
    const_macroblock_address_inc[23].len = 11;
    const_macroblock_address_inc[23].value = 24;
    const_macroblock_address_inc[24].code = 32;
    const_macroblock_address_inc[24].len = 11;
    const_macroblock_address_inc[24].value = 25;
    const_macroblock_address_inc[25].code = 31;
    const_macroblock_address_inc[25].len = 11;
    const_macroblock_address_inc[25].value = 26;
    const_macroblock_address_inc[26].code = 30;
    const_macroblock_address_inc[26].len = 11;
    const_macroblock_address_inc[26].value = 27;
    const_macroblock_address_inc[27].code = 29;
    const_macroblock_address_inc[27].len = 11;
    const_macroblock_address_inc[27].value = 28;
    const_macroblock_address_inc[28].code = 28;
    const_macroblock_address_inc[28].len = 11;
    const_macroblock_address_inc[28].value = 29;
    const_macroblock_address_inc[29].code = 27;
    const_macroblock_address_inc[29].len = 11;
    const_macroblock_address_inc[29].value = 30;
    const_macroblock_address_inc[30].code = 26;
    const_macroblock_address_inc[30].len = 11;
    const_macroblock_address_inc[30].value = 31;
    const_macroblock_address_inc[31].code = 25;
    const_macroblock_address_inc[31].len = 11;
    const_macroblock_address_inc[31].value = 32;
    const_macroblock_address_inc[32].code = 24;
    const_macroblock_address_inc[32].len = 11;
    const_macroblock_address_inc[32].value = 33;

    const_macroblock_type_Ipictures[0].code = 1;
    const_macroblock_type_Ipictures[0].len = 1;
    const_macroblock_type_Ipictures[0].value = 2;
    const_macroblock_type_Ipictures[1].code = 1;
    const_macroblock_type_Ipictures[1].len = 2;
    const_macroblock_type_Ipictures[1].value = 34;
    
    const_macroblock_type_Ppictures[0].code = 1;
    const_macroblock_type_Ppictures[0].len = 1;
    const_macroblock_type_Ppictures[0].value = 20;
    const_macroblock_type_Ppictures[1].code = 1;
    const_macroblock_type_Ppictures[1].len = 2;
    const_macroblock_type_Ppictures[1].value = 4;
    const_macroblock_type_Ppictures[2].code = 1;
    const_macroblock_type_Ppictures[2].len = 3;
    const_macroblock_type_Ppictures[2].value = 16;
    const_macroblock_type_Ppictures[3].code = 3;
    const_macroblock_type_Ppictures[3].len = 5;
    const_macroblock_type_Ppictures[3].value = 2;
    const_macroblock_type_Ppictures[4].code = 2;
    const_macroblock_type_Ppictures[4].len = 5;
    const_macroblock_type_Ppictures[4].value = 52;
    const_macroblock_type_Ppictures[5].code = 1;
    const_macroblock_type_Ppictures[5].len = 5;
    const_macroblock_type_Ppictures[5].value = 36;
    const_macroblock_type_Ppictures[6].code = 1;
    const_macroblock_type_Ppictures[6].len = 6;
    const_macroblock_type_Ppictures[6].value = 34;

    const_macroblock_type_Bpictures[0].code = 2;
    const_macroblock_type_Bpictures[0].len = 2;
    const_macroblock_type_Bpictures[0].value = 24;
    const_macroblock_type_Bpictures[1].code = 3;
    const_macroblock_type_Bpictures[1].len = 2;
    const_macroblock_type_Bpictures[1].value = 28;
    const_macroblock_type_Bpictures[2].code = 2;
    const_macroblock_type_Bpictures[2].len = 3;
    const_macroblock_type_Bpictures[2].value = 8;
    const_macroblock_type_Bpictures[3].code = 3;
    const_macroblock_type_Bpictures[3].len = 3;
    const_macroblock_type_Bpictures[3].value = 12;
    const_macroblock_type_Bpictures[4].code = 2;
    const_macroblock_type_Bpictures[4].len = 4;
    const_macroblock_type_Bpictures[4].value = 16;
    const_macroblock_type_Bpictures[5].code = 3;
    const_macroblock_type_Bpictures[5].len = 4;
    const_macroblock_type_Bpictures[5].value = 20;
    const_macroblock_type_Bpictures[6].code = 3;
    const_macroblock_type_Bpictures[6].len = 5;
    const_macroblock_type_Bpictures[6].value = 2;
    const_macroblock_type_Bpictures[7].code = 2;
    const_macroblock_type_Bpictures[7].len = 5;
    const_macroblock_type_Bpictures[7].value = 60;
    const_macroblock_type_Bpictures[8].code = 3;
    const_macroblock_type_Bpictures[8].len = 6;
    const_macroblock_type_Bpictures[8].value = 52;
    const_macroblock_type_Bpictures[9].code = 2;
    const_macroblock_type_Bpictures[9].len = 6;
    const_macroblock_type_Bpictures[9].value = 44;
    const_macroblock_type_Bpictures[10].code = 1;
    const_macroblock_type_Bpictures[10].len = 6;
    const_macroblock_type_Bpictures[10].value = 34;

    const_dct_dc_size_luminance[0].code = 4;
    const_dct_dc_size_luminance[0].len = 3;
    const_dct_dc_size_luminance[0].value = 0;
    const_dct_dc_size_luminance[1].code = 0;
    const_dct_dc_size_luminance[1].len = 2;
    const_dct_dc_size_luminance[1].value = 1;
    const_dct_dc_size_luminance[2].code = 1;
    const_dct_dc_size_luminance[2].len = 2;
    const_dct_dc_size_luminance[2].value = 2;
    const_dct_dc_size_luminance[3].code = 5;
    const_dct_dc_size_luminance[3].len = 3;
    const_dct_dc_size_luminance[3].value = 3;
    const_dct_dc_size_luminance[4].code = 6;
    const_dct_dc_size_luminance[4].len = 3;
    const_dct_dc_size_luminance[4].value = 4;
    const_dct_dc_size_luminance[5].code = 14;
    const_dct_dc_size_luminance[5].len = 4;
    const_dct_dc_size_luminance[5].value = 5;
    const_dct_dc_size_luminance[6].code = 30;
    const_dct_dc_size_luminance[6].len = 5;
    const_dct_dc_size_luminance[6].value = 6;
    const_dct_dc_size_luminance[7].code = 62;
    const_dct_dc_size_luminance[7].len = 6;
    const_dct_dc_size_luminance[7].value = 7;
    const_dct_dc_size_luminance[8].code = 126;
    const_dct_dc_size_luminance[8].len = 7;
    const_dct_dc_size_luminance[8].value = 8;
    const_dct_dc_size_luminance[9].code = 254;
    const_dct_dc_size_luminance[9].len = 8;
    const_dct_dc_size_luminance[9].value = 9;
    const_dct_dc_size_luminance[10].code = 510;
    const_dct_dc_size_luminance[10].len = 9;
    const_dct_dc_size_luminance[10].value = 10;
    const_dct_dc_size_luminance[11].code = 511;
    const_dct_dc_size_luminance[11].len = 10;
    const_dct_dc_size_luminance[11].value = 11;

    const_dct_dc_size_chrominance[0].code = 0;
    const_dct_dc_size_chrominance[0].len = 2;
    const_dct_dc_size_chrominance[0].value = 0;
    const_dct_dc_size_chrominance[1].code = 1;
    const_dct_dc_size_chrominance[1].len = 2;
    const_dct_dc_size_chrominance[1].value = 1;
    const_dct_dc_size_chrominance[2].code = 2;
    const_dct_dc_size_chrominance[2].len = 2;
    const_dct_dc_size_chrominance[2].value = 2;
    const_dct_dc_size_chrominance[3].code = 6;
    const_dct_dc_size_chrominance[3].len = 3;
    const_dct_dc_size_chrominance[3].value = 3;
    const_dct_dc_size_chrominance[4].code = 14;
    const_dct_dc_size_chrominance[4].len = 4;
    const_dct_dc_size_chrominance[4].value = 4;
    const_dct_dc_size_chrominance[5].code = 30;
    const_dct_dc_size_chrominance[5].len = 5;
    const_dct_dc_size_chrominance[5].value = 5;
    const_dct_dc_size_chrominance[6].code = 62;
    const_dct_dc_size_chrominance[6].len = 6;
    const_dct_dc_size_chrominance[6].value = 6;
    const_dct_dc_size_chrominance[7].code = 126;
    const_dct_dc_size_chrominance[7].len = 7;
    const_dct_dc_size_chrominance[7].value = 7;
    const_dct_dc_size_chrominance[8].code = 254;
    const_dct_dc_size_chrominance[8].len = 8;
    const_dct_dc_size_chrominance[8].value = 8;
    const_dct_dc_size_chrominance[9].code = 510;
    const_dct_dc_size_chrominance[9].len = 9;
    const_dct_dc_size_chrominance[9].value = 9;
    const_dct_dc_size_chrominance[10].code = 1022;
    const_dct_dc_size_chrominance[10].len = 10;
    const_dct_dc_size_chrominance[10].value = 10;
    const_dct_dc_size_chrominance[11].code = 1023;
    const_dct_dc_size_chrominance[11].len = 10;
    const_dct_dc_size_chrominance[11].value = 11;

    // Note that the special codes End_of_Block and Escape
    // are left out of this table and must be checked for seperately.
    const_dct_coefficients_table_zero[0].code = 3;
    const_dct_coefficients_table_zero[0].len = 2;
    const_dct_coefficients_table_zero[0].run = 0;
    const_dct_coefficients_table_zero[0].level = 1;
    const_dct_coefficients_table_zero[1].code = 3;
    const_dct_coefficients_table_zero[1].len = 3;
    const_dct_coefficients_table_zero[1].run = 1;
    const_dct_coefficients_table_zero[1].level = 1;
    const_dct_coefficients_table_zero[2].code = 4;
    const_dct_coefficients_table_zero[2].len = 4;
    const_dct_coefficients_table_zero[2].run = 0;
    const_dct_coefficients_table_zero[2].level = 2;
    const_dct_coefficients_table_zero[3].code = 5;
    const_dct_coefficients_table_zero[3].len = 4;
    const_dct_coefficients_table_zero[3].run = 2;
    const_dct_coefficients_table_zero[3].level = 1;
    const_dct_coefficients_table_zero[4].code = 5;
    const_dct_coefficients_table_zero[4].len = 5;
    const_dct_coefficients_table_zero[4].run = 0;
    const_dct_coefficients_table_zero[4].level = 3;
    const_dct_coefficients_table_zero[5].code = 7;
    const_dct_coefficients_table_zero[5].len = 5;
    const_dct_coefficients_table_zero[5].run = 3;
    const_dct_coefficients_table_zero[5].level = 1;
    const_dct_coefficients_table_zero[6].code = 6;
    const_dct_coefficients_table_zero[6].len = 5;
    const_dct_coefficients_table_zero[6].run = 4;
    const_dct_coefficients_table_zero[6].level = 1;
    const_dct_coefficients_table_zero[7].code = 6;
    const_dct_coefficients_table_zero[7].len = 6;
    const_dct_coefficients_table_zero[7].run = 1;
    const_dct_coefficients_table_zero[7].level = 2;
    const_dct_coefficients_table_zero[8].code = 7;
    const_dct_coefficients_table_zero[8].len = 6;
    const_dct_coefficients_table_zero[8].run = 5;
    const_dct_coefficients_table_zero[8].level = 1;
    const_dct_coefficients_table_zero[9].code = 5;
    const_dct_coefficients_table_zero[9].len = 6;
    const_dct_coefficients_table_zero[9].run = 6;
    const_dct_coefficients_table_zero[9].level = 1;
    const_dct_coefficients_table_zero[10].code = 4;
    const_dct_coefficients_table_zero[10].len = 6;
    const_dct_coefficients_table_zero[10].run = 7;
    const_dct_coefficients_table_zero[10].level = 1;
    const_dct_coefficients_table_zero[11].code = 6;
    const_dct_coefficients_table_zero[11].len = 7;
    const_dct_coefficients_table_zero[11].run = 0;
    const_dct_coefficients_table_zero[11].level = 4;
    const_dct_coefficients_table_zero[12].code = 4;
    const_dct_coefficients_table_zero[12].len = 7;
    const_dct_coefficients_table_zero[12].run = 2;
    const_dct_coefficients_table_zero[12].level = 2;
    const_dct_coefficients_table_zero[13].code = 7;
    const_dct_coefficients_table_zero[13].len = 7;
    const_dct_coefficients_table_zero[13].run = 8;
    const_dct_coefficients_table_zero[13].level = 1;
    const_dct_coefficients_table_zero[14].code = 5;
    const_dct_coefficients_table_zero[14].len = 7;
    const_dct_coefficients_table_zero[14].run = 9;
    const_dct_coefficients_table_zero[14].level = 1;
    const_dct_coefficients_table_zero[15].code = 38;
    const_dct_coefficients_table_zero[15].len = 8;
    const_dct_coefficients_table_zero[15].run = 0;
    const_dct_coefficients_table_zero[15].level = 5;
    const_dct_coefficients_table_zero[16].code = 33;
    const_dct_coefficients_table_zero[16].len = 8;
    const_dct_coefficients_table_zero[16].run = 0;
    const_dct_coefficients_table_zero[16].level = 6;
    const_dct_coefficients_table_zero[17].code = 37;
    const_dct_coefficients_table_zero[17].len = 8;
    const_dct_coefficients_table_zero[17].run = 1;
    const_dct_coefficients_table_zero[17].level = 3;
    const_dct_coefficients_table_zero[18].code = 36;
    const_dct_coefficients_table_zero[18].len = 8;
    const_dct_coefficients_table_zero[18].run = 3;
    const_dct_coefficients_table_zero[18].level = 2;
    const_dct_coefficients_table_zero[19].code = 39;
    const_dct_coefficients_table_zero[19].len = 8;
    const_dct_coefficients_table_zero[19].run = 10;
    const_dct_coefficients_table_zero[19].level = 1;
    const_dct_coefficients_table_zero[20].code = 35;
    const_dct_coefficients_table_zero[20].len = 8;
    const_dct_coefficients_table_zero[20].run = 11;
    const_dct_coefficients_table_zero[20].level = 1;
    const_dct_coefficients_table_zero[21].code = 34;
    const_dct_coefficients_table_zero[21].len = 8;
    const_dct_coefficients_table_zero[21].run = 12;
    const_dct_coefficients_table_zero[21].level = 1;
    const_dct_coefficients_table_zero[22].code = 32;
    const_dct_coefficients_table_zero[22].len = 8;
    const_dct_coefficients_table_zero[22].run = 13;
    const_dct_coefficients_table_zero[22].level = 1;
    const_dct_coefficients_table_zero[23].code = 10;
    const_dct_coefficients_table_zero[23].len = 10;
    const_dct_coefficients_table_zero[23].run = 0;
    const_dct_coefficients_table_zero[23].level = 7;
    const_dct_coefficients_table_zero[24].code = 12;
    const_dct_coefficients_table_zero[24].len = 10;
    const_dct_coefficients_table_zero[24].run = 1;
    const_dct_coefficients_table_zero[24].level = 4;
    const_dct_coefficients_table_zero[25].code = 11;
    const_dct_coefficients_table_zero[25].len = 10;
    const_dct_coefficients_table_zero[25].run = 2;
    const_dct_coefficients_table_zero[25].level = 3;
    const_dct_coefficients_table_zero[26].code = 15;
    const_dct_coefficients_table_zero[26].len = 10;
    const_dct_coefficients_table_zero[26].run = 4;
    const_dct_coefficients_table_zero[26].level = 2;
    const_dct_coefficients_table_zero[27].code = 9;
    const_dct_coefficients_table_zero[27].len = 10;
    const_dct_coefficients_table_zero[27].run = 5;
    const_dct_coefficients_table_zero[27].level = 2;
    const_dct_coefficients_table_zero[28].code = 14;
    const_dct_coefficients_table_zero[28].len = 10;
    const_dct_coefficients_table_zero[28].run = 14;
    const_dct_coefficients_table_zero[28].level = 1;
    const_dct_coefficients_table_zero[29].code = 13;
    const_dct_coefficients_table_zero[29].len = 10;
    const_dct_coefficients_table_zero[29].run = 15;
    const_dct_coefficients_table_zero[29].level = 1;
    const_dct_coefficients_table_zero[30].code = 8;
    const_dct_coefficients_table_zero[30].len = 10;
    const_dct_coefficients_table_zero[30].run = 16;
    const_dct_coefficients_table_zero[30].level = 1;
    const_dct_coefficients_table_zero[31].code = 29;
    const_dct_coefficients_table_zero[31].len = 12;
    const_dct_coefficients_table_zero[31].run = 0;
    const_dct_coefficients_table_zero[31].level = 8;
    const_dct_coefficients_table_zero[32].code = 24;
    const_dct_coefficients_table_zero[32].len = 12;
    const_dct_coefficients_table_zero[32].run = 0;
    const_dct_coefficients_table_zero[32].level = 9;
    const_dct_coefficients_table_zero[33].code = 19;
    const_dct_coefficients_table_zero[33].len = 12;
    const_dct_coefficients_table_zero[33].run = 0;
    const_dct_coefficients_table_zero[33].level = 10;
    const_dct_coefficients_table_zero[34].code = 16;
    const_dct_coefficients_table_zero[34].len = 12;
    const_dct_coefficients_table_zero[34].run = 0;
    const_dct_coefficients_table_zero[34].level = 11;
    const_dct_coefficients_table_zero[35].code = 27;
    const_dct_coefficients_table_zero[35].len = 12;
    const_dct_coefficients_table_zero[35].run = 1;
    const_dct_coefficients_table_zero[35].level = 5;
    const_dct_coefficients_table_zero[36].code = 20;
    const_dct_coefficients_table_zero[36].len = 12;
    const_dct_coefficients_table_zero[36].run = 2;
    const_dct_coefficients_table_zero[36].level = 4;
    const_dct_coefficients_table_zero[37].code = 28;
    const_dct_coefficients_table_zero[37].len = 12;
    const_dct_coefficients_table_zero[37].run = 3;
    const_dct_coefficients_table_zero[37].level = 3;
    const_dct_coefficients_table_zero[38].code = 18;
    const_dct_coefficients_table_zero[38].len = 12;
    const_dct_coefficients_table_zero[38].run = 4;
    const_dct_coefficients_table_zero[38].level = 3;
    const_dct_coefficients_table_zero[39].code = 30;
    const_dct_coefficients_table_zero[39].len = 12;
    const_dct_coefficients_table_zero[39].run = 6;
    const_dct_coefficients_table_zero[39].level = 2;
    const_dct_coefficients_table_zero[40].code = 21;
    const_dct_coefficients_table_zero[40].len = 12;
    const_dct_coefficients_table_zero[40].run = 7;
    const_dct_coefficients_table_zero[40].level = 2;
    const_dct_coefficients_table_zero[41].code = 17;
    const_dct_coefficients_table_zero[41].len = 12;
    const_dct_coefficients_table_zero[41].run = 8;
    const_dct_coefficients_table_zero[41].level = 2;
    const_dct_coefficients_table_zero[42].code = 31;
    const_dct_coefficients_table_zero[42].len = 12;
    const_dct_coefficients_table_zero[42].run = 17;
    const_dct_coefficients_table_zero[42].level = 1;
    const_dct_coefficients_table_zero[43].code = 26;
    const_dct_coefficients_table_zero[43].len = 12;
    const_dct_coefficients_table_zero[43].run = 18;
    const_dct_coefficients_table_zero[43].level = 1;
    const_dct_coefficients_table_zero[44].code = 25;
    const_dct_coefficients_table_zero[44].len = 12;
    const_dct_coefficients_table_zero[44].run = 19;
    const_dct_coefficients_table_zero[44].level = 1;
    const_dct_coefficients_table_zero[45].code = 23;
    const_dct_coefficients_table_zero[45].len = 12;
    const_dct_coefficients_table_zero[45].run = 20;
    const_dct_coefficients_table_zero[45].level = 1;
    const_dct_coefficients_table_zero[46].code = 22;
    const_dct_coefficients_table_zero[46].len = 12;
    const_dct_coefficients_table_zero[46].run = 21;
    const_dct_coefficients_table_zero[46].level = 1;
    const_dct_coefficients_table_zero[47].code = 26;
    const_dct_coefficients_table_zero[47].len = 13;
    const_dct_coefficients_table_zero[47].run = 0;
    const_dct_coefficients_table_zero[47].level = 12;
    const_dct_coefficients_table_zero[48].code = 25;
    const_dct_coefficients_table_zero[48].len = 13;
    const_dct_coefficients_table_zero[48].run = 0;
    const_dct_coefficients_table_zero[48].level = 13;
    const_dct_coefficients_table_zero[49].code = 24;
    const_dct_coefficients_table_zero[49].len = 13;
    const_dct_coefficients_table_zero[49].run = 0;
    const_dct_coefficients_table_zero[49].level = 14;
    const_dct_coefficients_table_zero[50].code = 23;
    const_dct_coefficients_table_zero[50].len = 13;
    const_dct_coefficients_table_zero[50].run = 0;
    const_dct_coefficients_table_zero[50].level = 15;
    const_dct_coefficients_table_zero[51].code = 22;
    const_dct_coefficients_table_zero[51].len = 13;
    const_dct_coefficients_table_zero[51].run = 1;
    const_dct_coefficients_table_zero[51].level = 6;
    const_dct_coefficients_table_zero[52].code = 21;
    const_dct_coefficients_table_zero[52].len = 13;
    const_dct_coefficients_table_zero[52].run = 1;
    const_dct_coefficients_table_zero[52].level = 7;
    const_dct_coefficients_table_zero[53].code = 20;
    const_dct_coefficients_table_zero[53].len = 13;
    const_dct_coefficients_table_zero[53].run = 2;
    const_dct_coefficients_table_zero[53].level = 5;
    const_dct_coefficients_table_zero[54].code = 19;
    const_dct_coefficients_table_zero[54].len = 13;
    const_dct_coefficients_table_zero[54].run = 3;
    const_dct_coefficients_table_zero[54].level = 4;
    const_dct_coefficients_table_zero[55].code = 18;
    const_dct_coefficients_table_zero[55].len = 13;
    const_dct_coefficients_table_zero[55].run = 5;
    const_dct_coefficients_table_zero[55].level = 3;
    const_dct_coefficients_table_zero[56].code = 17;
    const_dct_coefficients_table_zero[56].len = 13;
    const_dct_coefficients_table_zero[56].run = 9;
    const_dct_coefficients_table_zero[56].level = 2;
    const_dct_coefficients_table_zero[57].code = 16;
    const_dct_coefficients_table_zero[57].len = 13;
    const_dct_coefficients_table_zero[57].run = 10;
    const_dct_coefficients_table_zero[57].level = 2;
    const_dct_coefficients_table_zero[58].code = 31;
    const_dct_coefficients_table_zero[58].len = 13;
    const_dct_coefficients_table_zero[58].run = 22;
    const_dct_coefficients_table_zero[58].level = 1;
    const_dct_coefficients_table_zero[59].code = 30;
    const_dct_coefficients_table_zero[59].len = 13;
    const_dct_coefficients_table_zero[59].run = 23;
    const_dct_coefficients_table_zero[59].level = 1;
    const_dct_coefficients_table_zero[60].code = 29;
    const_dct_coefficients_table_zero[60].len = 13;
    const_dct_coefficients_table_zero[60].run = 24;
    const_dct_coefficients_table_zero[60].level = 1;
    const_dct_coefficients_table_zero[61].code = 28;
    const_dct_coefficients_table_zero[61].len = 13;
    const_dct_coefficients_table_zero[61].run = 25;
    const_dct_coefficients_table_zero[61].level = 1;
    const_dct_coefficients_table_zero[62].code = 27;
    const_dct_coefficients_table_zero[62].len = 13;
    const_dct_coefficients_table_zero[62].run = 26;
    const_dct_coefficients_table_zero[62].level = 1;
    const_dct_coefficients_table_zero[63].code = 31;
    const_dct_coefficients_table_zero[63].len = 14;
    const_dct_coefficients_table_zero[63].run = 0;
    const_dct_coefficients_table_zero[63].level = 16;
    const_dct_coefficients_table_zero[64].code = 30;
    const_dct_coefficients_table_zero[64].len = 14;
    const_dct_coefficients_table_zero[64].run = 0;
    const_dct_coefficients_table_zero[64].level = 17;
    const_dct_coefficients_table_zero[65].code = 29;
    const_dct_coefficients_table_zero[65].len = 14;
    const_dct_coefficients_table_zero[65].run = 0;
    const_dct_coefficients_table_zero[65].level = 18;
    const_dct_coefficients_table_zero[66].code = 28;
    const_dct_coefficients_table_zero[66].len = 14;
    const_dct_coefficients_table_zero[66].run = 0;
    const_dct_coefficients_table_zero[66].level = 19;
    const_dct_coefficients_table_zero[67].code = 27;
    const_dct_coefficients_table_zero[67].len = 14;
    const_dct_coefficients_table_zero[67].run = 0;
    const_dct_coefficients_table_zero[67].level = 20;
    const_dct_coefficients_table_zero[68].code = 26;
    const_dct_coefficients_table_zero[68].len = 14;
    const_dct_coefficients_table_zero[68].run = 0;
    const_dct_coefficients_table_zero[68].level = 21;
    const_dct_coefficients_table_zero[69].code = 25;
    const_dct_coefficients_table_zero[69].len = 14;
    const_dct_coefficients_table_zero[69].run = 0;
    const_dct_coefficients_table_zero[69].level = 22;
    const_dct_coefficients_table_zero[70].code = 24;
    const_dct_coefficients_table_zero[70].len = 14;
    const_dct_coefficients_table_zero[70].run = 0;
    const_dct_coefficients_table_zero[70].level = 23;
    const_dct_coefficients_table_zero[71].code = 23;
    const_dct_coefficients_table_zero[71].len = 14;
    const_dct_coefficients_table_zero[71].run = 0;
    const_dct_coefficients_table_zero[71].level = 24;
    const_dct_coefficients_table_zero[72].code = 22;
    const_dct_coefficients_table_zero[72].len = 14;
    const_dct_coefficients_table_zero[72].run = 0;
    const_dct_coefficients_table_zero[72].level = 25;
    const_dct_coefficients_table_zero[73].code = 21;
    const_dct_coefficients_table_zero[73].len = 14;
    const_dct_coefficients_table_zero[73].run = 0;
    const_dct_coefficients_table_zero[73].level = 26;
    const_dct_coefficients_table_zero[74].code = 20;
    const_dct_coefficients_table_zero[74].len = 14;
    const_dct_coefficients_table_zero[74].run = 0;
    const_dct_coefficients_table_zero[74].level = 27;
    const_dct_coefficients_table_zero[75].code = 19;
    const_dct_coefficients_table_zero[75].len = 14;
    const_dct_coefficients_table_zero[75].run = 0;
    const_dct_coefficients_table_zero[75].level = 28;
    const_dct_coefficients_table_zero[76].code = 18;
    const_dct_coefficients_table_zero[76].len = 14;
    const_dct_coefficients_table_zero[76].run = 0;
    const_dct_coefficients_table_zero[76].level = 29;
    const_dct_coefficients_table_zero[77].code = 17;
    const_dct_coefficients_table_zero[77].len = 14;
    const_dct_coefficients_table_zero[77].run = 0;
    const_dct_coefficients_table_zero[77].level = 30;
    const_dct_coefficients_table_zero[78].code = 16;
    const_dct_coefficients_table_zero[78].len = 14;
    const_dct_coefficients_table_zero[78].run = 0;
    const_dct_coefficients_table_zero[78].level = 31;
    const_dct_coefficients_table_zero[79].code = 24;
    const_dct_coefficients_table_zero[79].len = 15;
    const_dct_coefficients_table_zero[79].run = 0;
    const_dct_coefficients_table_zero[79].level = 32;
    const_dct_coefficients_table_zero[80].code = 23;
    const_dct_coefficients_table_zero[80].len = 15;
    const_dct_coefficients_table_zero[80].run = 0;
    const_dct_coefficients_table_zero[80].level = 33;
    const_dct_coefficients_table_zero[81].code = 22;
    const_dct_coefficients_table_zero[81].len = 15;
    const_dct_coefficients_table_zero[81].run = 0;
    const_dct_coefficients_table_zero[81].level = 34;
    const_dct_coefficients_table_zero[82].code = 21;
    const_dct_coefficients_table_zero[82].len = 15;
    const_dct_coefficients_table_zero[82].run = 0;
    const_dct_coefficients_table_zero[82].level = 35;
    const_dct_coefficients_table_zero[83].code = 20;
    const_dct_coefficients_table_zero[83].len = 15;
    const_dct_coefficients_table_zero[83].run = 0;
    const_dct_coefficients_table_zero[83].level = 36;
    const_dct_coefficients_table_zero[84].code = 19;
    const_dct_coefficients_table_zero[84].len = 15;
    const_dct_coefficients_table_zero[84].run = 0;
    const_dct_coefficients_table_zero[84].level = 37;
    const_dct_coefficients_table_zero[85].code = 18;
    const_dct_coefficients_table_zero[85].len = 15;
    const_dct_coefficients_table_zero[85].run = 0;
    const_dct_coefficients_table_zero[85].level = 38;
    const_dct_coefficients_table_zero[86].code = 17;
    const_dct_coefficients_table_zero[86].len = 15;
    const_dct_coefficients_table_zero[86].run = 0;
    const_dct_coefficients_table_zero[86].level = 39;
    const_dct_coefficients_table_zero[87].code = 16;
    const_dct_coefficients_table_zero[87].len = 15;
    const_dct_coefficients_table_zero[87].run = 0;
    const_dct_coefficients_table_zero[87].level = 40;
    const_dct_coefficients_table_zero[88].code = 31;
    const_dct_coefficients_table_zero[88].len = 15;
    const_dct_coefficients_table_zero[88].run = 1;
    const_dct_coefficients_table_zero[88].level = 8;
    const_dct_coefficients_table_zero[89].code = 30;
    const_dct_coefficients_table_zero[89].len = 15;
    const_dct_coefficients_table_zero[89].run = 1;
    const_dct_coefficients_table_zero[89].level = 9;
    const_dct_coefficients_table_zero[90].code = 29;
    const_dct_coefficients_table_zero[90].len = 15;
    const_dct_coefficients_table_zero[90].run = 1;
    const_dct_coefficients_table_zero[90].level = 10;
    const_dct_coefficients_table_zero[91].code = 28;
    const_dct_coefficients_table_zero[91].len = 15;
    const_dct_coefficients_table_zero[91].run = 1;
    const_dct_coefficients_table_zero[91].level = 11;
    const_dct_coefficients_table_zero[92].code = 27;
    const_dct_coefficients_table_zero[92].len = 15;
    const_dct_coefficients_table_zero[92].run = 1;
    const_dct_coefficients_table_zero[92].level = 12;
    const_dct_coefficients_table_zero[93].code = 26;
    const_dct_coefficients_table_zero[93].len = 15;
    const_dct_coefficients_table_zero[93].run = 1;
    const_dct_coefficients_table_zero[93].level = 13;
    const_dct_coefficients_table_zero[94].code = 25;
    const_dct_coefficients_table_zero[94].len = 15;
    const_dct_coefficients_table_zero[94].run = 1;
    const_dct_coefficients_table_zero[94].level = 14;
    const_dct_coefficients_table_zero[95].code = 19;
    const_dct_coefficients_table_zero[95].len = 16;
    const_dct_coefficients_table_zero[95].run = 1;
    const_dct_coefficients_table_zero[95].level = 15;
    const_dct_coefficients_table_zero[96].code = 18;
    const_dct_coefficients_table_zero[96].len = 16;
    const_dct_coefficients_table_zero[96].run = 1;
    const_dct_coefficients_table_zero[96].level = 16;
    const_dct_coefficients_table_zero[97].code = 17;
    const_dct_coefficients_table_zero[97].len = 16;
    const_dct_coefficients_table_zero[97].run = 1;
    const_dct_coefficients_table_zero[97].level = 17;
    const_dct_coefficients_table_zero[98].code = 16;
    const_dct_coefficients_table_zero[98].len = 16;
    const_dct_coefficients_table_zero[98].run = 1;
    const_dct_coefficients_table_zero[98].level = 18;
    const_dct_coefficients_table_zero[99].code = 20;
    const_dct_coefficients_table_zero[99].len = 16;
    const_dct_coefficients_table_zero[99].run = 6;
    const_dct_coefficients_table_zero[99].level = 3;
    const_dct_coefficients_table_zero[100].code = 26;
    const_dct_coefficients_table_zero[100].len = 16;
    const_dct_coefficients_table_zero[100].run = 11;
    const_dct_coefficients_table_zero[100].level = 2;
    const_dct_coefficients_table_zero[101].code = 25;
    const_dct_coefficients_table_zero[101].len = 16;
    const_dct_coefficients_table_zero[101].run = 12;
    const_dct_coefficients_table_zero[101].level = 2;
    const_dct_coefficients_table_zero[102].code = 24;
    const_dct_coefficients_table_zero[102].len = 16;
    const_dct_coefficients_table_zero[102].run = 13;
    const_dct_coefficients_table_zero[102].level = 2;
    const_dct_coefficients_table_zero[103].code = 23;
    const_dct_coefficients_table_zero[103].len = 16;
    const_dct_coefficients_table_zero[103].run = 14;
    const_dct_coefficients_table_zero[103].level = 2;
    const_dct_coefficients_table_zero[104].code = 22;
    const_dct_coefficients_table_zero[104].len = 16;
    const_dct_coefficients_table_zero[104].run = 15;
    const_dct_coefficients_table_zero[104].level = 2;
    const_dct_coefficients_table_zero[105].code = 21;
    const_dct_coefficients_table_zero[105].len = 16;
    const_dct_coefficients_table_zero[105].run = 16;
    const_dct_coefficients_table_zero[105].level = 2;
    const_dct_coefficients_table_zero[106].code = 31;
    const_dct_coefficients_table_zero[106].len = 16;
    const_dct_coefficients_table_zero[106].run = 27;
    const_dct_coefficients_table_zero[106].level = 1;
    const_dct_coefficients_table_zero[107].code = 30;
    const_dct_coefficients_table_zero[107].len = 16;
    const_dct_coefficients_table_zero[107].run = 28;
    const_dct_coefficients_table_zero[107].level = 1;
    const_dct_coefficients_table_zero[108].code = 29;
    const_dct_coefficients_table_zero[108].len = 16;
    const_dct_coefficients_table_zero[108].run = 29;
    const_dct_coefficients_table_zero[108].level = 1;
    const_dct_coefficients_table_zero[109].code = 28;
    const_dct_coefficients_table_zero[109].len = 16;
    const_dct_coefficients_table_zero[109].run = 30;
    const_dct_coefficients_table_zero[109].level = 1;
    const_dct_coefficients_table_zero[110].code = 27;
    const_dct_coefficients_table_zero[110].len = 16;
    const_dct_coefficients_table_zero[110].run = 31;
    const_dct_coefficients_table_zero[110].level = 1;
  }

  phase PushMacroblock push 64 {
    for (int j = 0; j < 64; j++) {
      push(QFS[j]);
    }
    count++;
  }

  work pop * push * {  // Actually unknown pop/push rate
    if (!ran) {
      print("Parsing M2V File...");
      ran = true;
 
      int tempval;

      // video_sequence() (cite 1, P. 25)

//      print("Looking for start code");
      next_start_code();
//      print("Found start code");

        // sequence_header() (cite 1, P. 26)

      pops(32,tempval);
      if (tempval != 0x000001B3)
        print("Error - Expected Video Sequence Start Code, Found " + tempval);

//      print("Reading Sequence Header");

      int horizontal_size_value, vertical_size_value, aspect_ratio_information,
        frame_rate_code, bit_rate_value, vbv_buffer_size_value,
        constrained_parameters_flag, load_intra_quantiser_matrix, load_non_intra_quantiser_matrix;
      // (cite 1, P.55)
      pops(12,horizontal_size_value);
      pops(12,vertical_size_value);
      pops(4,aspect_ratio_information);
          // (cite 1, P.41 Table 6-3)
      if (aspect_ratio_information == 0)
        print("Error - Forbidden Aspect Ratio");
      else if (aspect_ratio_information == 1) {
//        print("  aspect_ratio_information 1:1");
      } else {
        print("Error - Program Limitation: Don't Know How to Handle Other Aspect Ratios");
      }
      // TODO later calculate SAR and DAR, see page
      pops(4,frame_rate_code);
          // (cite 1, P.41-42 Table 6-4)
      float frame_rate_value = 0;
      if (frame_rate_code == 0)
        print("Error - Forbidden Frame Rate Code");
      else if (frame_rate_code == 4) {
//        print("  frame_rate_code 4");
        frame_rate_value = 30000.0/1001.0;
      }
      else 
        print("Error - Program Limitation: Don't Know How to Handle Other Frame Rate Codes");
//      print("  frame_rate_value " + frame_rate_value);
      pops(18,bit_rate_value);
      marker_bit();
      pops(10,vbv_buffer_size_value);
      pops(1,constrained_parameters_flag);
      // (cite 1, P. 43)
      if (constrained_parameters_flag != 0)
        print("Error - Expected Constrained Parameters Flag To Be 0");
      // Default Values for the quantiser_matrices
      int[64] intra_quantiser_matrix = 
        { 8, 16, 19, 22, 26, 27, 29, 34,
         16, 16, 22, 24, 27, 29, 34, 37,
         19, 22, 26, 27, 29, 34, 34, 38,
         22, 22, 26, 27, 29, 34, 37, 40,
         22, 26, 27, 29, 32, 35, 40, 48,
         26, 27, 29, 32, 35, 40, 48, 58,
         26, 27, 29, 34, 38, 46, 56, 69,
         27, 29, 35, 38, 46, 56, 69, 83};
      int[64] non_intra_quantiser_matrix =
        {16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16};
      pops(1,load_intra_quantiser_matrix);
      if (load_intra_quantiser_matrix == 1) {
        print("  Loading Intra Quantiser Matrix from File");    
        for (int i = 0; i < 64; i++) {
          pops(8,intra_quantiser_matrix[i]);
        }
      } else {
        // print("  Using Default Intra Quantiser Matrix");
        // Default Values Previously Loaded
      }
      pops(1,load_non_intra_quantiser_matrix);
      if (load_non_intra_quantiser_matrix == 1) {
        // print("  Loading Non Intra Quantiser Matrix from File");
        for (int i = 0; i < 64; i++) {
          pops(8,intra_quantiser_matrix[i]);
        }
      } else {
        print("  Using Default Non Intra Quantiser Matrix");
        // Default Values Previously Loaded
      }
      UpdatePortal_quantiser_data_ac.setQuantiserMatrices(intra_quantiser_matrix,
                                                       non_intra_quantiser_matrix) [0:0]; 

      next_start_code();

        // sequence_extension() (cite 1, P. 28)

      pops(32,tempval);
      if (tempval != 0x000001B5)
        print("Error - Expected Extension Start Code, File Must be MPEG-1 " + tempval);

      int extension_start_code_identifier, profile_and_level_indication,
          progressive_sequence, chroma_format, horizontal_size_extension,
          vertical_size_extension, bit_rate_extension, vbv_buffer_size_extension,
          low_delay, frame_rate_extension_n, frame_rate_extension_d;
      pops(4,extension_start_code_identifier);
      if (extension_start_code_identifier != 0x1)
        print("Error - Expected Sequence Extension Identifier " + extension_start_code_identifier);
      pops(8,profile_and_level_indication);
      // TODO Interpret and understand the profile and level indicator
      pops(1,progressive_sequence);
      if (progressive_sequence == 1) {
//        print("  progressive_sequence 1: allows only progressive frames");
      } else {
        print("  progressive_sequence 0: allows interlaced and progressive frames");
        print("Error - Program Limitation: Don't handle interlaced frames");
      }
      pops(2,chroma_format);
      int block_count = 0; // (cite 1, P. 62)
      if (chroma_format == 1) {
//        print("  chroma_format 4:2:0");
        block_count = 6;
      } else {
        print("Error - Program Limitation: Unsupported chroma_format");
      }
//      print("  block_count " + block_count);
      pops(2,horizontal_size_extension);
      int horizontal_size = horizontal_size_value + (horizontal_size_extension << 12);
      int mb_width = (horizontal_size + 15) / 16;
      pops(2,vertical_size_extension);
      int vertical_size = vertical_size_value +  (vertical_size_extension << 12);
      int mb_height = (vertical_size + 15) / 16;
      pops(12,bit_rate_extension);
      // (cite 1, P.42)
      int bit_rate = 400 * (bit_rate_value + (bit_rate_extension << 18));
      marker_bit();
      pops(8,vbv_buffer_size_extension);
      int vbv_buffer_size = vbv_buffer_size_value + (vbv_buffer_size_extension << 10);
      pops(1,low_delay);
      if (low_delay == 1) {
        print("  low_delay 1 indicates that sequence containes no B-pictures");
        print("Error - Program Limitation: Can't Handle This Case Yet");
      } else {
//        print("  low_delay 0 indicates that sequence is allowed to contain B-pictures");
      }
      pops(2,frame_rate_extension_n);
      pops(5,frame_rate_extension_d);
      // cite (1, P. P.41)
      float frame_rate = frame_rate_value * 
        ((float) (frame_rate_extension_n + 1)) / ((float) (frame_rate_extension_d + 1));
      next_start_code();

      boolean sequence_end_code_not_found = true;
      while (sequence_end_code_not_found) {
        // extension_and_user_data(0) (cite 1, P.26)
        peeks(32,tempval);
        while (tempval == 0x000001B5 || tempval == 0x000001B2) {
          pops(32,tempval);
          if (tempval == 0x000001B5) {
          // extension_data(0) (cite 1, P.27)
            print("Error - Program Limitation: Not Yet Support for Extension_Data(0)");
          } else {      
          // user_data() TODO (cite 1, P.27)
            print("Error - Program Limitation: Not Yet Support for User_Data()");
          }
          peeks(32,tempval);
        }
        
        boolean picture_or_group_start_code_found = true;
        while (picture_or_group_start_code_found) {
          peeks(32,tempval);
          if (tempval == 0x000001B8) {
            // group_of_pictures_header() (cite 1, P.29)
            pops(32,tempval);
            int drop_frame_flag, time_code_hours, time_code_minutes, time_code_seconds, 
                time_code_pictures, closed_gop, broken_link;
            // -- Time Code - Not Used in Decoding Process --
            // (cite 1, P.49)
            pops(1,drop_frame_flag);
            pops(5,time_code_hours);
            pops(6,time_code_minutes);
            marker_bit();
            pops(6,time_code_seconds);
            pops(6,time_code_pictures);
            // -- End of Time Code
     
            pops(1,closed_gop);
            if (closed_gop == 1)
              print("Error - Program Limitation: closed_gop = 1");
            pops(1,broken_link);
            if (broken_link == 1)
              print("Error - Program Limitation: broken_link = 1");
            next_start_code();
            // extension_and_user_data(1) (cite 1, P.26)
            peeks(32,tempval);
            if (tempval == 0x000001B5 || tempval == 0x000001B2)
              print("Error - Program Limitation: Not Yet Support for extension_and_user_data(1)");
          }
 
          // picture_header() (cite 1, P.30)
          pops(32,tempval);
          if (tempval != 0x00000100) {
            print("Error - Picture Start Code Expected, " + tempval);
          }

          int temporal_reference, picture_coding_type, vbv_delay, full_pel_forward_vector,
              forward_f_code, full_pel_backward_vector, backward_f_code;
          // (cite 1, P.50) for interpretation of the following fields
          pops(10,temporal_reference);
//          print("  temporal_reference " + temporal_reference);   
          pops(3,picture_coding_type);
          if (picture_coding_type == 1) {
//            print("  picture_coding_type = I-picture");
          } else if (picture_coding_type == 2) {
//            print("  picture_coding_type = P-picture");
          } else if (picture_coding_type == 3) {
//            print("  picture_coding_type = B-picture");
          } else {
            print("  Error: Forbidden picture_coding_type " + picture_coding_type);
          }
          print("parser Setting picture type " + picture_coding_type);
          UpdatePortal_motion_vectors_lum.setPictureType(picture_coding_type);
          UpdatePortal_motion_vectors_cr.setPictureType(picture_coding_type);
          UpdatePortal_motion_vectors_cb.setPictureType(picture_coding_type);
          pops(16,vbv_delay);
          // TODO unknown interpretation for vbv_delay, (cite 1, P.50)
          // The following is not used by the MPEG-2 specification (cite 1, P.51)
          // Supposed to have certain values, but not guaranteed for most files.
          if (picture_coding_type == 2 || picture_coding_type == 3) {
            pops(1,full_pel_forward_vector);
            pops(3,forward_f_code);
          } 
          if (picture_coding_type == 3) {
            pops(1,full_pel_backward_vector);
            pops(3,backward_f_code);
          }
          pops(1,tempval);
          if (tempval == 1)
            print("Error: File conforms to some superset of the MPEG-2 specification");
          next_start_code();
            
          // picture_coding_extension() (cite 1, P.30)
          pops(32,tempval);
          if (tempval != 0x000001B5)
            print("Error - Expecting extension start code " + tempval);
          pops(4,extension_start_code_identifier);
          if (extension_start_code_identifier != 0x8)
            print("Error - Expecting picture coding extension ID " + extension_start_code_identifier);
          int[2][2] f_code;
          pops(4,f_code[0][0]);
          pops(4,f_code[0][1]);
          pops(4,f_code[1][0]);
          pops(4,f_code[1][1]);
          // (cite 1, P.51)
          for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
              if (f_code[i][j] == 0 || (f_code[i][j] >= 10 && f_code[i][j] <= 14))
                print("Error - Invalid f_code");
              if (picture_coding_type == 1 && f_code[i][j] != 0xF)
                print("Error - Program Limitation: I-frame has motion prediction");
              if (picture_coding_type == 2 && f_code[1][j] != 0xF)
                print("Error - Program Limitation: P-frame has backward motion prediction");
            }
          }
          int intra_dc_precision, picture_structure, top_field_first, frame_pred_frame_dct, 
              concealment_motion_vectors, q_scale_type, intra_vlc_format, alternate_scan, 
              repeat_first_field, chroma_420_type, progressive_frame, composite_display_flag;
          pops(2,intra_dc_precision);
          UpdatePortal_quantiser_data_dc.setIntraDCPrecision(intra_dc_precision);
          int actual_intra_dc_precision = intra_dc_precision + 8;
          pops(2,picture_structure);
          if (picture_structure != 3)
            print("Error - Program Limitation: Interlaced or bad picture structure");
          pops(1,top_field_first); // Interpreted Later
          pops(1,frame_pred_frame_dct);
          if (frame_pred_frame_dct != 1) 
            print("Error - Program Limitation or Bad Syntax: frame_pred_frame_dct must be 1");
          pops(1,concealment_motion_vectors);
//          print("  concealment_motion_vectors " + concealment_motion_vectors);
          pops(1,q_scale_type);
          UpdatePortal_quantiser_data_ac.setQScaleType(q_scale_type) [0:0];
          pops(1,intra_vlc_format);
          pops(1,alternate_scan);
          if (alternate_scan == 1)
            print("Error - Program Limitation - Doesn't handle alternate_scan right now");
          pops(1,repeat_first_field);
          // todo Assumes progressive_sequence = 1
          if (repeat_first_field == 0) {
          //  print("  repeat_first_field = 0, one frame output");
          }
          else {
            if (top_field_first == 0)
              print("  repeat_first_field = 1, top_field_first = 0, two frames output");
            else
              print("  repeat_first_field = 1, top_field_first = 1, three frames output");
          }
          pops(1,chroma_420_type);
          // We don't really care about this, although it should be 1 for 4:2:0 chroma.
          // (cite 1, P.53)
          pops(1,progressive_frame);
          // Again, I don't think we care too much about this value, since we assume only a
          // base stream exists.
          pops(1,composite_display_flag);
          if (composite_display_flag == 1)
            print("Error - Program Limitation: Assumes no composite display information");
          else {
//            print("  composite_display_flag - not present");
          }
          next_start_code();
          
          // extension_and_user_data(2)
          peeks(32,tempval);
          if (tempval == 0x000001B5 || tempval == 0x000001B2)
            print("Error - Program Limitation: Not Yet Support for extension_and_user_data(2)");
          
          // picture_data() (cite 1, P.34)
          boolean slice_start_code_follows = true;
          while (slice_start_code_follows) {
            // slice() (cite 1, P.34)

            // Reset motion vector predictors, (cite 1, P. 77-80)
            int[2][2][2] PMV;
            for (int i = 0; i < 2; i++)
              for (int j = 0; j < 2; j++)
                for (int k = 0; k < 2; k++)
                  PMV[i][j][k] = 0;

            pops(24,tempval);
            if (tempval != 0x000001) 
              print("Error - Expecting slice_start_code " + tempval);
            int slice_vertical_position;
            pops(8,slice_vertical_position);
            if (slice_vertical_position < 0x01 || slice_vertical_position > 0xAF)
              print("Error - Invalid slice_vertical_position" + slice_vertical_position);
            else {
//              print("  slice_vertical_position " + slice_vertical_position);
            }
            if (vertical_size > 2800)
              print("Error - Program Limitation: Doesn't handle vertical_sizes > 2800");
            int mb_row, previous_macroblock_address;
            mb_row = slice_vertical_position - 1;
//            print("  mb_row " + mb_row);
            previous_macroblock_address = (mb_row * mb_width) - 1;
//            print("  slice reset: previous_macroblock_address " + previous_macroblock_address);
            int quantiser_scale_code;
            pops(5,quantiser_scale_code);
            UpdatePortal_quantiser_data_ac.setQuantiserScaleCode(quantiser_scale_code) [0:0];
            peeks(1,tempval);
            if (tempval == 1)
              print("Error - Program Limitation: Doesn't handle intra_slice_flag");
            pops(1,tempval);
            if (tempval == 1)
              print("Error - Extra_bit_slice must be 0");
            int[3] dc_dct_pred; // (cite 1, P.64-65)
                                // I'm not sure about this - see P. 64 and getpic.c Line 1180
                                // they disagree
            dc_dct_pred[0] = 0; // (int) pow(2,actual_intra_dc_precision - 1);
            dc_dct_pred[1] = 0; // (int) pow(2,actual_intra_dc_precision - 1);
            dc_dct_pred[2] = 0; // ( int) pow(2,actual_intra_dc_precision - 1);
            boolean macroblock_next = true;

            while (macroblock_next) {
              // macroblock() (cite 1, P. 35)
              int macroblock_escape = 0;
              peeks(11,tempval);
              while (tempval == 8) {
                pops(11,tempval);
                macroblock_escape += 33;
                peeks(11,tempval);
              }
 
              variable_length_code(tempval,const_macroblock_address_inc);

              int macroblock_address_increment = tempval + macroblock_escape;         
//              print("  macroblock_address_increment " + macroblock_address_increment);         
              int macroblock_address, mb_column;
              macroblock_address = previous_macroblock_address + macroblock_address_increment;
              previous_macroblock_address = macroblock_address;
//              print("  macroblock_address " + macroblock_address);
              mb_column = macroblock_address % mb_width;
//              print("  mb_column " + mb_column);
              // TODO - Don't actually check to make sure that macroblocks are skipped which aren't
              // allowed to be skipped - this should be done, the rules are on (cite 1, P. 60)
              // macroblock_modes, (cite 1, P.36)
              // TODO - If a sequence_scalable_extension present in bitstream, then may possibly
              // need to use tables B5,6,7,8 as well.
              if (picture_coding_type == 1) { // I-picture
                variable_length_code(tempval,const_macroblock_type_Ipictures);
              } else if (picture_coding_type == 2) { // P-picture
                variable_length_code(tempval,const_macroblock_type_Ppictures);
              } else if (picture_coding_type == 3) { // B-picture
                variable_length_code(tempval,const_macroblock_type_Bpictures);
              }
              int macroblock_quant, macroblock_motion_forward, macroblock_motion_backward, 
                  macroblock_pattern, macroblock_intra, spatial_temporal_weight_code_flag;
              spatial_temporal_weight_code_flag = tempval & 0x01;
              tempval >>= 1;
              macroblock_intra = tempval & 0x01;
              UpdatePortal_macroblock_intra.setMacroblockIntra(macroblock_intra) [0:0];
              tempval >>= 1;
              macroblock_pattern = tempval & 0x01;
              tempval >>= 1;
              macroblock_motion_backward = tempval & 0x01;
              tempval >>= 1;
              macroblock_motion_forward = tempval & 0x01;
              tempval >>= 1;
              macroblock_quant = tempval & 0x01;

              if (spatial_temporal_weight_code_flag == 1)
                print("Error - Program Limitation - Expects spatial_temporal_weight_code_flag to be 0");
              // (cite 1, P. 60, Table 6-17)
              int prediction_type = 0; // 0 = reserved, 1 = field-based, 2=frame-based, 3=dual-prime
              int motion_vector_count = 0;
              int mv_format = 0; // 0 = field, 1 = frame
              int dmv = 0; 
              if (frame_pred_frame_dct == 1) {
                // See comments on P.60 regarding what happens if frame_motion_type
                // is omitted.
                prediction_type = 2;
                motion_vector_count = 1;
                mv_format = 1;
                dmv = 0;
              }
              if (macroblock_motion_forward == 1 || macroblock_motion_backward == 1) {
                if (picture_structure == 3) {
                  if (frame_pred_frame_dct == 0) {
                    // (cite 1, P. 60, Table 6-17)
                    pops(2,tempval);
                    if (tempval == 0) {
                      print("Error - Invalid frame_motion_type code");
                    } else if (tempval == 1) {
                      if (spatial_temporal_weight_code_flag < 2) {
                        print("Error - Don't handle this case of frame_motion_type");
                      } else {
                        print("Error - Don't handle this case of frame_motion_type");
                      }
                    } else if (tempval == 2) {
                      prediction_type = 2;
                      motion_vector_count = 1;
                      mv_format = 1;
                      dmv = 0;
                    } else if (tempval == 3) {
                      prediction_type = 3;
                      motion_vector_count = 1;
                      mv_format = 0;
                      dmv = 1;
                    }
                    if (prediction_type == 0)
                      print("Error - Invalid prediction_type");
                    else if (prediction_type == 1)
                      print("  prediction_type field-based");
                    else if (prediction_type == 2)
                      print("  prediction_type frame-based");
                    else if (prediction_type == 3)
                      print("  prediction_type dual-prime");
                    print("  motion_vector_count " + motion_vector_count);
                    if (mv_format == 0)
                      print("  mv_format field");
                    else
                      print("  mv_format frame");
                    print("  dmv " + dmv);
                  }
                } else {
                  print("Error - Program Limitation: Doesn't handle this case");
                }
              }
              if ((picture_structure == 3) && (frame_pred_frame_dct == 0) && ((macroblock_intra == 1) || (macroblock_pattern == 1)))
                print("Error - Program Limitation, Doesn't Handle This Particular Case");

              if (macroblock_quant == 1) {
                pops(5,quantiser_scale_code);
                UpdatePortal_quantiser_data_ac.setQuantiserScaleCode(quantiser_scale_code) [0:0];
              }

              int[2][2][2] motion_code;
              int[2][2][2] motion_residual;
              for (int i = 0; i < 2; i++)
                 for (int j = 0; j < 2; j++)
                    for (int k = 0; k < 2; k++) {
                       motion_code[i][j][k] = 0;
                       motion_residual[i][j][k] = 0;
                    }

              // Motion Vector Predictor Reset, (cite 1, P.80)
              // TODO - Reset on skipped macroblocks, (cite 1, P.80)
              if ((macroblock_intra == 1 && concealment_motion_vectors == 1) ||
                  (macroblock_intra == 0 && macroblock_motion_forward == 0 && 
                   picture_coding_type == 2)) {
                for (int i = 0; i < 2; i++)
                  for (int j = 0; j < 2; j++)
                    for (int k = 0; k < 2; k++)
                      PMV[i][j][k] = 0;
              }

              if (macroblock_motion_forward == 1 || 
                  (macroblock_intra == 1 && concealment_motion_vectors == 1)) {
                // motion_vectors(0); (cite 1, P. 36, 61)
                if (motion_vector_count == 1) {
                  if ((mv_format == 0) && (dmv != 1)) {
                    print("Error - Program Limitation: Don't handle this case with mv_format and dmv.");
                    print("mv_format " + mv_format + " dmv " + dmv);
                  }
                  // motion_vector(0,0);
                  // (cite 1, P. 61)
                  for (int t = 0; t < 2; t++) {
                    variable_length_code(motion_code[0][0][t],const_motion_code);
                    if ((f_code[0][t] != 1) && (motion_code[0][0][t] != 0)) {
                      int r_size = f_code[0][t]-1;
                      print("r_size " + r_size);
                      pops(r_size,motion_residual[0][0][t]);
                    }
                    if (dmv == 1) {
                      print("Error - Program Limitation: Don't handle case of dmv = 1");
                    }
                  } 
                
                } else {
                  print("Error - Program Limitation: Don't handle field motion vectors");
                }
              }
              if (macroblock_motion_backward == 1) {
//                print("decoding backward motion vectors");
                
                // motion_vectors(1); (cite 1, P. 36, 61)
                if (motion_vector_count == 1) {
                  if ((mv_format == 0) && (dmv != 1)) {
                    print("Error - Program Limitation: Don't handle this case with mv_format and dmv.");
                    print("mv_format " + mv_format + " dmv " + dmv);
                  }
                  // motion_vector(0,1);
                  // (cite 1, P. 61)
                  for (int t = 0; t < 2; t++) {
                    variable_length_code(motion_code[0][1][t],const_motion_code);
                    if ((f_code[1][t] != 1) && (motion_code[0][1][t] != 0)) {
                      int r_size = f_code[1][t]-1;
                      print("r_size " + r_size);
                      pops(r_size,motion_residual[0][1][t]);
                    }
                    if (dmv == 1) {
                      print("Error - Program Limitation: Don't handle the case of dmv = 1");
                    }
                  }
                }
              }

              // Section 7.6.3.1 covers this - this might eventually be moved out of the
              // parser TODO - pretty much verbatim (cite 1, P. 77)
              int[2][2][2] vectorp, vector;
              for (int r = 0; r < 1; r++) {
                // NOTE TODO - Hacked right now, don't know when we need the second motion vector.
                for (int s = 0; s < 2; s++) {
                  for (int t = 0; t < 2; t++) {
                    if (((macroblock_motion_forward == 1 || 
                          (macroblock_intra == 1 && concealment_motion_vectors == 1)) &&
                         s == 0) ||
                        (macroblock_motion_backward == 1 &&
                         s == 1)) {
                      int r_size = f_code[s][t]-1;
                      int f = 1 << r_size;
                      int high = (16*f)-1;
                      int low = ((-16)*f);
                      int range = (32*f);
                      int delta;
                      if ((f == 1) || (motion_code[r][s][t] == 0))
                        delta = motion_code[r][s][t];
                      else {
                        delta = ((int) (abs(motion_code[r][s][t])-1)*f) + 
                                motion_residual[r][s][t]+1;
                        if (motion_code[r][s][t]<0)
                          delta = -delta;
                      }
                      int prediction = PMV[r][s][t];
                      if ((mv_format == 0) && (t == 1) && (picture_structure == 3))
                        print("Error - Program Limitation: May not be correct in decoding motion vectors");
                      vectorp[r][s][t] = prediction + delta;
                      if (vectorp[r][s][t] < low)
                        vectorp[r][s][t] = vectorp[r][s][t] + range;
                      if (vectorp[r][s][t] > high)
                        vectorp[r][s][t] = vectorp[r][s][t] - range;
                      if ((mv_format == 0) && (t == 1) && (picture_structure == 3))
                        print("Error - Program Limitation: May not be correct in decoding motion vectors");
                      else 
                        PMV[r][s][t] = vectorp[r][s][t];
                      // TODO handle updating missed motion_vectors
                      // section 7.6.3.3 
                    }
                  }
                  if ((macroblock_motion_forward == 1 || 
                        (macroblock_intra == 1 && concealment_motion_vectors == 1)) &&
                       s == 0) { 
//                     print("PMV = " + vectorp[r][s][0] + "," + vectorp[r][s][1]);
//                       UpdatePortal_motion_vectors.setForwardMotionVectors(vectorp[r][s][0],
//                                                                           vectorp[r][s][1]) [0:0];
                  }
                  if (macroblock_motion_backward == 1 && s == 1) {
//                     print("PMV = " + vectorp[r][s][0] + "," + vectorp[r][s][1]);
                  }
                }
              }

              if (count == 0 || count == 6) {
                // TODO ABOVE LINE HACK UNTIL FINE GRAINED WORKS
                UpdatePortal_motion_vectors_lum.setMotionVectors(vectorp) [0:0];
                UpdatePortal_motion_vectors_cr.setMotionVectors(vectorp) [0:0];
                UpdatePortal_motion_vectors_cb.setMotionVectors(vectorp) [0:0];
                print("UpdatePortal_motion_vectors getting called " + count);
              }

              if (macroblock_intra == 1 && concealment_motion_vectors == 1) {
                marker_bit();
              }
              int[12] pattern_code;
              if (macroblock_pattern == 1) {
                // coded_block_pattern() (cite 1, P. 37, 62)
                int cbp;
                variable_length_code(cbp,const_coded_block_patterns);
                if (chroma_format == 1 && cbp == 0) {
                  print("Error - cbp not allowed to be zero in 4:2:0 format");
                } else {
//                  print("  cbp " + cbp);
                }
                if (chroma_format != 1) {
                  print("Error - Program Limitation: Only handles 4:2:0 coded block patterns");
                }
                for (int i = 0; i < block_count; i++) {
                  // This seems backwards to me but this is how they do it in
                  // (2, getpic.c, Line 1186)
                  if ((cbp & (1 << (block_count-1-i))) > 0)
                    pattern_code[i] = 1;
                  else
                    pattern_code[i] = 0;
                }
              } else {
                // The meaning of pattern_code is defined somewhat poorly
                // on (cite 1, P.62) in the code block
                for (int i = 0; i < 12; i++) {
                  if (macroblock_intra == 1) {
                    pattern_code[i] = 1;
                  } else {
                    pattern_code[i] = 0;
                  }
                }
//                print("  All blocks present in macroblock");
              }
              for (int i = 0; i < block_count; i++) {
// NOTE                int[64] QFS; // Stores the quantized DCT coefficients
                int QFS_current;
                QFS_current = 0;
                for (int j = 0; j < 64; j++) {
                  QFS[j] = 0;
                } 

                // block(i) (cite 1, P.38)
                // Note - Assume all macroblocks exist for now, and pattern_code is always 1
                // if macroblocks are skipped, predictor is reset
                // TODO - reset predictors
                if (pattern_code[i] == 1) {
                  if (macroblock_intra == 1) {
                    if (i < 4) {
                      int dc_dct_size_luminance, dc_dct_differential_luminance, dc_dct_luminance;
                      variable_length_code(dc_dct_size_luminance,const_dct_dc_size_luminance);
//                      print("  dc_dct_size_luminance " + dc_dct_size_luminance);
                      int dct_diff; // This next section from (cite 1, P.65)
                      if (dc_dct_size_luminance == 0) {
                        dct_diff = 0;
                      } else {
                        pops(dc_dct_size_luminance,dc_dct_differential_luminance);
                        int half_range = (int) pow(2,dc_dct_size_luminance-1);
                        if (dc_dct_differential_luminance >= half_range) {
                          dct_diff = dc_dct_differential_luminance;
                        } else {
                          dct_diff = (dc_dct_differential_luminance + 1) - (2*half_range);
                        }
                      }
                      dc_dct_luminance = dc_dct_pred[0] + dct_diff;
                      dc_dct_pred[0] = dc_dct_luminance;
//                      print("  dc_dct_luminance " + dc_dct_luminance);
// disable this check for now TODO see previous discrepancy error comment
//                      if (dc_dct_luminance < 0 || dc_dct_luminance > (pow(2,actual_intra_dc_precision)-1))
//                         print("Error - Invalid dc_dct_luminance, something went wrong " + dc_dct_luminance);
                      QFS[0] = dc_dct_luminance;
                      QFS_current = 1;
                    } else {
                      // Other ones 
                      int dc_dct_size_chrominance, dc_dct_differential_chrominance, dc_dct_chrominance;
                      variable_length_code(dc_dct_size_chrominance,const_dct_dc_size_chrominance);
//                      print("  dc_dct_size_chrominance " + dc_dct_size_chrominance);
                      int dct_diff;
                      if (dc_dct_size_chrominance == 0) {
                        dct_diff = 0;
                      } else {
                        pops(dc_dct_size_chrominance,dc_dct_differential_chrominance);
                        int half_range = (int) pow(2,dc_dct_size_chrominance-1);
                        if (dc_dct_differential_chrominance >= half_range) {
                          dct_diff = dc_dct_differential_chrominance;
                        } else {
                          dct_diff = (dc_dct_differential_chrominance + 1) - (2*half_range);
                        }
                      }
                      dc_dct_chrominance = dc_dct_pred[i-3] + dct_diff;
                      dc_dct_pred[i-3] = dc_dct_chrominance;
//                      print("  dc_dct_chrominance " + dc_dct_chrominance);
// See similar error under luminance todo
//                      if (dc_dct_chrominance < 0 || dc_dct_chrominance > (pow(2,actual_intra_dc_precision)-1))
//                        print("Error - Invalid dc_dct_chrominance, something went wrong " + dc_dct_chrominance);
                      QFS[0] = dc_dct_chrominance;
                      QFS_current = 1;
                    }
                  } else {
                    // I don't think we really need to do anything here... if we let this just
                    // fall through it should get handled in the next section, right?
                    // Reset predictors, (cite 1, P. 64)
                    dc_dct_pred[0] = 0;
                    dc_dct_pred[1] = 0;
                    dc_dct_pred[2] = 0;  
                  }
                  if (intra_vlc_format == 1 && macroblock_intra == 1)
                    print("Error - Program Limitation: Need to use B15 to decode DCT coefficients instead of B14");
                  while (QFS_current < 64) {
                    if (macroblock_intra == 0 && QFS_current == 0) {
                      // This section here from end of Table B.14 and 7.2.2.2 (cite 1, P.66)
                      peeks(1,tempval);
                      if (tempval == 1) {
                        pops(1,tempval);
                        pops(1,tempval);
                        if (tempval == 0)
                          QFS[0] = 1;
                        else 
                          QFS[0] = -1;
                        QFS_current += 1;
                      }
                    } 
                    peeks(2,tempval);
                    if (tempval == 2) {
                      pops(2,tempval);
                      QFS_current = 64;
                    } else {
                      int signed_level, run;
                      peeks(6,tempval);
                      if (tempval == 1) {
                        pops(6,tempval);
//                        print("  Escape Code");
                        int level, sign;
                        pops(6,run);
                        pops(1,sign);
                        pops(11,level);

                        if (sign == 0) {
                          signed_level = level;
                        } else {
                          signed_level = level - 2048;
                        }
                      } else {
//                        print("  Regular Code");
                        int level, sign;
                        variable_length_code_dct(run,level,const_dct_coefficients_table_zero);
                        pops(1,sign);
                        if (sign == 0) {
                          signed_level = level;
                        } else {
                          signed_level = -level;
                        }
                      }
                      QFS_current += run;
                      if (QFS_current == 63) {
                        pops(2,tempval);
                        if (tempval != 2) {
                          print("Error - Reached End of Block, Expecting End of Block Code");
                        }
                      }
                      QFS[QFS_current] = signed_level;
                      QFS_current++;
                    }
                    if (QFS_current > 64)
                      print("Error - QFS_current > 64 " + QFS_current);
                  }
                  PushMacroblock();
                } else {
                  // Skipped block
                  // This indicates a skipped block, but not a skipped macroblock. 
                  // I don't THINK that we reset the vectors but TODO this is something to check.
                  // Notes on (cite 1, P. 80) and (cite 1, P. 62)
                  // We don't actually know that this block should just be 0, I couldn't find this
                  // in the spec anywhere. But I think this makes sense TODO verify that this is
                  // the case.
                  for (int index = 0; index < 64; index++) {
                    QFS[index] = 0;
                  }
                  PushMacroblock();
                }
              }

              peeks(23,tempval);
              if (tempval == 0) {
                macroblock_next = false;
              } else {
                macroblock_next = true;
              }
            }
 
            next_start_code();

            peeks(32,tempval);
            if (tempval > 0x000001AF || tempval < 0x00000101)
              slice_start_code_follows = false;
            else
              slice_start_code_follows = true;
          }

          next_start_code();
          peeks(32,tempval);

          if (tempval == 0x00000100 || tempval == 0x000001B8) {
            picture_or_group_start_code_found = true;
//            print("  Found another picture or group start code");
          } else {
            picture_or_group_start_code_found = false;
          }

        }

        peeks(32,tempval);
        if (tempval != 0x000001B7) {
          print("Error - Program Limitation: Don't handle repeated sequence headers and sequence extensions");
        }
  
        if (tempval != 0x000001B7) {
          sequence_end_code_not_found = true;
        } else {
          sequence_end_code_not_found = false;
        }
      }
      print("Done Parsing M2V File...");
    } else {
      print("Error - Trying to parse M2V file for a second time...");
    }
  }
}











