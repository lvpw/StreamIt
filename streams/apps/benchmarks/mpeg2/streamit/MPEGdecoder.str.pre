/*
 * Copyright 2005 by the Massachusetts Institute of Technology.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in
 * advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 */

/**
 * @description
 * This file contains functions that allow one to decode MPEG-2 compliant video. 
 * The code is based on the MPEG-2 specification (ISO/IEC 13818-2). The MPEG-2 decoding
 * is a work in progress, although it works within a limited test range. Throughout the 
 * source code, citations are made in cases where an understanding of the code would be
 * helped by looking at an outside source. The format I have chosen is 
 * (cite NUM#, LOOKUP_INFO). NUM=1 refers to ISO/IEC: 13818-2, and NUM=2 refers to the reference
 * MPEG implementation written in C, available at [www.mpeg.org].
 *
 * @author <a href="mailto:madrake@gmail.com">Matthew Drake</a>
 * @file MPEGdecoder.str.pre
 * @version 1.0
 */

// Comments for readers of the StreamIt MPEG specification:
//
// TODO notes refer to parts of the MPEG-2 specification which this
// program does not yet handle, or assumptions made by the program.
// FEATURETODO notes refer to changes that ought to be made to the program,
// or support which can be added for more of the MPEG-2 specification, which
// is pending the addition of features to the StreamIt language compiler.
// In general I have tried to document my code, and refer to the MPEG-2
// specification whenever I used it. If you are looking at any particular
// block of code and aren't sure what it is doing, find the previous citation
// comment, and refer to the corresponding page in the MPEG 2 spec.

/**
 * Interprets and decodes a compressed MPEG-2 compliant bit stream, in accordance
 * with the IEEE MPEG-2 specification.
 * @param width The resolution width of the video. This variable is only needed until the StreamIt
 *              language supports dynamically reconfiguring splijtoins.
 * @param height The resolution height of the video. This variable is only needed until the StreamIt
 *               language supports dynamically reconfiguring splitjoins.
 * @input An MPEG-2 compliant bit stream of variable length.
 * @output Outputs a series of images representing the frames of the video. Each image
 *         consists of 3 integers for each pixel, with the number of pixels per image 
 *         equalling the width * height of the video. Frames are output in time order,
 *         top to bottom, left to right, and RGB color order.
 */
bit->int pipeline MPEGStream_to_rawImageStream(int width, int height,
                                               int the_chroma_format) {
  // width, height, chroma: Hacked till we have reprogrammable splitjoins FEATURETODO

  portal<InverseQuantization_AC_Coeff> UpdatePortal_quantiser_data_ac;
  portal<InverseQuantizationJoinerSubstitute> UpdatePortal_macroblock_intra;
  portal<InverseQuantization_DC_Intra_Coeff> UpdatePortal_quantiser_data_dc;
  portal<MotionPrediction> UpdatePortal_picture_type;
  portal<MotionVectorDecode> UpdatePortal_mvd;
  portal<PictureReorder> UpdatePortal_picture_type2;
 
  add MPEGStreamParser(UpdatePortal_quantiser_data_ac,
                       UpdatePortal_quantiser_data_dc,
                       UpdatePortal_macroblock_intra,
                       UpdatePortal_picture_type,
                       UpdatePortal_mvd,
                       UpdatePortal_picture_type2,
                       width,
                       height,
                       the_chroma_format
                      );

  add int->int splitjoin {
    split roundrobin(64*blocks_per_macroblock[the_chroma_format], 16, 3);
    add BlockDecode(UpdatePortal_quantiser_data_ac, 
                    UpdatePortal_macroblock_intra, 
                    UpdatePortal_quantiser_data_dc);
    add int->int pipeline {
      add MotionVectorDecode() to UpdatePortal_mvd;
      add Repeat(8, blocks_per_macroblock[the_chroma_format]);
    }
    add Repeat(3, blocks_per_macroblock[the_chroma_format]); // macroblock_intra
    join roundrobin(64, 8, 3);
  }

  // Each output channel is ordered left to right, top to bottom

  // the following split within if drives a bug in Kopi2SIR
  //add int->int splitjoin {
  //  if (the_chroma_format == 1) {
  //    split roundrobin(4*75, 2*75);
  //  } else {
  //    split roundrobin(4*75, 4*75);
  //  }
  //  add LuminanceChannelProcessing(width, height, UpdatePortal_picture_type, the_chroma_format);
  //  add int->int splitjoin {
  //    split roundrobin(75);
  //    add ChrominanceChannelProcessing(width, height, UpdatePortal_picture_type, the_chroma_format);  
  //    add ChrominanceChannelProcessing(width, height, UpdatePortal_picture_type, the_chroma_format);  
  //    join roundrobin(1, 1);
  //  }
  //  join roundrobin(1, 2);
  //}

  // replacement code: wrap if around adds of separately-defined splitjoin's
  if (the_chroma_format == 1) {
      add LumChromFormatOne(width,height,UpdatePortal_picture_type,the_chroma_format);
  } else {
      add LumChromFormatOther(width,height,UpdatePortal_picture_type,the_chroma_format);
  }
 

  // FEATURETODO This next component should also use the UpdatePortal_picture_type
  // but it doesn't because of messaging limitations.
  add PictureReorder(width, height) to UpdatePortal_picture_type2;

  // This function assumes that no sequence display extension was ever
  // encountered in the data stream, and the default colorspace transformations 
  // apply.
  // (cite 1, P. 47, Table 6-9): Refer to entry 1, which is
  // Recommendation ITU-R BT.709 for transformations.
  add ColorSpaceConversion_YCbCrtoRGB;

}

// splitjoin pulled out above
int->int splitjoin LumChromFormatOne(int width, int height, 
				     portal<MotionPrediction> UpdatePortal_picture_type,
				     int the_chroma_format) {
    split roundrobin(4*75, 2*75);
    add LuminanceChannelProcessing(width, height, UpdatePortal_picture_type, the_chroma_format);
    add int->int splitjoin {
      split roundrobin(75);
      add ChrominanceChannelProcessing(width, height, UpdatePortal_picture_type, the_chroma_format);
      add ChrominanceChannelProcessing(width, height, UpdatePortal_picture_type, the_chroma_format);
      join roundrobin(1, 1);
    }
    join roundrobin(1, 2);
}

// splitjoin pulled out above
int->int splitjoin LumChromFormatOther(int width, int height, 
                                       portal<MotionPrediction> UpdatePortal_picture_type,
				       int the_chroma_format) {
    split roundrobin(4*75, 4*75);
    add LuminanceChannelProcessing(width, height, UpdatePortal_picture_type, the_chroma_format);
    add int->int splitjoin {
      split roundrobin(75);
      add ChrominanceChannelProcessing(width, height, UpdatePortal_picture_type, the_chroma_format);
      add ChrominanceChannelProcessing(width, height, UpdatePortal_picture_type, the_chroma_format);
      join roundrobin(1, 1);
    }
    join roundrobin(1, 2);
}

int->int splitjoin ReorderCrCbBlocks(int blocks_per_macroblock) {
  split roundrobin(75*4, 75*(blocks_per_macroblock-4));
  add Identity<int>;
  add int->int splitjoin {
    split roundrobin(75);
    add Identity<int>;
    add Identity<int>;
    join roundrobin(75*((blocks_per_macroblock-4)/2));
  } 
  join roundrobin(75*4, 75*(blocks_per_macroblock-4));
}

/**
 * @internal
 */
bit->int filter MPEGStreamParser(
                        portal<InverseQuantization_AC_Coeff> UpdatePortal_quantiser_data_ac,
                        portal<InverseQuantization_DC_Intra_Coeff> UpdatePortal_quantiser_data_dc,
                        portal<InverseQuantizationJoinerSubstitute> UpdatePortal_macroblock_intra,
                        portal<MotionPrediction> UpdatePortal_picture_type,
                        portal<MotionVectorDecode> UpdatePortal_mvd,
                        portal<PictureReorder> UpdatePortal_picture_type2,
                        int width,
                        int height,
                        int the_chroma_format) {
  // FEATURETODO
  // When phases can take parameters, get rid of this definition and
  // uncomment the definition in the filter work function, and change
  // the phase PushMacroblock() to use the parameter. 
  int b_per_m = blocks_per_macroblock[the_chroma_format];
  int[12][64] QFS; // Should be b_per_m, but b_per_m gets assigned later for some reason.
  int picture_coding_type;
  int macroblock_intra;
  int macroblock_motion_forward;
  int macroblock_motion_backward;
  int[2][2][2] motion_code;
  int[2][2][2] motion_residual;

  int ran;

  init {
    ran = 0;
  } 

  phase PushMacroblock push (b_per_m*64+19) {
    for (int i = 0; i < blocks_per_macroblock[the_chroma_format]; i++) {
      for (int j = 0; j < 64; j++) {
        push(QFS[i][j]);
      }
    }
    for (int r = 0; r < 2; r++) 
      for (int s = 0; s < 2; s++)
        for (int t = 0; t < 2; t++) {
            push(motion_code[r][s][t]);
        }
    for (int r = 0; r < 2; r++) 
      for (int s = 0; s < 2; s++)
        for (int t = 0; t < 2; t++) {
            push(motion_residual[r][s][t]);
        }
    push(macroblock_intra);
    push(macroblock_motion_forward);
    push(macroblock_motion_backward);
  }


//  Static work rate if using "../input/nomessage.m2v" as input -- maybe
//  work pop  624909 push (1320*(b_per_m*64+19)) 

  work pop * push * {  // Actually unknown pop/push rate
    if (ran == 0) {
      println("Parsing M2V File...");
      ran = 1;
 
      int tempval;

      // video_sequence() (cite 1, P. 25)

      next_start_code();

      // sequence_header() (cite 1, P. 26)

      pops(32,tempval);
      if (tempval != 0x000001B3)
        println("Error - Expected Video Sequence Start Code, Found " + tempval);

      // Reading Sequence Header
      int horizontal_size_value, vertical_size_value, aspect_ratio_information,
        frame_rate_code, bit_rate_value, vbv_buffer_size_value,
        constrained_parameters_flag, load_intra_quantiser_matrix, load_non_intra_quantiser_matrix;
      // (cite 1, P.55)
      pops(12,horizontal_size_value);
      pops(12,vertical_size_value);
      pops(4,aspect_ratio_information);
      // (cite 1, P.41 Table 6-3)
      if (aspect_ratio_information == 0)
        println("Error - Forbidden Aspect Ratio");
      else if (aspect_ratio_information == 1) {
         // aspect_ratio_information == 1 -> aspect ratio is 1:1, this case is handled
      } else {
        println("Error - Program Limitation: Don't Know How to Handle Other Aspect Ratios");
      }
      pops(4,frame_rate_code);
          // (cite 1, P.41-42 Table 6-4)
      float frame_rate_value = 0;
      if (frame_rate_code == 0)
        println("Error - Forbidden Frame Rate Code");
      else if (frame_rate_code == 4) {
        // frame_rate_code 4
        frame_rate_value = 30000.0/1001.0;
      }
      else 
        println("Error - Program Limitation: Don't Know How to Handle Other Frame Rate Codes");
      pops(18,bit_rate_value);
      marker_bit();

      pops(10,vbv_buffer_size_value);
      pops(1,constrained_parameters_flag);
      // (cite 1, P. 43)
      if (constrained_parameters_flag != 0)
        println("Error - Expected Constrained Parameters Flag To Be 0");
      // Default Values for the quantiser_matrices
      int[64] intra_quantiser_matrix = 
        { 8, 16, 19, 22, 26, 27, 29, 34,
         16, 16, 22, 24, 27, 29, 34, 37,
         19, 22, 26, 27, 29, 34, 34, 38,
         22, 22, 26, 27, 29, 34, 37, 40,
         22, 26, 27, 29, 32, 35, 40, 48,
         26, 27, 29, 32, 35, 40, 48, 58,
         26, 27, 29, 34, 38, 46, 56, 69,
         27, 29, 35, 38, 46, 56, 69, 83};
      int[64] non_intra_quantiser_matrix =
        {16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16};
      // Assumes no alternate_scan TODO
      int[64] Ordering = {00, 01, 05, 06, 14, 15, 27, 28,
                          02, 04, 07, 13, 16, 26, 29, 42,
				     	            03, 08, 12, 17, 25, 30, 41, 43,
					                09, 11, 18, 24, 31, 40, 44, 53,
					                10, 19, 23, 32, 39, 45, 52, 54,
					                20, 22, 33, 38, 46, 51, 55, 60,
					                21, 34, 37, 47, 50, 56, 59, 61,
					                35, 36, 48, 49, 57, 58, 62, 63};
      pops(1,load_intra_quantiser_matrix);
      if (load_intra_quantiser_matrix == 1) {
        // println("  Loading Intra Quantiser Matrix from File");    
        int[64] tempOrder;
        for (int i = 0; i < 64; i++) {
          pops(8,tempOrder[i]);
        }
        for (int i = 0; i < 64; i++) {
          // Assumes no alternate_scan TODO
          intra_quantiser_matrix[i] = tempOrder[Ordering[i]];
        }
       } else {
        // println("  Using Default Intra Quantiser Matrix");
        // Default Values Previously Loaded
      }
      pops(1,load_non_intra_quantiser_matrix);
      if (load_non_intra_quantiser_matrix == 1) {
        // println("  Loading Non Intra Quantiser Matrix from File");
        int[64] tempOrder;
        for (int i = 0; i < 64; i++) {
          pops(8,tempOrder[i]);
        }
        for (int i = 0; i < 64; i++) {
          // Assumes no alternate_scan
          non_intra_quantiser_matrix[i] = tempOrder[Ordering[i]];
        }
      } else {
        // println("  Using Default Non Intra Quantiser Matrix");
        // Default Values Previously Loaded
      }
      UpdatePortal_quantiser_data_ac.setQuantiserMatrices(intra_quantiser_matrix,
                                                          non_intra_quantiser_matrix) [0:0]; 
      next_start_code();

      // sequence_extension() (cite 1, P. 28)

      pops(32,tempval);
      if (tempval != 0x000001B5)
        println("Error - Expected Extension Start Code, File Must be MPEG-1 " + tempval);
      int extension_start_code_identifier, profile_and_level_indication,
          progressive_sequence, chroma_format, horizontal_size_extension,
          vertical_size_extension, bit_rate_extension, vbv_buffer_size_extension,
          low_delay, frame_rate_extension_n, frame_rate_extension_d;
      pops(4,extension_start_code_identifier);
      if (extension_start_code_identifier != 0x1)
        println("Error - Expected Sequence Extension Identifier " + extension_start_code_identifier);
      pops(8,profile_and_level_indication);
      // We don't really care about the profile_and_level indicator - this matters if this implementation
      // were fully MPEG2 compliant to some profile/level, but it isn't.
      pops(1,progressive_sequence);
      if (progressive_sequence == 1) {
        // progressive_sequence 1: allows only progressive frames
      } else {
        // progressive_sequence 0: allows interlaced and progressive frames
        println("Error - Program Limitation: Don't handle interlaced frames");
      }
      pops(2,chroma_format);
      int block_count = blocks_per_macroblock[the_chroma_format]; // (cite 1, P. 62)
      if (chroma_format != the_chroma_format) {
        println("Error - Program specified with chroma " + the_chroma_format);
        println("        File has chroma " + chroma_format);
      }
      pops(2,horizontal_size_extension);
      int horizontal_size = horizontal_size_value + (horizontal_size_extension << 12);
      int mb_width = (horizontal_size + 15) / 16;
      pops(2,vertical_size_extension);
      int vertical_size = vertical_size_value +  (vertical_size_extension << 12);
      int mb_height = (vertical_size + 15) / 16;
      pops(12,bit_rate_extension);
      // (cite 1, P.42)
      int bit_rate = 400 * (bit_rate_value + (bit_rate_extension << 18));
      marker_bit();
      pops(8,vbv_buffer_size_extension);
      int vbv_buffer_size = vbv_buffer_size_value + (vbv_buffer_size_extension << 10);
      pops(1,low_delay);
      if (low_delay == 1) {
        // low_delay 1 indicates that sequence contains no B-pictures
        println("Error - Program Limitation: Can't Handle This Case Yet");
      } else {
        // low_delay 0 indicates that sequence is allowed to contain B-pictures
      }

      pops(2,frame_rate_extension_n);
      pops(5,frame_rate_extension_d);
      // (cite 1, P. P.41)
      float frame_rate = frame_rate_value * 
        ((float) (frame_rate_extension_n + 1)) / ((float) (frame_rate_extension_d + 1));
      next_start_code();

      boolean sequence_end_code_not_found = true;
      while (sequence_end_code_not_found) {
        // extension_and_user_data(0) (cite 1, P.26)
        peeks(32,tempval);
        while (tempval == 0x000001B5 || tempval == 0x000001B2) {
          pops(32,tempval);
          if (tempval == 0x000001B5) {
          // extension_data(0) (cite 1, P.27)
            peeks(4, tempval); 
            if (tempval == 2) { // extension_start_code_identifier
              pops(4, tempval); 
              int video_format;
              pops(3, video_format);
              int color_description;
              pops(1, color_description);
              if (color_description == 1) {
                int color_primaries, transfer_characteristics, matrix_coefficients;
                pops(8, color_primaries);
                pops(8, transfer_characteristics);
                pops(8, matrix_coefficients);
              }
              int display_horizontal_size;
              pops(14, display_horizontal_size);
              marker_bit();
              int display_vertical_size;
              pops(14, display_vertical_size);
              // TODO - we don't do anything with this extra data we get out. Eventually we should.
              next_start_code();
            } else {
              println("Error - Program Limitation: Not Yet Support for Sequence Scalable Extension()");
            }
          } else { // user_data() (cite 1, P.27)      
            if (tempval != 0x000001B2) {
              println("Error - Program Limitation: Not Yet Support for User_Data()");
            } 
            peeks(24, tempval);
            while (tempval != 0x000001) {
              int user_data;
              pops(8, user_data);
              // TODO we should probably do something with this data
              peeks(24, tempval);
            }
            next_start_code();
          }
          peeks(32,tempval);
        }
        
        boolean picture_or_group_start_code_found = true;
        while (picture_or_group_start_code_found) {
          peeks(32,tempval);
          if (tempval == 0x000001B8) {
            // group_of_pictures_header() (cite 1, P.29)
            pops(32,tempval);
            int drop_frame_flag, time_code_hours, time_code_minutes, time_code_seconds, 
                time_code_pictures, closed_gop, broken_link;
            // -- Time Code - Not Used in Decoding Process --
            // (cite 1, P.49)
            pops(1,drop_frame_flag);
            pops(5,time_code_hours);
            pops(6,time_code_minutes);
            marker_bit();
            pops(6,time_code_seconds);
            pops(6,time_code_pictures);
            // -- End of Time Code
     
            pops(1,closed_gop);
            pops(1,broken_link);
            if (broken_link == 1)
              println("Error - Program Limitation: broken_link = 1");
            next_start_code();
            // extension_and_user_data(1) (cite 1, P.26)
            peeks(32,tempval);
            if (tempval == 0x000001B5 || tempval == 0x000001B2)
              println("Error - Program Limitation: Not Yet Support for extension_and_user_data(1)");
          }
 
          // picture_header() (cite 1, P.30)
          pops(32,tempval);
          if (tempval != 0x00000100) {
            println("Error - Picture Start Code Expected, " + tempval);
          }

          int temporal_reference, /* FEATURETODO picture_coding_type, */ vbv_delay, full_pel_forward_vector,
              forward_f_code, full_pel_backward_vector, backward_f_code;
          // (cite 1, P.50) for interpretation of the following fields
          pops(10,temporal_reference);
          pops(3,picture_coding_type);
          if (picture_coding_type == 1) {
            // picture_coding_type = I-picture
          } else if (picture_coding_type == 2) {
            // picture_coding_type = P-picture
          } else if (picture_coding_type == 3) {
            // picture_coding_type = B-picture
          } else {
            println("  Error: Forbidden picture_coding_type " + picture_coding_type);
          }
          UpdatePortal_picture_type.setPictureType(picture_coding_type) [0:0];
          UpdatePortal_picture_type2.setPictureType(picture_coding_type) [0:0];
 
         pops(16,vbv_delay);
          // TODO unknown interpretation for vbv_delay, (cite 1, P.50)
          // The following is not used by the MPEG-2 specification (cite 1, P.51)
          // Supposed to have certain values, but not guaranteed for most files.
          if (picture_coding_type == 2 || picture_coding_type == 3) {
            pops(1,full_pel_forward_vector);
            pops(3,forward_f_code);
          } 
          if (picture_coding_type == 3) {
            pops(1,full_pel_backward_vector);
            pops(3,backward_f_code);
          }
          pops(1,tempval);
          if (tempval == 1)
            println("Error: File conforms to some superset of the MPEG-2 specification");
          next_start_code();
            
          // picture_coding_extension() (cite 1, P.30)
          pops(32,tempval);
          if (tempval != 0x000001B5)
            println("Error - Expecting extension start code " + tempval);
          pops(4,extension_start_code_identifier);
          if (extension_start_code_identifier != 0x8)
            println("Error - Expecting picture coding extension ID " + extension_start_code_identifier);
          int[2][2] f_code;
          pops(4,f_code[0][0]);
          pops(4,f_code[0][1]);
          pops(4,f_code[1][0]);
          pops(4,f_code[1][1]);
          UpdatePortal_mvd.setFCode(f_code) [0:0];
          // (cite 1, P.51)
          for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
              if (f_code[i][j] == 0 || (f_code[i][j] >= 10 && f_code[i][j] <= 14))
                println("Error - Invalid f_code");
              if (picture_coding_type == 1 && f_code[i][j] != 0xF)
                println("Error - Program Limitation: I-frame has motion prediction");
              if (picture_coding_type == 2 && f_code[1][j] != 0xF)
                println("Error - Program Limitation: P-frame has backward motion prediction");
            }
          }
          int intra_dc_precision, picture_structure, top_field_first, frame_pred_frame_dct, 
              concealment_motion_vectors, q_scale_type, intra_vlc_format, alternate_scan, 
              repeat_first_field, chroma_420_type, progressive_frame, composite_display_flag;
          pops(2,intra_dc_precision);
          UpdatePortal_quantiser_data_dc.setIntraDCPrecision(intra_dc_precision);
          int actual_intra_dc_precision = intra_dc_precision + 8;
          pops(2,picture_structure);
          if (picture_structure != 3)
            println("Error - Program Limitation: Interlaced or bad picture structure");
          pops(1,top_field_first); // Interpreted Later
          pops(1,frame_pred_frame_dct);
          if (frame_pred_frame_dct != 1) 
            println("Error - Program Limitation or Bad Syntax: frame_pred_frame_dct must be 1");
          pops(1,concealment_motion_vectors);
          pops(1,q_scale_type);
          UpdatePortal_quantiser_data_ac.setQScaleType(q_scale_type) [0:0];
          pops(1,intra_vlc_format);
          pops(1,alternate_scan);
          if (alternate_scan == 1)
            println("Error - Program Limitation - Doesn't handle alternate_scan right now");
          pops(1,repeat_first_field);
          // TODO Assumes progressive_sequence = 1
          if (repeat_first_field == 0) {
            //  repeat_first_field = 0, one frame output
          }
          else {
            if (top_field_first == 0)
              println("  repeat_first_field = 1, top_field_first = 0, two frames output");
            else
              println("  repeat_first_field = 1, top_field_first = 1, three frames output");
          }
          pops(1,chroma_420_type);
          // We don't really care about this, although it should be 1 for 4:2:0 chroma.
          // (cite 1, P.53)
          pops(1,progressive_frame);
          // Again, I don't think we care too much about this value, since we assume only a
          // base stream exists.
          pops(1,composite_display_flag);
          if (composite_display_flag == 1) {
            println("Error - Program Limitation: Assumes no composite display information");
          } else {
            // composite_display_flag - not present
          }
          next_start_code();
         
          // extension_and_user_data(2)
          peeks(32,tempval);
          if (tempval == 0x000001B5 || tempval == 0x000001B2)
            println("Error - Program Limitation: Not Yet Support for extension_and_user_data(2)");
          
          // picture_data() (cite 1, P.34)
          boolean slice_start_code_follows = true;
          while (slice_start_code_follows) {
            // slice() (cite 1, P.34)
            // Reset motion vector predictors, (cite 1, P.77-80)
            UpdatePortal_mvd.resetPredictors() [0:0];
            pops(24,tempval);
            if (tempval != 0x000001) 
              println("Error - Expecting slice_start_code " + tempval);
            int slice_vertical_position;
            pops(8,slice_vertical_position);
            if (slice_vertical_position < 0x01 || slice_vertical_position > 0xAF)
              println("Error - Invalid slice_vertical_position" + slice_vertical_position);
            if (vertical_size > 2800)
              println("Error - Program Limitation: Doesn't handle vertical_sizes > 2800");
            int mb_row, previous_macroblock_address;
            mb_row = slice_vertical_position - 1;
            previous_macroblock_address = (mb_row * mb_width) - 1;
            int quantiser_scale_code;
            pops(5,quantiser_scale_code);
            UpdatePortal_quantiser_data_ac.setQuantiserScaleCode(quantiser_scale_code) [0:0];
            peeks(1,tempval);
            if (tempval == 1)
              println("Error - Program Limitation: Doesn't handle intra_slice_flag");
            pops(1,tempval);
            if (tempval == 1)
              println("Error - Extra_bit_slice must be 0");
            int[3] dc_dct_pred; // (cite 1, P.64-65)
                                // I'm not sure about this - see P. 64 and getpic.c Line 1180
                                // they disagree TODO
            dc_dct_pred[0] = 0; // (int) pow(2,actual_intra_dc_precision - 1);
            dc_dct_pred[1] = 0; // (int) pow(2,actual_intra_dc_precision - 1);
            dc_dct_pred[2] = 0; // (int) pow(2,actual_intra_dc_precision - 1);
            boolean macroblock_next = true;

            while (macroblock_next) {
              // macroblock() (cite 1, P.35)
              int macroblock_escape = 0;
              peeks(11,tempval);
              while (tempval == 8) {
                pops(11,tempval);
                macroblock_escape += 33;
                peeks(11,tempval);
              }
              
              variable_length_code(tempval,const_macroblock_address_inc);
              int macroblock_address_increment = tempval + macroblock_escape;         
              int macroblock_address, mb_column;
              macroblock_address = previous_macroblock_address + macroblock_address_increment;
              previous_macroblock_address = macroblock_address;
              mb_column = macroblock_address % mb_width;
              // TODO - Don't actually check to make sure that macroblocks are skipped which aren't
              // allowed to be skipped - this should be done, the rules are on (cite 1, P.60)
              // macroblock_modes, (cite 1, P.36)
              // TODO - If a sequence_scalable_extension present in bitstream, then may possibly
              // need to use tables B5,6,7,8 as well.

              if (picture_coding_type == 1) { // I-picture
                variable_length_code(tempval,const_macroblock_type_Ipictures);
              } else if (picture_coding_type == 2) { // P-picture
                variable_length_code(tempval,const_macroblock_type_Ppictures);
              } else if (picture_coding_type == 3) { // B-picture
                variable_length_code(tempval,const_macroblock_type_Bpictures);
              }
              int macroblock_quant, /* macroblock_motion_forward, macroblock_motion_backward, */
                  macroblock_pattern, /* macroblock_intra, */ spatial_temporal_weight_code_flag;
              spatial_temporal_weight_code_flag = tempval & 0x01;
              tempval >>= 1;
              macroblock_intra = tempval & 0x01;
              UpdatePortal_macroblock_intra.setMacroblockIntra(macroblock_intra) [0:0];
              tempval >>= 1;
              macroblock_pattern = tempval & 0x01;
              tempval >>= 1;
              macroblock_motion_backward = tempval & 0x01;
              tempval >>= 1;
              macroblock_motion_forward = tempval & 0x01;
              tempval >>= 1;
              macroblock_quant = tempval & 0x01;

              if (spatial_temporal_weight_code_flag == 1)
                println("Error - Program Limitation - Expects spatial_temporal_weight_code_flag to be 0");
              // (cite 1, P.60, Table 6-17)
              int prediction_type = 0; // 0 = reserved, 1 = field-based, 2=frame-based, 3=dual-prime
              int motion_vector_count = 0;
              int mv_format = 0; // 0 = field, 1 = frame
              int dmv = 0; 
              if (frame_pred_frame_dct == 1) {
                // See comments on P.60 regarding what happens if frame_motion_type
                // is omitted.
                prediction_type = 2;
                motion_vector_count = 1;
                mv_format = 1;
                dmv = 0;
              }
              if (macroblock_motion_forward == 1 || macroblock_motion_backward == 1) {
                if (picture_structure == 3) {
                  if (frame_pred_frame_dct == 0) {
                    // (cite 1, P.60, Table 6-17)
                    pops(2,tempval);
                    if (tempval == 0) {
                      println("Error - Invalid frame_motion_type code");
                    } else if (tempval == 1) {
                      if (spatial_temporal_weight_code_flag < 2) {
                        println("Error - Don't handle this case of frame_motion_type");
                      } else {
                        println("Error - Don't handle this case of frame_motion_type");
                      }
                    } else if (tempval == 2) {
                      prediction_type = 2;
                      motion_vector_count = 1;
                      mv_format = 1;
                      dmv = 0;
                    } else if (tempval == 3) {
                      prediction_type = 3;
                      motion_vector_count = 1;
                      mv_format = 0;
                      dmv = 1;
                    }
                    if (prediction_type == 0)
                      println("Error - Invalid prediction_type");
                    else if (prediction_type == 1)
                      println("  prediction_type field-based");
                    else if (prediction_type == 2)
                      println("  prediction_type frame-based");
                    else if (prediction_type == 3)
                      println("  prediction_type dual-prime");
                    println("  motion_vector_count " + motion_vector_count);
                    if (mv_format == 0)
                      println("  mv_format field");
                    else
                      println("  mv_format frame");
                    println("  dmv " + dmv);
                  }
                } else {
                  println("Error - Program Limitation: Doesn't handle this case");
                }
              }
              if ((picture_structure == 3) && (frame_pred_frame_dct == 0) && ((macroblock_intra == 1) || (macroblock_pattern == 1)))
                println("Error - Program Limitation, Doesn't Handle This Particular Case");

              if (macroblock_quant == 1) {
                pops(5,quantiser_scale_code);
                UpdatePortal_quantiser_data_ac.setQuantiserScaleCode(quantiser_scale_code) [0:0];
              }

/*            int[2][2][2] motion_code;
              int[2][2][2] motion_residual; FEATURETODO */
              for (int i = 0; i < 2; i++)
                 for (int j = 0; j < 2; j++)
                    for (int k = 0; k < 2; k++) {
                       motion_code[i][j][k] = 0;
                       motion_residual[i][j][k] = 0;
                    }

              // Motion Vector Predictor Reset, (cite 1, P.80)
              if ((macroblock_intra == 1 && concealment_motion_vectors == 0) ||
                  (macroblock_intra == 0 && macroblock_motion_forward == 0 && 
                   picture_coding_type == 2)) {
                UpdatePortal_mvd.resetPredictors() [0:0];  
              }

              if (macroblock_motion_forward == 1 || 
                  (macroblock_intra == 1 && concealment_motion_vectors == 1)) {
                // motion_vectors(0); (cite 1, P.36, 61)
                if (motion_vector_count == 1) {
                  if ((mv_format == 0) && (dmv != 1)) {
                    println("Error - Program Limitation: Don't handle this case with mv_format and dmv.");
                    println("mv_format " + mv_format + " dmv " + dmv);
                  }
                  // motion_vector(0,0);
                  // (cite 1, P.61)
                  for (int t = 0; t < 2; t++) {
                    variable_length_code(motion_code[0][0][t],const_motion_code);
                    if ((f_code[0][t] != 1) && (motion_code[0][0][t] != 0)) {
                      int r_size = f_code[0][t]-1;
                      pops(r_size,motion_residual[0][0][t]);
                    }
                    if (dmv == 1) {
                      println("Error - Program Limitation: Don't handle case of dmv = 1");
                    }
                  } 
                
                } else {
                  println("Error - Program Limitation: Don't handle field motion vectors");
                }
              }
              if (macroblock_motion_backward == 1) {
                
                // motion_vectors(1); (cite 1, P.36, 61)
                if (motion_vector_count == 1) {
                  if ((mv_format == 0) && (dmv != 1)) {
                    println("Error - Program Limitation: Don't handle this case with mv_format and dmv.");
                    println("mv_format " + mv_format + " dmv " + dmv);
                  }
                  // motion_vector(0,1);
                  // (cite 1, P.61)
                  for (int t = 0; t < 2; t++) {
                    variable_length_code(motion_code[0][1][t],const_motion_code);
                    if ((f_code[1][t] != 1) && (motion_code[0][1][t] != 0)) {
                      int r_size = f_code[1][t]-1;
                      pops(r_size,motion_residual[0][1][t]);
                    }
                    if (dmv == 1) {
                      println("Error - Program Limitation: Don't handle the case of dmv = 1");
                    }
                  }
                }
              }

              if (macroblock_intra == 1 && concealment_motion_vectors == 1) {
                marker_bit();
              }

              int[12] pattern_code;
              // The meaning of pattern_code is defined somewhat poorly
              // on (cite 1, P.62) in the code block
              for (int i = 0; i < 12; i++) {
                if (macroblock_intra == 1) {
                  pattern_code[i] = 1;
                } else {
                  pattern_code[i] = 0;
                }
              }
              if (macroblock_pattern == 1) {
                // coded_block_pattern() (cite 1, P.37, 62)
                int cbp;
                variable_length_code(cbp,const_coded_block_patterns);
                for (int i = 0; i < 6; i++) {
                  if ((cbp & (1 << (5-i))) > 0)
                    pattern_code[i] = 1;
                }
                if (chroma_format == 1 && cbp == 0) {
                  println("Error - cbp not allowed to be zero in 4:2:0 format");
                }
                if (chroma_format == 2) {
                  int coded_block_pattern_1;
                  pops(2, coded_block_pattern_1);
                  for (int i = 6; i < 8; i++) {
                    if ((coded_block_pattern_1 & (1<< (7-i))) > 0)
                      pattern_code[i] = 1;
                  }
                }
                if (chroma_format == 3) {
                  println("Error - Program Limitation: Doesn't handle 4:4:4 format");
                }
              }

              for (int i = 0; i < block_count; i++) {
                int QFS_current;
                QFS_current = 0;
                for (int j = 0; j < 64; j++) {
                  QFS[i][j] = 0;
                } 

                // block(i) (cite 1, P.38)
                // if macroblocks are skipped, predictor is reset
                if (pattern_code[i] == 1) {
                  if (macroblock_intra == 1) {
                    if (i < 4) {
                      int dc_dct_size_luminance, dc_dct_differential_luminance, dc_dct_luminance;
                      variable_length_code(dc_dct_size_luminance,const_dct_dc_size_luminance);
                      int dct_diff; // This next section from (cite 1, P.65)
                      if (dc_dct_size_luminance == 0) {
                        dct_diff = 0;
                      } else {
                        pops(dc_dct_size_luminance,dc_dct_differential_luminance);
                        int half_range = (int) pow(2,dc_dct_size_luminance-1);
                        if (dc_dct_differential_luminance >= half_range) {
                          dct_diff = dc_dct_differential_luminance;
                        } else {
                          dct_diff = (dc_dct_differential_luminance + 1) - (2*half_range);
                        }
                      }
                      dc_dct_luminance = dc_dct_pred[0] + dct_diff;
                      dc_dct_pred[0] = dc_dct_luminance;
                      QFS[i][0] = dc_dct_luminance;
                      QFS_current = 1;
                    } else {
                      // Other ones 
                      int dc_dct_size_chrominance, dc_dct_differential_chrominance, dc_dct_chrominance;
                      variable_length_code(dc_dct_size_chrominance,const_dct_dc_size_chrominance);
                      int dct_diff;
                      if (dc_dct_size_chrominance == 0) {
                        dct_diff = 0;
                      } else {
                        pops(dc_dct_size_chrominance,dc_dct_differential_chrominance);
                        int half_range = (int) pow(2,dc_dct_size_chrominance-1);
                        if (dc_dct_differential_chrominance >= half_range) {
                          dct_diff = dc_dct_differential_chrominance;
                        } else {
                          dct_diff = (dc_dct_differential_chrominance + 1) - (2*half_range);
                        }
                      }
                      // Blocks 4, 6, 8, and 10 go into [1]
                      // Blocks 5, 7, 9, 11 go into [2]
                      int temp_index = (i % 2) + 1;
                      dc_dct_chrominance = dc_dct_pred[temp_index] + dct_diff;
                      dc_dct_pred[temp_index] = dc_dct_chrominance;
                      QFS[i][0] = dc_dct_chrominance;
                      QFS_current = 1;
                    }
                  } else {
                    // I don't think we really need to do anything here... if we let this just
                    // fall through it should get handled in the next section, right?
                    // Reset predictors, (cite 1, P. 64)
                    dc_dct_pred[0] = 0;
                    dc_dct_pred[1] = 0;
                    dc_dct_pred[2] = 0;  
                  }
                  if (intra_vlc_format == 1 && macroblock_intra == 1)
                    println("Error - Program Limitation: Need to use B15 to decode DCT coefficients instead of B14");
                  while (QFS_current < 64) {
                    if (macroblock_intra == 0 && QFS_current == 0) {
                      // This section here from end of Table B.14 and 7.2.2.2 (cite 1, P.66)
                      peeks(1,tempval);
                      if (tempval == 1) {
                        pops(1,tempval);
                        pops(1,tempval);
                        if (tempval == 0)
                          QFS[i][0] = 1;
                        else 
                          QFS[i][0] = -1;
                        QFS_current += 1;
                      }
                    } 
                    peeks(2,tempval);
                    if (tempval == 2) {
                      pops(2,tempval);
                      QFS_current = 64;
                    } else {
                      int signed_level = 0;
                      int run = 0;
                      peeks(6,tempval);
                      if (tempval == 1) { 
                        // Escape Code
                        pops(6,tempval);
                        int level = 0;
                        int sign = 0;
                        pops(6,run);
                        pops(1,sign);
                        pops(11,level);
                        if (sign == 0) {
                          signed_level = level;
                        } else {
                          signed_level = level - 2048;
                        }
                      } else {
                        // Regular Code
                        int level = 0;
                        int sign = 0;
                        // The old. inefficient way: v ariable_length_code_dct(run,level,const_dct_coefficients_table_zero);
                        // begin variable length code
                        peeks(16, tempval);
                        // if (tempval >= 49152 && tempval <= 65535) { // 2
                        if (tempval >= 49152) {
                            pops(2, tempval);
                            run = const_dct_coefficients_table_zero_len2[0].run;
                            level = const_dct_coefficients_table_zero_len2[0].level; 
                            // } else if (tempval >= 24576 && tempval <= 32767) { // 3
                        } else if (tempval >= 24576) {
                            pops(3, tempval);
                            run = const_dct_coefficients_table_zero_len3[0].run;
                            level = const_dct_coefficients_table_zero_len3[0].level; 
                            // } else if (tempval >= 16384 && tempval <= 24575) { // 4
                        } else if (tempval >= 16384) {
                            pops(4, tempval);
                            run = const_dct_coefficients_table_zero_len4[tempval-4].run;
                            level = const_dct_coefficients_table_zero_len4[tempval-4].level; 
                            // } else if (tempval >= 10240 && tempval <= 16383) { // 5
                        } else if (tempval >= 10240) {
                            pops(5, tempval);
                            run = const_dct_coefficients_table_zero_len5[tempval-5].run;
                            level = const_dct_coefficients_table_zero_len5[tempval-5].level; 
                            // } else if (tempval >= 8192 && tempval <= 10239) { // 8
                        } else if ( tempval >= 8192) {
                            pops(8, tempval);
                            run = const_dct_coefficients_table_zero_len8[tempval-32].run;
                            level = const_dct_coefficients_table_zero_len8[tempval-32].level; 
                            // } else if (tempval >= 4096 && tempval <= 8191) { // 6
                        } else if (tempval >= 4096) {
                            pops(6, tempval);
                            run = const_dct_coefficients_table_zero_len6[tempval-4].run;
                            level = const_dct_coefficients_table_zero_len6[tempval-4].level; 
                            // } else if (tempval >= 2048 && tempval <= 4095) { // 7
                        } else if (tempval >= 2048) {
                            pops(7, tempval);
                            run = const_dct_coefficients_table_zero_len7[tempval-4].run;
                            level = const_dct_coefficients_table_zero_len7[tempval-4].level; 
                            // } else if (tempval >= 512 && tempval <= 1023) { // 10
                        } else if (tempval >= 512) {
                            pops(10, tempval);
                            run = const_dct_coefficients_table_zero_len10[tempval-8].run;
                            level = const_dct_coefficients_table_zero_len10[tempval-8].level; 
                            // } else if (tempval >= 256 && tempval <= 511) { // 12
                        } else if (tempval >= 256) {
                            pops(12, tempval); 
                            run = const_dct_coefficients_table_zero_len12[tempval-16].run;
                            level = const_dct_coefficients_table_zero_len12[tempval-16].level; 
                            // } else if (tempval >= 128 && tempval <= 255) { // 13
                        } else if (tempval >= 128) {
                            pops(13, tempval); 
                            run = const_dct_coefficients_table_zero_len13[tempval-16].run;
                            level = const_dct_coefficients_table_zero_len13[tempval-16].level; 
                            // } else if (tempval >= 64 && tempval <= 127) { // 14
                        } else if (tempval >= 64) {
                            pops(14, tempval); 
                            run = const_dct_coefficients_table_zero_len14[tempval-16].run;
                            level = const_dct_coefficients_table_zero_len14[tempval-16].level; 
                            // } else if (tempval >= 32 && tempval <= 63) { // 15
                        } else if (tempval >= 32) {
                            pops(15, tempval); 
                            run = const_dct_coefficients_table_zero_len15[tempval-16].run;
                            level = const_dct_coefficients_table_zero_len15[tempval-16].level; 
                            // } else if (tempval >= 16 && tempval <= 31) { // 16
                        } else if (tempval >= 16) {
                            pops(16, tempval);
                            run = const_dct_coefficients_table_zero_len16[tempval-16].run;
                            level = const_dct_coefficients_table_zero_len16[tempval-16].level; 
                        }  else {
                            print("Error - Unknown Huffman Symbol");
                        }
                        // end variable length code

                        pops(1,sign);
                        if (sign == 0) {
                          signed_level = level;
                        } else {
                          signed_level = -level;
                        }
                      }
                      QFS_current += run;
                      if (QFS_current == 63) {
                        pops(2,tempval);
                        if (tempval != 2) {
                          println("Error - Reached End of Block, Expecting End of Block Code");
                        }
                      }
                      QFS[i][QFS_current] = signed_level;
                      QFS_current++;
                    }
                    if (QFS_current > 64)
                      println("Error - QFS_current > 64 " + QFS_current);
                  }
                } else {
                  // Skipped block
                  // This indicates a skipped block, but not a skipped macroblock. 
                  for (int index = 0; index < 64; index++) {
                    QFS[i][index] = 0;
                  }
                }
              }
              PushMacroblock();
              peeks(23,tempval);
              if (tempval == 0) {
                macroblock_next = false;
              } else {
                macroblock_next = true;
              }
            }
 
            next_start_code();
            peeks(32,tempval);
            if (tempval > 0x000001AF || tempval < 0x00000101)
              slice_start_code_follows = false;
            else
              slice_start_code_follows = true;
          }
          next_start_code();
          peeks(32,tempval);

          if (tempval == 0x00000100 || tempval == 0x000001B8) {
            picture_or_group_start_code_found = true;
          } else {
            picture_or_group_start_code_found = false;
          }

        }

        peeks(32,tempval);
        if (tempval != 0x000001B7) {
          println("Error - Program Limitation: Don't handle repeated sequence headers and sequence extensions");
        }
  
        if (tempval != 0x000001B7) {
          sequence_end_code_not_found = true;
        } else {
          sequence_end_code_not_found = false;
        }
      }
      println("Done Parsing M2V File...");
    } else if (ran == 1) {
      println("Generating fake last frame to push out last real frame of video.");
      ran = 2;
      UpdatePortal_picture_type.setPictureType(1);
      UpdatePortal_picture_type2.setPictureType(1);
      UpdatePortal_macroblock_intra.setMacroblockIntra(1);
      for (int i = 0; i < blocks_per_macroblock[the_chroma_format]; i++) {
        for (int j = 0; j < 64; j++) {
          QFS[i][j] = 0;
        }
      }
      for (int r = 0; r < 2; r++) 
        for (int s = 0; s < 2; s++)
          for (int t = 0; t < 2; t++) {
              motion_code[r][s][t] = 0;
          }
      for (int r = 0; r < 2; r++) 
        for (int s = 0; s < 2; s++)
          for (int t = 0; t < 2; t++) {
              motion_residual[r][s][t] = 0;
          }
      push(1);
      push(0);
      push(0);
      for (int i = 0; i < (width/16); i++) {
        for (int j = 0; j < (height/16); j++) {
          PushMacroblock();     
        } 
      }
      println("Done generating fake frame");
    } else {
//      println("Error - Trying to parse M2V file for a second time...");
    }
  }
}

/**
 * @internal
 */
int->int pipeline BlockDecode(portal<InverseQuantization_AC_Coeff> UpdatePortal_quantiser_data_ac,
                              portal<InverseQuantizationJoinerSubstitute> UpdatePortal_macroblock_intra,
                              portal<InverseQuantization_DC_Intra_Coeff> UpdatePortal_quantiser_data_dc
                             ) {
  add ZigZagUnordering;
    // Assumes no alternate_scan TODO
    // Output of this corresponds to QF[v][u], (cite 1, P. 67)
  add InverseQuantization(UpdatePortal_quantiser_data_ac,
                          UpdatePortal_quantiser_data_dc,
                          UpdatePortal_macroblock_intra);
  // Extreme bounds for both saturations are a best guess about how far off
  // any invalid data could ever get.
  // Bounded Saturation is roughly twice as fast as the regular Saturation
  add BoundedSaturation(-2048, 2047, -2050, 2050);
  add MismatchControl();
  add iDCT8x8_ieee(2); // fast iDCT
  add BoundedSaturation(-256, 255, -260, 260);
}

/**
 * @internal
 */
int->int filter ZigZagUnordering {
  int[64] Ordering = {00, 01, 05, 06, 14, 15, 27, 28,
                      02, 04, 07, 13, 16, 26, 29, 42,
					            03, 08, 12, 17, 25, 30, 41, 43,
					            09, 11, 18, 24, 31, 40, 44, 53,
					            10, 19, 23, 32, 39, 45, 52, 54,
					            20, 22, 33, 38, 46, 51, 55, 60,
					            21, 34, 37, 47, 50, 56, 59, 61,
					            35, 36, 48, 49, 57, 58, 62, 63};
  work pop 64 push 64 {
    for (int i = 0; i < 64; i++) {
      push(peek(Ordering[i]));
    }
    for (int i = 0; i < 64; i++) {
      pop();
    }
  }
}

/**
 * @internal
 */
int->int pipeline InverseQuantization(  
         portal<InverseQuantization_AC_Coeff> UpdatePortal_quantiser_data_ac,
         portal<InverseQuantization_DC_Intra_Coeff> UpdatePortal_quantiser_data_dc,
         portal<InverseQuantizationJoinerSubstitute> UpdatePortal_macroblock_intra) {

  // The handling of the intra DC coefficient is described on (cite 1, P.69)
  add int->int splitjoin {
    split duplicate;
    // Intra Coded Macroblocks
    add int->int splitjoin {
      split roundrobin(1, 63); 
      add InverseQuantization_DC_Intra_Coeff to UpdatePortal_quantiser_data_dc; // (cite 1, P.69)
      add InverseQuantization_AC_Coeff(1) to UpdatePortal_quantiser_data_ac;
      join roundrobin(1, 63); 
    }
    // Non Intra Coded Macroblocks
    add InverseQuantization_AC_Coeff(0) to UpdatePortal_quantiser_data_ac;
    join roundrobin(64, 64);  
  }
  
  // Selects which stream - FEATURETODO eventually programmable splitjoin and only one of the two
  // above branches gets taken instead of both.
 
  add InverseQuantizationJoinerSubstitute() to UpdatePortal_macroblock_intra;
}

/**
 * @internal
 */
int->int filter InverseQuantizationJoinerSubstitute {
  int macroblock_intra;
 
  init {
    macroblock_intra = -1;
  }
  
  handler setMacroblockIntra(int new_macroblock_intra) {
    macroblock_intra = new_macroblock_intra;
  }
  
  work pop (128) push 64 {
    if (macroblock_intra == -1) {
      println("  Error: macroblock_intra should not be -1, should have recieved update message");
    } else if (macroblock_intra == 1) {
      // It was Intra Coded
      for (int i = 0; i < 64; i++) {
        push(pop());
      }
      for (int i = 0; i < 64; i++) {
        pop();
      }
    } else {
      // It was Non Intra Coded
      for (int i = 0; i < 64; i++) {
        pop();
      }
      for (int i = 0; i < 64; i++) {
        push(pop());
      }
    }
    
  } 

}


/**
 * @internal
 */
int->int filter InverseQuantization_DC_Intra_Coeff() {
  // (cite 1, P.69)
  int[4] intra_dc_mult;
  int intra_dc_precision;

  init {
    intra_dc_mult[0] = 8;
    intra_dc_mult[1] = 4;
    intra_dc_mult[2] = 2;
    intra_dc_mult[3] = 1;
    intra_dc_precision = -1; // In case no message is received, error
  }

  work pop 1 push 1 {
    push(intra_dc_mult[intra_dc_precision] * pop());
  }

  handler setIntraDCPrecision(int new_intra_dc_precision) {
    intra_dc_precision = new_intra_dc_precision;
  }
}

/**
 * @internal
 */
int->int filter InverseQuantization_AC_Coeff(int macroblock_intra) {
  // Assumes 4:2:0 data
  // (cite 1, P.69)
  // intra = 1: This is dequantizing the non-DC part of an intra coded block
  // intra = 0: This is dequantizing the DC and AC part of a non-intra coded block

  // These are all assigned by messages and MUST be assigned before the first 
  // call to work()
  int quantiser_scale_code;
  int q_scale_type;
  int[64] intra_quantiser_matrix;
  int[64] non_intra_quantiser_matrix;

  // (cite 1, P.70 Table 7-6)
  int[2][32] quantiser_scale =
    // Note that quantiser_scale[x][0] is a Forbidden Value
    {{ 0,  2,  4,  6,  8, 10, 12, 14,
      16, 18, 20, 22, 24, 26, 28, 30,
      32, 34, 36, 38, 40, 42, 44, 46,
      48, 50, 52, 54, 56, 58, 60, 62},
     { 0,  1,  2,  3,  4,  5,  6,  7,
       8, 10, 12, 14, 16, 18, 20, 22,
      24, 28, 32, 36, 40, 44, 48, 52, 
      56, 64, 72, 80, 88, 96, 104, 112}};

  init {
    quantiser_scale_code = 0; // Guarantees that this throws an error
                              // if it doesn't get a quantiser message
                              // before getting some data.
    q_scale_type = -1; // Another nice error if no message received in time.
  }

  work pop (64-macroblock_intra) push (64-macroblock_intra) {
    if (quantiser_scale_code == 0)
      println("Error - quantiser_scale_code not allowed to be 0 " + macroblock_intra);
    for (int i = macroblock_intra; i < 64; i++) {
      int QF = pop();
      // (cite 1, P.71)
      int k = 0;
      if (macroblock_intra == 1) {
        k = 0;
      } else {
        // TODO - I think I'm interpreting this part of the spec correctly, check though.
        if (QF > 0) {
          k = 1;
        } else if (QF < 0) {
          k = -1;
        } else {
          k = 0;
        }          
      }
      int W = 0;
      if (macroblock_intra == 1) {
        W = intra_quantiser_matrix[i];
      } else {
        W = non_intra_quantiser_matrix[i];
      }
      int F = (2 * QF + k) * W * 
              quantiser_scale[q_scale_type][quantiser_scale_code] / 32;
      push(F);
    }
  }

  handler setQuantiserScaleCode(int new_quantiser_scale_code) {
    quantiser_scale_code = new_quantiser_scale_code;
  }

  handler setQuantiserMatrices(int[64] new_intra_quantiser_matrix, 
                               int[64] new_non_intra_quantiser_matrix) {
    for (int i = 0; i < 64; i++) {
      intra_quantiser_matrix[i] = new_intra_quantiser_matrix[i];
      non_intra_quantiser_matrix[i] = new_non_intra_quantiser_matrix[i];
    }
  }

  handler setQScaleType(int new_q_scale_type) {
    q_scale_type = new_q_scale_type;
  }
} 

/**
 * @internal
 */
int->int filter MismatchControl() {
  // (cite 1, P.71)
  work pop 64 push 64 {
    int sum, val;
    sum = 0;
    for (int i = 0; i < 63; i++) {
      val = pop();
      sum += val;
      push(val);
    }
    val = pop();
    sum += val;
    if ((sum & 0x1) == 0x1) {
      push(val);
    } else {
      if ((val * 0x1) == 0x1) {
        push(val-1);
      } else {
        push(val+1);
      }
    }
  }
}

/**
 * @internal
 */
int->int filter MotionVectorDecode() {
  // Note - at first glance, this filter looks like it OUGHT to handle only a single motion vector instead
  // of all 8, and then it would be wrapped inside an 8 way splitjoin. This is only because of currently
  // existing limitations in this code, however. More general MPEG-2 bitstreams allow for concealment
  // motion vectors (to help in the case of errors introduced during transmission of the bitstream), and
  // when concealment motion vectors are introduced, then dependencies are introduced between the 
  // vectors. These dependencies will make it hard to use an 8-way splitjoin approach without a 
  // message passing scheme that allows for across splitjoin messaging. 

  // Section 7.6.3.1 covers this. (cite 1, P.77)
  int[2][2][2] PMV;
  int[2][2] f_code;

  int mv_format; // HACKED TODO - MESSAGING
  int picture_structure; // HACKED TODO - MESSAGING

  init {
    mv_format = 1; // HACKD TODO MESSAGING
    picture_structure = 1; // HACKED TODO - MESSAGING
  }

  work pop 16 push 8 {
    int[2][2][2] motion_code;
    for (int r = 0; r < 2; r++)
      for (int s = 0; s < 2; s++) 
        for (int t = 0; t < 2; t++) {
          motion_code[r][s][t] = pop();
        }
    int[2][2][2] motion_residual;
    for (int r = 0; r < 2; r++)
      for (int s = 0; s < 2; s++) 
        for (int t = 0; t < 2; t++) {
          motion_residual[r][s][t] = pop();
        }
    int[2][2][2] vectorp;
    for (int r = 0; r < 1; r++) {
    // NOTE TODO - Hacked right now, don't know when we need the second motion vector.
      for (int s = 0; s < 2; s++) {
        for (int t = 0; t < 2; t++) {
          int r_size = f_code[s][t]-1;
          int f = 1 << r_size;
          int high = (16*f)-1;
          int low = ((-16)*f);
          int range = (32*f);
          int delta;
          if ((f == 1) || (motion_code[r][s][t] == 0)) {
            delta = motion_code[r][s][t];
          } else {
            delta = ((int) (abs(motion_code[r][s][t])-1)*f) + 
                    motion_residual[r][s][t]+1;
            if (motion_code[r][s][t]<0)
              delta = -delta;
          }
          int prediction = PMV[r][s][t];
          if ((mv_format == 0) && (t == 1) && (picture_structure == 3))
            println("Error - Program Limitation: May not be correct in decoding motion vectors");
          vectorp[r][s][t] = prediction + delta;
          if (vectorp[r][s][t] < low)
            vectorp[r][s][t] = vectorp[r][s][t] + range;
          if (vectorp[r][s][t] > high)
            vectorp[r][s][t] = vectorp[r][s][t] - range;
          if ((mv_format == 0) && (t == 1) && (picture_structure == 3))
            println("Error - Program Limitation: May not be correct in decoding motion vectors");
          else 
            PMV[r][s][t] = vectorp[r][s][t];
          // TODO handle updating missed motion_vectors
          // section 7.6.3.3 
        }
      }
    } 
    for (int r = 0; r < 2; r++)
      for (int s = 0; s < 2; s++) 
        for (int t = 0; t < 2; t++) {
          push(vectorp[r][s][t]);
        }
  }
  
  handler resetPredictors() {
    for (int i = 0; i < 2; i++)
      for (int j = 0; j < 2; j++)
        for (int k = 0; k < 2; k++) {
          PMV[i][j][k] = 0;
        }
  }
 
  handler setFCode(int[2][2] new_f_code) {
    for (int s = 0; s < 2; s++) 
      for (int t = 0; t < 2; t++) 
        f_code[s][t] = new_f_code[s][t];
  }

}

/**
 * @internal
 */
int->int pipeline LuminanceChannelProcessing(int width, 
                                                int height,
                                                portal<MotionPrediction> UpdatePortal_picture_type,
                                                int the_chroma_format) {
  add MacroBlockDescrambler(width, 64+11, 2);
  add DescrambleAndMotionCompensate(width, height, 1, 1, UpdatePortal_picture_type, 1, the_chroma_format);
}

/**
 * @internal
 */
int->int pipeline ChrominanceChannelProcessing(int width, 
                                               int height,
                                               portal<MotionPrediction> UpdatePortal_picture_type,
                                               int the_chroma_format) {
  // Assumes 4:2:0 to 4:4:4 or 4:2:2 to 4:4:4
  // Adding 4:4:4 support requires some additional block reordering.
  if (the_chroma_format == 2) {
    add MacroBlockDescrambler(width/2, 64+11, 1);
  }
  int vertical_upsample_factor;
  if (the_chroma_format == 1) {
    vertical_upsample_factor = 2;
  } else {
    vertical_upsample_factor = 1;
  }
  add DescrambleAndMotionCompensate(width, height, vertical_upsample_factor, 2, UpdatePortal_picture_type, 0, the_chroma_format);
  if (the_chroma_format == 1) {
    add ChannelUpsample_Vert_and_Horz(width/2, height/2);
  } else {
    add ChannelUpsample_Horizontal(width/2, height);
  }
}

/**
 * @internal
 */
int->int splitjoin MacroBlockDescrambler(int width, int block_data_size, int horiz_blockwidth) {
  split roundrobin(block_data_size*horiz_blockwidth);
  for (int i = 0; i < 2; i++) {
    add Identity<int>;
  }
  join roundrobin((width/8)*block_data_size);
}

/**
 * @internal
 */
int->int pipeline DescrambleAndMotionCompensate(int width, 
                                                  int height, 
                                                  int vertical_upsample_factor,
                                                  int horizontal_upsample_factor,
                                                  portal<MotionPrediction> UpdatePortal_picture_type,
                                                  int temp,
                                                  int the_chroma_format) {
  int datasize = (width/horizontal_upsample_factor)*(height/vertical_upsample_factor);
  add int->int splitjoin {
    split roundrobin(64, 8, 1, 1, 1);
    //add BlockDescrambler(width/horizontal_upsample_factor);
    add Identity<int>;
    add int->int splitjoin { // vectorp->vector (cite 1, P.82) 
      split roundrobin(1, 1); 
      add DivideBy(horizontal_upsample_factor);
      add DivideBy(vertical_upsample_factor);
      join roundrobin(1, 1);
    }
    add Identity<int>;
    add Identity<int>;
    add Identity<int>;
//    join roundrobin(datasize, (datasize/64)*8, datasize/64, datasize/64, datasize/64); 
    join roundrobin(64, 8, 1, 1, 1);
  }  
  add MotionPrediction(width/horizontal_upsample_factor, height/vertical_upsample_factor) 
      to UpdatePortal_picture_type;
}

int->int filter SendBackReferenceFrame(int width, int height,
                                       portal<MotionPrediction> UpdatePortal_reference_frame) {
  work pop (width*height) push (width*height) {
    int[width][height] picture;
    for (int y = 0; y < height; y++) {
      for (int x = 0; x < width; x++) {
        push(peek(0));
        picture[x][y] = pop();
      }
    }
    UpdatePortal_reference_frame.referenceFrame(picture) [1:1];    
  }
}

/**
 * @internal
 */
int->int splitjoin BlockDescrambler(int width) {
  split roundrobin(8);
  for (int i = 0; i < 8; i++) {
    add Identity<int>;
  }
  join roundrobin(width);
}

/**
 * @internal
 *
 * This is a filter version of the block descrambler that should avoid
 * some fusion overhead.  This version does not need any buffer, and
 * should be able to be derived by linear analysis.  Unfortunately, no
 * speedups were observed, but including it here for future reference.
 */
int->int filter BlockDescramblerFilter1(int width) {
    work push 8*width pop 8*width {
	for (int i=0; i<64; i+=8) {
	    for (int j=0; j<width*8; j+=width) {
		int k = i+j;
		push(peek(k));
		push(peek(k+1));
		push(peek(k+2));
		push(peek(k+3));
		push(peek(k+4));
		push(peek(k+5));
		push(peek(k+6));
		push(peek(k+7));
	    }
	}
	for (int i=0; i<8*width; i++) {
	    pop();
	}
    }
}

/**
 * @internal
 *
 * This is a filter version of the block descrambler that should avoid
 * some fusion overhead.  This version uses a buffer so that no peek
 * statements are needed.  It is probably slower than
 * BlockDescramblerFilter1, but including for future experiments.
 */
int->int filter BlockDescramblerFilter2(int width) {
    work push 8*width pop 8*width {
	int[8*width] buffer;
	for (int i=0; i<width; i+=8) {
	    for (int j=0; j<8; j++) {
		int k = j*width+i;
		buffer[k] = pop();
		buffer[k+1] = pop();
		buffer[k+2] = pop();
		buffer[k+3] = pop();
		buffer[k+4] = pop();
		buffer[k+5] = pop();
		buffer[k+6] = pop();
		buffer[k+7] = pop();
	    }
	}
	for (int i=0; i<8*width; i++) {
	    push(buffer[i]);
	}
    }
}

/**
 * @internal
 */
int->int filter MotionPrediction(int width, int height) {
  int count;

  int lastSeenFrame;

  int datarate = (width*height/64*(64+8+1+1+1));
  int pushrate = width*height;
  
  int[width][height] prev_picture;
  int[width][height] next_picture;

  int next_picture_type;

  init {
    next_picture_type = -1;
    count = 0;
  }

  work pop datarate push pushrate {
    if (next_picture_type == -1) {
      println("Error - Should have received a picture type message before motion prediction can process");
    } 
    if (next_picture_type == 1 || next_picture_type == 2) {
      prev_picture = next_picture;
      if (next_picture_type == 1) {
        readIPicture();
      } else {
        readPPicture();
      }
    } else {
      readBPicture();
    }
    count++;
  }

  phase readIPicture pop datarate push pushrate {
    lastSeenFrame = 1;
    int[width][height] temp_picture;
 
    for (int blocky = 0; blocky < (height/8); blocky++) {
      for (int blockx = 0; blockx < (width/8); blockx++) {
        for (int y = 0; y < 8; y++) {
          for (int x = 0; x < 8; x++) {
            temp_picture[x+blockx*8][y+blocky*8] = pop();
          }
        }
        for (int i = 0; i < 8; i++) {
          pop();
        }
        pop();
        pop();
        pop();
      }
    }

    for (int y = 0; y < height; y++) {
      for (int x = 0; x < width; x++) {
        next_picture[x][y] = temp_picture[x][y];
        push(temp_picture[x][y]);
      }
    }
  }

  phase readPPicture pop datarate push pushrate {
    lastSeenFrame = 2;
    int[width][height] temp_picture;
    int[width/8][height/8][2][2][2] vector;
    int[width/8][height/8] macroblock_intra;

    for (int blocky = 0; blocky < height/8; blocky++) {
      for (int blockx = 0; blockx < width/8; blockx++) {
        for (int y = 0; y < 8; y++) {
          for (int x = 0; x < 8; x++) {
            temp_picture[x+blockx*8][y+blocky*8] = pop();
          }
        }
        for (int r = 0; r < 2; r++) {
          for (int s = 0; s < 2; s++) {
            for (int t = 0; t < 2; t++) {
              vector[blockx][blocky][r][s][t] = pop();
            }
          }
        }
        macroblock_intra[blockx][blocky] = pop();
        pop();
        pop();
      }
    }

    for (int y = 0; y < height; y++) {
      for (int x = 0; x < width; x++) {
        if (macroblock_intra[x/8][y/8] == 0) {
          int sample_data;
          sample_data = predictMotionPixel(prev_picture, vector, 0, x, y);
          next_picture[x][y] = temp_picture[x][y] + sample_data;
        } else {
          next_picture[x][y] = temp_picture[x][y];
        }
        push(next_picture[x][y]);
        if (next_picture[x][y] > 127) {
          next_picture[x][y] = 127;
        } else if (next_picture[x][y] < -128) {
          next_picture[x][y] = -128;
        }
      }
    }
  }

  phase readBPicture pop datarate push pushrate {
    lastSeenFrame = 3;
    int[width][height] temp_picture;
    int[width/8][height/8][2][2][2] vector;
    int[width/8][height/8] macroblock_intra;
    int[width/8][height/8] macroblock_motion_forward;
    int[width/8][height/8] macroblock_motion_backward;

    for (int blocky = 0; blocky < height/8; blocky++) {
      for (int blockx = 0; blockx < width/8; blockx++) {
        for (int y = 0; y < 8; y++) {
          for (int x = 0; x < 8; x++) {
            temp_picture[x+blockx*8][y+blocky*8] = pop();
          }
        }
        for (int r = 0; r < 2; r++) {
          for (int s = 0; s < 2; s++) {
            for (int t = 0; t < 2; t++) {
              vector[blockx][blocky][r][s][t] = pop();
            }
          }
        }
        macroblock_intra[blockx][blocky] = pop();
        macroblock_motion_forward[blockx][blocky] = pop();
        macroblock_motion_backward[blockx][blocky] = pop();
      }
    }

    int[width][height] permsample;
    for (int y = 0; y < height; y++) {
      for (int x = 0; x < width; x++) {
        int pushval;
        if (macroblock_intra[x/8][y/8] == 0) {
          int[2] sample_data;
          if (macroblock_motion_forward[x/8][y/8] == 1) {
            sample_data[0] = predictMotionPixel(prev_picture, vector, 0, x, y);
          }
          if (macroblock_motion_backward[x/8][y/8] == 1) {
            sample_data[1] = predictMotionPixel(next_picture, vector, 1, x, y);
          }
          if (macroblock_motion_forward[x/8][y/8] == 1) {
            if (macroblock_motion_backward[x/8][y/8] == 1) {
                permsample[x][y] = (1+sample_data[0]+sample_data[1]+256)/2-128;
            } else {
              permsample[x][y] = sample_data[0];  
            }
          } else {
            permsample[x][y] = sample_data[1];
          }
        } else {
          permsample[x][y] = 0;
        }
        pushval = temp_picture[x][y] + permsample[x][y];
        push(pushval);
      }
    }
  }

  handler setPictureType(int picture_coding_type) {
    next_picture_type = picture_coding_type;
  }

  handler referenceFrame(int[width][height] picture) {
    if (lastSeenFrame == 1 || lastSeenFrame == 2) {
      for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
          next_picture[x][y] = picture[x][y];
        }
      }
    }
  }

  int predictPixelHorizHalfPelVertHalfPel(int[width][height] predict_pic, int horiz_vector, int vert_vector) {
    int sample_data;
    sample_data = (predict_pic[(horiz_vector-1)/2][(vert_vector-1)/2] +
                   predict_pic[(horiz_vector-1)/2][(vert_vector+1)/2] +
                   predict_pic[(horiz_vector+1)/2][(vert_vector-1)/2] +
                   predict_pic[(horiz_vector+1)/2][(vert_vector+1)/2]);
    sample_data += 128*4;
    if (sample_data > 0) {
      sample_data += 2;
    } else if (sample_data < 0) {
      println("Error - Shouldn't be less than zero " + sample_data);
    }
    sample_data = sample_data / 4;
    sample_data -= 128;
    return sample_data;
  }

  int predictPixelHorizHalfPelVertFullPel(int[width][height] predict_pic, int horiz_vector, int vert_vector) {
    int sample_data;
    sample_data = (predict_pic[(horiz_vector-1)/2][vert_vector/2] +
                   predict_pic[(horiz_vector+1)/2][vert_vector/2]);
    sample_data += 128*2;
    if (sample_data > 0) {
      sample_data += 1;
    } else if (sample_data < 0) { 
      println("Error - Shouldn't be less than zero " + sample_data);
    }
    sample_data = sample_data / 2;
    sample_data -= 128;
    return sample_data;
  }

  int predictPixelHorizFullPelVertHalfPel(int[width][height] predict_pic, int horiz_vector, int vert_vector) {
    int sample_data;
    sample_data = (predict_pic[horiz_vector/2][(vert_vector-1)/2] +
                   predict_pic[horiz_vector/2][(vert_vector+1)/2]);
    sample_data += 128*2;
    if (sample_data > 0) {
      sample_data += 1;
    } else if (sample_data < 0) {
      println("Error - Shouldn't be less than zero " + sample_data);
    }
    sample_data = sample_data / 2;
    sample_data -= 128;
    return sample_data;
  }

  int predictPixelHorizFullPelVertFullPel(int[width][height] predict_pic, int horiz_vector, int vert_vector) {
    int sample_data;
    sample_data = predict_pic[horiz_vector/2][vert_vector/2];
    return sample_data;
  }

  int predictMotionPixel(int[width][height] predict_pic, int[width/8][height/8][2][2][2] vector, 
                         int whichvect, int x, int y) {
  // whichvect = 0 for forward motion prediction
  // whichvect = 1 for backward motion prediction
    int horiz_vector = vector[x/8][y/8][0][whichvect][0] + (x*2);
    int vert_vector = vector[x/8][y/8][0][whichvect][1] + (y*2);
    int sample_data;
    if (vert_vector < 0 || vert_vector >= (height*2-1) || 
        horiz_vector < 0 || horiz_vector >= (width*2-1)) {
       sample_data = 0;
    } else if ((horiz_vector & 0x1) == 1) {
      if ((vert_vector & 0x1) == 1) {
        sample_data = predictPixelHorizHalfPelVertHalfPel(predict_pic, horiz_vector, vert_vector);
      } else {
        sample_data = predictPixelHorizHalfPelVertFullPel(predict_pic, horiz_vector, vert_vector);
      }
    } else {
      if ((vert_vector & 0x1) == 1) {
        sample_data = predictPixelHorizFullPelVertHalfPel(predict_pic, horiz_vector, vert_vector);
      } else {
        sample_data = predictPixelHorizFullPelVertFullPel(predict_pic, horiz_vector, vert_vector);
      }
    }
    if (sample_data > 127)
      sample_data = 127;
    else if (sample_data < -128)
      sample_data = -128;
    return sample_data;
  }

}

// Note: We assume we are going from 4:2:0 to 4:4:4
// Otherwise this won't work.
// Check out store.c in the mpeg reference implementation
// It has a more complicated, probably more accurate
// implementation. Only implement if needed.
/**
 * @internal
 */
int->int pipeline ChannelUpsample_Vert_and_Horz(int sourcewidth, int sourceheight) {
  add ChannelUpsample_Vertical(sourcewidth, sourceheight);
  add ChannelUpsample_Horizontal(sourcewidth, sourceheight);
}

int->int splitjoin ChannelUpsample_Vertical(int sourcewidth, int sourceheight) {
  split roundrobin(1);
  for (int i = 0; i < sourcewidth; i++) {
    add ChannelUpsample_1D(sourceheight, 0.75, 0.25);
  }
  join roundrobin(1);
}

int->int splitjoin ChannelUpsample_Horizontal(int sourcewidth, int sourceheight) {
  split roundrobin(sourcewidth);
  for (int i = 0; i < sourceheight; i++) {
    add ChannelUpsample_1D(sourcewidth, 0.5, 0.5);
  }
  join roundrobin(sourcewidth*2);
}

/**
 * @internal
 */
int->int filter ChannelUpsample_1D_Unoptimized(int sourcelen, float weight1, float weight2) {
  work pop sourcelen push sourcelen*2 {
    int val1 = 0, val2 = 0;
    val1 = pop();
    push(val1);
    for (int i = 0; i < sourcelen-1; i++) {
      val2 = pop();
      float outval = (weight1*val1+weight2*val2);
      push((int) round(outval));
      outval = (weight2*val1+weight1*val2);
      push((int) round(outval));
      val1 = val2;
    }
    push(val2);
  }    
}

/**
 * @internal
 */
int->int filter ChannelUpsample_1D(int sourcelen, 
				    float weight1, 
				    float weight2) {
    work pop sourcelen push sourcelen*2 {
        int val1 = 0, val2 = 0;
	// keep track of product of weights to avoid extra multiplies
	float w1val1, w1val2; // weight1 * val1, weight1 * val2
	float w2val1, w2val2; // weight2 * val1, weight2 * val2

        val1 = pop();
	w1val1 = weight1*val1;
	w2val1 = weight2*val1;

        push(val1);
        for (int i = 0; i < sourcelen-1; i++) {
            val2 = pop();
	    w1val2 = weight1*val2;
	    w2val2 = weight2*val2;

            float outval = (w1val1+w2val2);
            push((int) round(outval));
            outval = (w2val1+w1val2);
            push((int) round(outval));

            w1val1 = w1val2;
            w2val1 = w2val2;
        }
        push(val2);
    }    
}

/**
 * @internal
 */
int->int filter PictureReorder(int width, int height) {
  int datarate = (width*height*3);
  int[(width*height*3)] databuffer;
  int next_picture_type;

  prework pop datarate {
    for (int i = 0; i < datarate; i++) {
      databuffer[i] = pop();
    }
  }

  work pop datarate push datarate {
    if (next_picture_type == 3) {
      for (int i = 0; i < datarate; i++) {
        push(pop());
      }
    } else {
      for (int i = 0; i < datarate; i++) {
        push(databuffer[i]);
        databuffer[i] = pop();
      }
    }     
  }

  handler setPictureType(int picture_coding_type) {
    next_picture_type = picture_coding_type;
  }
}




