/*
 * Copyright 2005 by the Massachusetts Institute of Technology.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in
 * advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 */

/**
 * @description
 * This file contains functions that allow one to encode MPEG-2 compliant video. 
 * The code is based on the MPEG-2 specification (ISO/IEC 13818-2). The MPEG-2 encoder
 * is a work in progress, although it works within a limited test range. Throughout the 
 * source code, citations are made in cases where an understanding of the code would be
 * helped by looking at an outside source. The format I have chosen is 
 * (cite NUM#, LOOKUP_INFO). NUM=1 refers to ISO/IEC: 13818-2, and NUM=2 refers to the reference
 * MPEG implementation written in C, available at [www.mpeg.org].
 *
 * @author <a href="mailto:madrake@gmail.com">Matthew Drake</a>
 * @file MPEGencoder.str.pre
 * @version 1.0
 */

// Comments for readers of the StreamIt MPEG specification:
//
// TODO notes refer to parts of the MPEG-2 specification which this
// program does not yet handle, or assumptions made by the program.
// FEATURETODO notes refer to changes that ought to be made to the program,
// or support which can be added for more of the MPEG-2 specification, which
// is pending the addition of features to the StreamIt language compiler.
// In general I have tried to document my code, and refer to the MPEG-2
// specification whenever I used it. If you are looking at any particular
// block of code and aren't sure what it is doing, find the previous citation
// comment, and refer to the corresponding page in the MPEG 2 spec.

/**
 * Interprets an input stream of raw video and encodes a compressed MPEG-2 
 * compliant bit stream, in accordance with the IEEE MPEG-2 specification.
 * @param width The resolution width of the video.
 * @param height The resolution height of the video.
 * @param numpictures The number of pictures to be put into the video.
 * @input A series of images representing the frames of the video. Each image
 *        consists of 3 integers for each pixel, with the number of pixels per
 *        image equalling the width * height of the video. Frames are output
 *        in time order, top to bottom, left to right, and RGB color order.
 * @output An MPEG-2 compliant bit stream of variable length.
 */ 
int->bit pipeline rawImageStream_to_MPEGStream(int width, int height, int numpictures) {

    portal<MotionEstimation> portal_fwdMotion;
    portal<MotionEstimation> portal_bckMotion;

    int actual_intra_dc_precision = 8;  
    int chroma_format = 1;
    int blocks_per_macroblock;
    int downsampled_data_per_image;
    if (chroma_format == 1) {
        blocks_per_macroblock = 6;
        downsampled_data_per_image = (width*height*3)/2;
    } else {
        // don't really support this
        blocks_per_macroblock = 10000;
        downsampled_data_per_image = 1;
    }

    int pixeldata_per_macroblock = blocks_per_macroblock*64;

    // Default Values for the quantiser_matrices
    int[64] default_intra_quantiser_matrix = 
    { 8, 16, 19, 22, 26, 27, 29, 34,
      16, 16, 22, 24, 27, 29, 34, 37,
      19, 22, 26, 27, 29, 34, 34, 38,
      22, 22, 26, 27, 29, 34, 37, 40,
      22, 26, 27, 29, 32, 35, 40, 48,
      26, 27, 29, 32, 35, 40, 48, 58,
      26, 27, 29, 34, 38, 46, 56, 69,
      27, 29, 35, 38, 46, 56, 69, 83};
    int[64] default_non_intra_quantiser_matrix =
    {16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16};
    int q_scale_type = 0;

    add PicturePreprocessing(width, height, numpictures, downsampled_data_per_image);
    // Eventually Wrap in Programmable Splitjoin for Group of Pictures

    add ReorderPictures(downsampled_data_per_image);
    // Eventually Wrap in Programmable Splitjoin for Slices - Also need to communicate frame type.

    add splitjoin {
        split roundrobin(2, downsampled_data_per_image);
        add Identity<int>;
        add int->int splitjoin {
            split duplicate;
            add IntraMotionPrediction(pixeldata_per_macroblock);
            add MotionEstimation(width, height, 0, pixeldata_per_macroblock, 32) to portal_fwdMotion;
            add MotionEstimation(width, height, 1, pixeldata_per_macroblock, 32) to portal_bckMotion;
            join roundrobin(pixeldata_per_macroblock+5);
        }
        join roundrobin(2, 3*(downsampled_data_per_image*(pixeldata_per_macroblock+5)/pixeldata_per_macroblock));
    }

    add MotionPredictionDecision(width, 
                                 height, 
                                 downsampled_data_per_image, 
                                 pixeldata_per_macroblock);

    add int->int splitjoin {
        split roundrobin(2, (downsampled_data_per_image*(pixeldata_per_macroblock+6)/pixeldata_per_macroblock));
        add Identity<int>;
        add splitjoin {
            split roundrobin(pixeldata_per_macroblock+1, 5);
            add MacroBlockEncode(default_intra_quantiser_matrix, 
                                 default_non_intra_quantiser_matrix,
                                 actual_intra_dc_precision - 8, 
                                 q_scale_type,
                                 pixeldata_per_macroblock);       
            add MotionVectorEncode(width/16);
            join roundrobin(pixeldata_per_macroblock+5, 8+1);
        }
        join roundrobin(2, downsampled_data_per_image*(pixeldata_per_macroblock+14)/pixeldata_per_macroblock);
    }

    add ReferenceFrameHandler(default_intra_quantiser_matrix, 
                              default_non_intra_quantiser_matrix, 
                              actual_intra_dc_precision - 8,
                              q_scale_type,
                              width,
                              height,
                              portal_fwdMotion,
                              portal_bckMotion,
                              downsampled_data_per_image,
                              pixeldata_per_macroblock);

    add MPEGStreamGenerator(width, 
                            height, 
                            numpictures,
                            default_intra_quantiser_matrix, 
                            default_non_intra_quantiser_matrix, 
                            actual_intra_dc_precision - 8,
                            q_scale_type);

    // TODO temporary hack to bit-align the start codes
    add bit->bit filter {
        int position = 0;
        // Fix up the start codes
        work pop * push * {
            int tempval;
            peeks(24, tempval);
            if (tempval == 1) {
                int blah;
                peeks(32, blah);
                if (position == 0) {
                    pushpop(32);
                } else {
                    for (int i = 0; i < 8 - position; i++) {
                        push(0);        
                    }
                    pushpop(32);
                    position = 0;
                }
            } else {
                pushpop(1);
                position = (position + 1) % 8;
            }
        }
    }
}

/**
 * @internal
 */
int->int pipeline ReferenceFrameHandler(int[64] intra_quantiser_matrix,
                                        int[64] non_intra_quantiser_matrix,
                                        int intra_dc_precision,
                                        int q_scale_type,
                                        int width,
                                        int height,
                                        portal<MotionEstimation> portal_fwdMotion,
                                        portal<MotionEstimation> portal_bckMotion,
                                        int downsampled_data_per_image,
                                        int pixeldata_per_macroblock) {

    int macroblock_output_data_size = downsampled_data_per_image*(pixeldata_per_macroblock+14)/pixeldata_per_macroblock;

    add int->int splitjoin {
        // FEATURETODO - Some kind of message should ignore the right branch if its a B frame
        split duplicate;
        add Identity<int>;
        add DecodeAndSendBackReferenceFrame(intra_quantiser_matrix, 
                                            non_intra_quantiser_matrix, 
                                            intra_dc_precision,
                                            q_scale_type,
                                            width,
                                            height,
                                            portal_fwdMotion,
                                            portal_bckMotion,
                                            downsampled_data_per_image,
                                            pixeldata_per_macroblock);
        join roundrobin(2+macroblock_output_data_size, 1);
    }
    add int->int filter {
        int a = 2+macroblock_output_data_size;
        work pop a+1 push a {
            pushpop(a);
            if (pop() != 1999) 
                println("Error - Streams missaligned somehow!");
        }
    }
}                                        

/**
 * @internal
 */
int->int pipeline MotionVectorDecodeNoMessage(int macroblock_width) {
    add splitjoin {
        split roundrobin(2);
        for (int i = 0; i < 4; i++) {
            add IndividualMotionVectorDecode(macroblock_width);
        }
        join roundrobin(1);
    }
}

/**
 * @internal
 */
int->int pipeline MotionVectorEncode(int macroblock_width) {
    add splitjoin {
        split roundrobin(4, 1);
        add Identity<int>;
        add Repeat(1, 5);
        join roundrobin(4, 5);
    }
    add splitjoin {
        split roundrobin(8, 1);
        add splitjoin {
            split roundrobin(1);
            add IndividualMotionVectorEncode(macroblock_width, 2);
            add IndividualMotionVectorEncode(macroblock_width, 2);
            add IndividualMotionVectorEncode(macroblock_width, 3);
            add IndividualMotionVectorEncode(macroblock_width, 3);
            join roundrobin(2);
        }        
        add Identity<int>;
        join roundrobin(8, 1);
    }
}

/**
 * @internal
 */
int->int filter IndividualMotionVectorDecode(int macro_width) {

    int PMV;
    int f_code;

    init {
        f_code = 9;
    }

    work pop 2*macro_width push macro_width {
        PMV = 0;
        for (int i = 0; i < macro_width; i++) {
            oneBlock();
        }
    }

    phase oneBlock pop 2 push 1 {
        int motion_code = pop();
        int motion_residual = pop();
        int r_size = f_code - 1;
        int f = 1 << r_size;
        int high = (16*f)-1;
        int low = ((-16)*f);
        int range = 32*f;
        int delta = 0;
        if ((f == 1) || (motion_code == 0))
            delta = motion_code;
        else {
            delta = ((((int) abs(motion_code)) - 1) * f) + motion_residual + 1;
            if (motion_code < 0)
                delta = -delta;
        }
        int prediction = PMV;
        int vectorp = prediction + delta;
        if (vectorp < low)
            vectorp = vectorp + range;
        else if (vectorp > high) {
            vectorp = vectorp - range;
        }

        push(vectorp);

        PMV = vectorp;

    }
        
}

/**
 * @internal
 */
int->int filter IndividualMotionVectorEncode(int macro_width, int vector_type) {
    int PMV;
    int f_code;

    init {
        f_code = 9; // TODO - f_codes can vary in general, but we'll only put this
        // into specific encoder implementations.
    }

    work pop 2*macro_width push 2*macro_width {
        PMV = 0;
        for (int i = 0; i < macro_width; i++) {
            oneBlock();
        }
    }

    phase oneBlock pop 2 push 2 {
        int r_size = f_code-1;
        int f = 1 << r_size;
        int high = (16*f)-1;
        int low = ((-16)*f);
        int range = (32*f);
        int vectorp = pop();
        int macroblock_type = pop();

        if (!((macroblock_type == 3 && vector_type == 2) ||
              (macroblock_type == 2 && vector_type == 3))) {

            int prediction = PMV;

            int delta = vectorp - prediction;
            
            int motion_code = 0;
            int motion_residual = 0;
            if ((f == 1) || delta == 0) {
                motion_code = delta;
            } else {
                int posdelta = (int) abs(delta);
                int temp3 = posdelta - 1;
                motion_residual = temp3 % f;
                int temp1 = temp3 - motion_residual;
                if (delta < 0) {
                    motion_code = (-1*temp1)/f - 1;
                } else {
                    motion_code = temp1/f + 1;
                }      
            }
            push(motion_code);
            push(motion_residual);

            PMV = vectorp;
        } else {
            push(0);
            push(0);
        }
    }
}

/**
 * @internal
 */
int->int filter MotionPredictionDecision(int width, 
                                         int height,
                                         int downsampled_data_per_image,
                                         int pixeldata_per_macroblock) {
    int mp_data_size = (downsampled_data_per_image*(pixeldata_per_macroblock+5)/pixeldata_per_macroblock);
    int mpd_data_size = (downsampled_data_per_image*(pixeldata_per_macroblock+6)/pixeldata_per_macroblock);

    work pop 2+3*mp_data_size push 2+mpd_data_size {
        pushpop(1);
        // TODO - Could have intra coded blocks in P or B frames
        int picture_type = peek(0);
        pushpop(1);
        int a = pixeldata_per_macroblock+4;
        for (int macroblock = 0; macroblock < (mp_data_size/a); macroblock++) {
            if (picture_type == 1) { // I picture              
                push(1); // macroblock_intra - TODO change to messaging
                pushpop(a);
                deadpop(1);
                deadpop(a);
                deadpop(1);
                deadpop(a);
                deadpop(1);
                push(1);
            } else if (picture_type == 2) { // P picture
                push(0); // macroblock_intra
                deadpop(a);
                deadpop(1);
                pushpop(a);
                deadpop(1);
                deadpop(a);
                deadpop(1);
                push(2);
            } else { // B picture
                push(0); // macroblock_intra
                deadpop(a);
                deadpop(1);
                int error_backward = peek(a);
                int error_forward = peek(2*a+1);
                // Determine if the combination of the forward and backward
                // vectors has lower error than either one seperately.
                float[pixeldata_per_macroblock] combo_data;
                float error_combo = 0;
                for (int i = 0; i < pixeldata_per_macroblock; i++) {
                    combo_data[i] = 0.5*(peek(i) + peek(pixeldata_per_macroblock+5+i));
                    error_combo += combo_data[i];
                }

                int encode_decision; // 2 = P, 3 = B, 4 = P and B
                if (((int) error_combo) < error_backward &&
                    ((int) error_combo) < error_forward) {
                    encode_decision = 4;
                } else if (error_backward <= error_forward) {
                    encode_decision = 3;
                } else {
                    encode_decision = 2;
                }

                if (encode_decision == 4) {
                    // Encode with P and B vectors
                    for (int i = 0; i < pixeldata_per_macroblock; i++) {
                        push((int) (round(combo_data[i])));                      
                    }
                    int b = pixeldata_per_macroblock;
                    deadpop(b);
                    push(peek(5+b));
                    push(peek(5+b+1));
                    pushpop(2);
                    deadpop(2);
                    deadpop(1);
                    deadpop(a);
                    deadpop(1);
                    push(encode_decision);
                } else if (encode_decision == 3) { // Encode with B vectors
                    int b = pixeldata_per_macroblock;
                    pushpop(b);
                    push(peek(2));
                    push(peek(3));
                    push(peek(0));
                    push(peek(1));
                    pop(); 
                    pop(); 
                    pop(); 
                    pop();
                    deadpop(1);
                    deadpop(a);
                    deadpop(1);
                    push(encode_decision);
                } else if (encode_decision == 2) { // Encode with P vectors
                    deadpop(a);
                    deadpop(1);
                    int b = pixeldata_per_macroblock;
                    pushpop(a); // Reorder
                    deadpop(1);
                    push(encode_decision);
                } else {
                    println("ERROR ERROR - encode_decision must be 2, 3, or 4");
                }
            }
            // the final value pushed follows this convention:
            // 1 = intra, 2 = forward, 3 = backward, 4 = both
        }
    }
}

/**
 * @internal
 */
int->int filter IntraMotionPrediction(int pixeldata_per_macroblock) {
    work pop pixeldata_per_macroblock push pixeldata_per_macroblock+5 {
        pushpop(pixeldata_per_macroblock);
        push(0);
        push(0);
        push(0);
        push(0);
        push(0); // error value - could use this later for 
                 // decision making TODO on P or B pictures
    }
}

/**
 * @internal
 */
int->int filter MotionEstimation(int width, int height, int delay, int pixeldata_per_macroblock, int window) {
    // The window size determines how many pixels on either side of the specified block that are checked for
    // possible motion estimation matching.
    int macroblock_count = (width/16)*(height/16);
    int block_output_data_size = pixeldata_per_macroblock+5;

    int[width][height] lum;
    int[width/2][height/2] cb;
    int[width/2][height/2] cr;


    work pop macroblock_count*pixeldata_per_macroblock push macroblock_count*block_output_data_size {
        for (int blocky = 0; blocky < (height/16); blocky++) {
            for (int blockx = 0; blockx < (width/16); blockx++) {
                int[16][16] curblock_lum;
                int[8][8] curblock_cb;
                int[8][8] curblock_cr;
                for (int lum_count = 0; lum_count < 4; lum_count++) {
                    for (int y = 0; y < 8; y++) {
                        for (int x = 0; x < 8; x++) {
                            int input_val = pop();
                            curblock_lum[x+8*(lum_count % 2)][y+8*(lum_count / 2)] = input_val;
                        }
                    }
                }
                for (int y = 0; y < 8; y++) {
                    for (int x = 0; x < 8; x++) {
                        int input_val = pop();
                        curblock_cb[x][y] = input_val;
                    }
                }
                for (int y = 0; y < 8; y++) {
                    for (int x = 0; x < 8; x++) {
                        int input_val = pop();
                        curblock_cr[x][y] = input_val;
                    }
                }
 
                int best_motionx = 0;
                int best_motiony = 0;
                int best_error = 256*8*8*4*3; // todo - hacked for now to have a limited window size
                                                
                int windowxleft = blockx*32-window;
                if (windowxleft < 0)
                    windowxleft = 0;
                int windowxright = blockx*32+32+window;
                if (windowxright > width*2)
                    windowxright = width*2;
                int windowytop = blocky*32-window;
                if (windowytop < 0) 
                    windowytop = 0;
                int windowybottom = blocky*32+32+window;
                if (windowybottom > height*2)
                    windowybottom = height*2;
                // For now we don't try half-pixel motion vectors TODO;
                for (int window_x = windowxleft; window_x <= windowxright - 32; window_x = window_x + 2) {
                    for (int window_y = windowytop; window_y <= windowybottom - 32; window_y = window_y + 2) {
                        // Try this window and see how well it does.
                        int local_error = 0;
                        for (int y = 0; y < 16; y++) {
                            for (int x = 0; x < 16; x++) {
                                local_error += (int) abs(curblock_lum[x][y] - lum[(window_x/2)+x][(window_y/2)+y]);
                            }
                        }
                        for (int y = 0; y < 8; y++) {
                            for (int x = 0; x < 8; x++) {
                                int temp  = ((int) abs(curblock_cb[x][y] - cb[(window_x/4)+x][(window_y/4)+y]));
                                local_error += 4 * temp;
                                int temp2 = ((int) abs(curblock_cr[x][y] - cr[(window_x/4)+x][(window_y/4)+y]));
                                local_error += 4 * temp2;
                            }
                        }
                        if (local_error < best_error) {
                            best_error = local_error;
                            best_motionx = window_x - blockx*32;
                            best_motiony = window_y - blocky*32;
                        }
                    }
                }
                             
                for (int lum_count = 0; lum_count < 4; lum_count++) {
                    for (int y = 0; y < 8; y++) {
                        for (int x = 0; x < 8; x++) {
                            int output_val;
                            int temp1 = x+8*(lum_count % 2);
                            int temp2 = y+8*(lum_count / 2);
                            int temp3 = blockx*16+(lum_count % 2)*8+x+best_motionx/2;
                            int temp4 = blocky*16+(lum_count / 2)*8+y+best_motiony/2;
                            int new_val = curblock_lum[temp1][temp2];
                            int ref_val = lum[temp3][temp4];
                            output_val =  new_val - ref_val;
                            push(output_val); 
                        }
                    }
                }
                for (int y = 0; y < 8; y++) {
                    for (int x = 0; x < 8; x++) {
                        int output_val;
                        output_val = curblock_cb[x][y] - cb[blockx*8+x+best_motionx/4][blocky*8+y+best_motiony/4];
                        push(output_val);
                    }
                }
                for (int y = 0; y < 8; y++) {
                    for (int x = 0; x < 8; x++) {
                        int output_val;
                        output_val = curblock_cr[x][y] - cr[blockx*8+x+best_motionx/4][blocky*8+y+best_motiony/4];
                        push(output_val);
                    }
                }
                push(best_motionx);
                push(best_motiony);
                push(0);
                push(0);
                push(best_error);
            }
        }
    }

    handler referencePic(int[width][height] new_lum, 
                         int[width/2][height/2] new_cb, 
                         int[width/2][height/2] new_cr, 
                         int[width/16][height/16][4] motion_vectors,
                         int picture_type) {

        int[width][height] old_lum;
        int[width/2][height/2] old_cb;
        int[width/2][height/2] old_cr;

        if (picture_type == 2) {
            for (int x = 0; x < width; x++) {
                for (int y = 0; y < height; y++) {
                    old_lum[x][y] = lum[x][y];
                }
            }
            for (int x = 0; x < width/2; x++) {
                for (int y = 0; y < height/2; y++) {
                    old_cb[x][y] = cb[x][y];
                    old_cr[x][y] = cr[x][y];
                }
            }
        }
         
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                if (picture_type == 1) {
                    lum[x][y] = new_lum[x][y];
                } else {
                    int xloc = x + motion_vectors[x/16][y/16][0]/2;
                    int yloc = y + motion_vectors[x/16][y/16][1]/2;
                    if (xloc < 0 || yloc < 0 || xloc > width || yloc > height) {
                        println("Fatal Error: Motion vectors point outside of image bounds in reference frame");
                        xloc = 0;
                        yloc = 0;
                    }
                    int temp1 = new_lum[x][y];
                    int temp2 = old_lum[xloc][yloc];
                    lum[x][y] = temp1 + temp2;
                }
            }
        }
        for (int x = 0; x < width/2; x++) {
            for (int y = 0; y < height/2; y++) {
                if (picture_type == 1) {                   
                    cb[x][y] = new_cb[x][y];
                    cr[x][y] = new_cr[x][y];
                } else {
                    int xloc = x + motion_vectors[x/8][y/8][0]/4;
                    int yloc = y + motion_vectors[x/8][y/8][1]/4;
                    if (xloc < 0 || yloc < 0 || xloc > width/2 || yloc > height/2) {
                        println("Fatal Error: Motion vectors point outside of image bounds in reference frame");
                        xloc = 0;
                        yloc = 0;
                    }
                    cb[x][y] = new_cb[x][y] +
                        old_cb[xloc][yloc];
                    cr[x][y] = new_cr[x][y] +
                        old_cr[xloc][yloc];
                }
            }
        }
    }
}

/**
 * @internal
 */
int->int splitjoin MacroBlockScrambler(int width) {
    split roundrobin(16);
    for (int i = 0; i < (width/16); i++) {
        add int->int splitjoin {
            split roundrobin(8);
            for (int j = 0; j < 2; j++) {
                add Identity<int>;
            }
            join roundrobin(8*8);
        }
    }
    join roundrobin(16*16);
}

/**
 * @internal
 */
int->int splitjoin MacroBlockOrder(int width) {
    split roundrobin(16);
    for (int i = 0; i < (width/16); i++) {
        add Identity<int>;
    }
    join roundrobin(16*16);
}

/**
 * @internal
 */
int->int filter DropSecond {
    work pop 2 push 1 {
        push(pop());
        pop();
    }
}

/**
 * @internal
 */
int->int filter ChannelDownsample_1D(float weight1, float weight2) {
    work pop 2 push 1 {
        float a = pop()*weight1;
        float b = pop()*weight2;
        push((int) round(a+b));
    }
}

// Note: We assume we are going from 4:4:4 to 4:2:0
// Otherwise this won't work.
// See (cite 1, P. 14, Figure 6-1) for spacing of the samples.
// I think this works but we should actually test it.
int->int pipeline ChannelDownsample(int width, int height) {
    add DropSecond;
    add int->int splitjoin {
        split roundrobin(1);
        for (int i = 0; i < 8; i++) {
            add ChannelDownsample_1D(0.5, 0.5);
        }
        join roundrobin(1);
    }
}

/**
 * @internal
 */
int->int pipeline TransformPicture(int width, int height) {
    add ColorSpaceConversion_RGBtoYCbCr;
    add int->int splitjoin {
        split roundrobin(1);
        add MacroBlockScrambler(width);
        for (int i = 0; i < 2; i++) {
            add int->int pipeline {
                add MacroBlockOrder(width);
                add ChannelDownsample(width, height); 
            }
        }
        join roundrobin(64*4, 64, 64);
    }
}

/**
 * @internal
 */
int->int filter AssignPictureType(int width, int height, int numpictures) {
    // TODO - AssignPictureType for now sends everything in a SINGLE Group_of_Pictures
    // It also assumes everything is a single scene, and just uses a static IPB
    // pattern: IBBPBBPBBPBB
    // First Value Pushed: Temporal Reference (Frame Number)
    // Second Value Pushed: See interpretation below
    // Output Interpretation:
    // 1 = I-Picture
    // 2 = P-Picture
    // 3 = B-Picture
    int frameno;

    init {
        frameno = 0;
    }
    work pop (width*height*3) push 2 {
        push(frameno);
        for (int i = 0; i < width*height*3; i++) {
            pop();
        }
        int pushval;
        int framecount = frameno % 12;
        if (framecount == 0) {
            pushval = 1;
        } else if (framecount == 3 || framecount == 6 || framecount == 9) { 
            pushval = 2;
        } else {
            pushval = 3;
        }
        if ((frameno == (numpictures-1)) && (pushval == 3)) {
            // If the last frame of the video is not a reference frame, 
            // make it one so that preceeding B pictures work correctly. 
            pushval = 2; 
        }
        println("frame " + frameno + " gets type " + pushval);
        push(pushval);      
        frameno++;
    }
}

/**
 * @internal
 */
int->int splitjoin PicturePreprocessing(int width, int height, int numpictures, int downsampled_data_per_image) {
    split duplicate;
    add AssignPictureType(width, height, numpictures);
    add TransformPicture(width, height);
    join roundrobin(2, downsampled_data_per_image);
}

/**
 * @internal
 */
int->int filter ReorderPictures(int downsampled_data_per_image) {
    int picture_data_size = 2+downsampled_data_per_image;
    // This isn't ENTIRELY unbounded - it may be bounded by the implementation of PicturePreprocessing
    // and its implementation - in particular the vbv buffer concept might come into play here, but
    // I'll worry about that later TODO.
    boolean ran;
    // FEATURETODO - change when phases can take parameters
    int PushAheadFrameThrough_nextIPframe;

    init {
        ran = false;
    }

    work pop * push * {
        // How this works: On the first execution this filter pushes an I-frame through. On subsequent
        // executions it pushes an I or P frame through, immediately followed by all B frames that
        // refer to the past two I/P frames.
        if (!ran) {
            ran = true;
            PushFrameThrough();   
        } else {
            int nextIPframe = 0;
            // Find the next I frame
            while (peek(nextIPframe*picture_data_size+1) == 3) {
                nextIPframe++;
            }
            // Push that frame through
            PushAheadFrameThrough_nextIPframe = nextIPframe;
            PushAheadFrameThrough();
            while (peek(1) == 3) {
                PushFrameThrough();
            }
            PopFrameOff();
        }
    }

    phase PushAheadFrameThrough push picture_data_size pop * {
        for (int i = 0; i < picture_data_size; i++) {
            push(peek(PushAheadFrameThrough_nextIPframe*picture_data_size+i));
        }
    }

    phase PopFrameOff pop picture_data_size {
        deadpop(picture_data_size);
    }

    phase PushFrameThrough push picture_data_size pop picture_data_size {
        pushpop(picture_data_size);
    }
}

/**
 * @internal
 */
int->int pipeline MacroBlockEncode(int[64] intra_quantiser_matrix, 
                                   int[64] non_intra_quantiser_matrix,
                                   int intra_dc_precision, 
                                   int q_scale_type,
                                   int pixeldata_per_macroblock) {
    add splitjoin {
        split roundrobin(1, pixeldata_per_macroblock);
        add Identity<int>;
        add DCT8x8_ieee;
        join roundrobin(1, pixeldata_per_macroblock);
    }
    add Quantisation(intra_quantiser_matrix, 
                     non_intra_quantiser_matrix, 
                     intra_dc_precision, 
                     q_scale_type,
                     pixeldata_per_macroblock);
    add int->int splitjoin {
        split roundrobin(5, pixeldata_per_macroblock);
        add Identity<int>;
        add ZigZagOrdering;
        join roundrobin(5, pixeldata_per_macroblock);
    }
}

/**
 * @internal
 */
int->int splitjoin MacroBlockAndMotionVectorDecode(int[64] default_intra_quantiser_matrix,
                                                   int[64] default_non_intra_quantiser_matrix,
                                                   int intra_dc_precision,
                                                   int q_scale_type,
                                                   int width,
                                                   int height,
                                                   int pixeldata_per_macroblock) {
    split roundrobin(pixeldata_per_macroblock+5, 8, 1);
    add pipeline {
        add int->int splitjoin {
            split roundrobin(5, pixeldata_per_macroblock);
            add Identity<int>;
            add ZigZagUnordering;
            join roundrobin(5, pixeldata_per_macroblock);
        }
        add undoQuantisation(default_intra_quantiser_matrix, 
                             default_non_intra_quantiser_matrix,
                             intra_dc_precision, 
                             q_scale_type,
                             pixeldata_per_macroblock);
        add iDCT8x8_ieee;
    }
    add MotionVectorDecodeNoMessage(width/16);
    add Identity<int>;
    join roundrobin(pixeldata_per_macroblock, 4, 1);
}

/**
 * @internal
 */
int->int pipeline DecodeAndSendBackReferenceFrame(int[64] default_intra_quantiser_matrix,
                                                  int[64] default_non_intra_quantiser_matrix,
                                                  int intra_dc_precision,
                                                  int q_scale_type,
                                                  int width,
                                                  int height,
                                                  portal<MotionEstimation> portal_fwdMotion,
                                                  portal<MotionEstimation> portal_bckMotion,
                                                  int downsampled_data_per_image,
                                                  int pixeldata_per_macroblock) {

    int macroblock_output_data_size = downsampled_data_per_image*(pixeldata_per_macroblock+5+8+1)/pixeldata_per_macroblock;

    int downsample_data_size = downsampled_data_per_image;
    int extended_data_size = downsample_data_size*(pixeldata_per_macroblock+5)/pixeldata_per_macroblock;
    add int->int splitjoin { 
        split roundrobin(2, macroblock_output_data_size);
        add Identity<int>;
        add MacroBlockAndMotionVectorDecode(default_intra_quantiser_matrix,
                                            default_non_intra_quantiser_matrix,
                                            intra_dc_precision,
                                            q_scale_type,
                                            width,
                                            height,
                                            pixeldata_per_macroblock);
        join roundrobin(2, extended_data_size);
    }
    
    add SendBackReferenceFrameEncoder(width, 
                                      height, 
                                      extended_data_size, 
                                      portal_fwdMotion, 
                                      portal_bckMotion);
}

/**
 * @internal
 */
int->int filter SendBackReferenceFrameEncoder(int width, 
                                              int height, 
                                              int extended_data_size,
                                              portal<MotionEstimation> portal_fwdMotion,
                                              portal<MotionEstimation> portal_bckMotion) {
    // The word "Encoder" is at the end to avoid namespace conflicts with the SendBackReferenceFrame
    // filter in the decoder, which is similar.
    int[width][height] backward_y_data;
    int[width/2][height/2] backward_cb_data;
    int[width/2][height/2] backward_cr_data;
    int[width/16][height/16][4] backward_motion_vectors;
    int backward_frametype;
    boolean skipframe; // skip sending the first frame backwards
    
    init {
        skipframe = true;
        backward_frametype = 0;
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                backward_y_data[x][y] = 0;
            }
        }
        for (int x = 0; x < width/2; x++) {
            for (int y = 0; y < height/2; y++) {
                backward_cb_data[x][y] = 0;
                backward_cr_data[x][y] = 0;
            }
        }
        for (int x = 0; x < width/16; x++) {
            for (int y = 0; y < height/16; y++) {
                for (int z = 0; z < 4; z++) {
                    backward_motion_vectors[x][y][z] = 0;
                }
            }
        }
    }

    work pop extended_data_size+2 push 1 {
        int[width][height] y_data;
        int[width/2][height/2] cb_data;
        int[width/2][height/2] cr_data;
        int[width/16][height/16][4] motion_vectors;
        
        int frameno = pop();
        int frametype = pop();
        
        if (frametype < 3) {               
            for (int macroblocky = 0; macroblocky < height/16; macroblocky++) {
                for (int macroblockx = 0; macroblockx < width/16; macroblockx++) {
                    for (int blocky = 0; blocky < 2; blocky++) {
                        for (int blockx = 0; blockx < 2; blockx++) {
                            for (int y = 0; y < 8; y++) {
                                for (int x = 0; x < 8; x++) {
                                    y_data[macroblockx*16+blockx*8+x][macroblocky*16+blocky*8+y] = pop();
                                }
                            }
                        }
                    }
                    for (int y = 0; y < 8; y++) {
                        for (int x = 0; x < 8; x++) {
                            cb_data[macroblockx*8+x][macroblocky*8+y] = pop();
                        }
                    }
                    for (int y = 0; y < 8; y++) {
                        for (int x = 0; x < 8; x++) {
                            cr_data[macroblockx*8+x][macroblocky*8+y] = pop();
                        }
                        }
                    for (int i = 0; i < 4; i++) {
                        motion_vectors[macroblockx][macroblocky][i] = pop();
                    }                       
                    deadpop(1);                        
                }
            }
            portal_fwdMotion.referencePic(y_data, 
                                          cb_data, 
                                          cr_data, 
                                          motion_vectors, 
                                          frametype) [1:1];
            if (!skipframe) {
                portal_bckMotion.referencePic(backward_y_data, 
                                              backward_cb_data, 
                                              backward_cr_data, 
                                              backward_motion_vectors, 
                                              backward_frametype) [1:1];
            } else {
                skipframe = false;
            }
            backward_frametype = frametype;
            for (int x = 0; x < width; x++) {
                for (int y = 0; y < height; y++) {
                    backward_y_data[x][y] = y_data[x][y];
                }
            }
            for (int x = 0; x < width/2; x++) {
                for (int y = 0; y < height/2; y++) {
                    backward_cb_data[x][y] = cb_data[x][y];
                    backward_cr_data[x][y] = cr_data[x][y];
                }
            }
            for (int x = 0; x < width/16; x++) {
                for (int y = 0; y < height/16; y++) {
                    for (int z = 0; z < 4; z++) {
                        backward_motion_vectors[x][y][z] = motion_vectors[x][y][z];
                    }
                }
            }
        } else {
            deadpop(extended_data_size);
        }
        push(1999);
    }
}

/**
 * @internal
 */
int->int filter undoQuantisation(int[64] intra_quantiser_matrix, 
                                 int[64] non_intra_quantiser_matrix,
                                 int intra_dc_precision, 
                                 int q_scale_type,
                                 int pixeldata_per_macroblock) {
    // FEATURETODO - Move to globals when globals working properly - also out of decoder
    // (cite 1, P. 70 Table 7-6)
    int[2][32] quantiser_scale =
        // Note that quantiser_scale[x][0] is a Forbidden Value
    {{ 0,  2,  4,  6,  8, 10, 12, 14,
       16, 18, 20, 22, 24, 26, 28, 30,
       32, 34, 36, 38, 40, 42, 44, 46,
       48, 50, 52, 54, 56, 58, 60, 62},
     { 0,  1,  2,  3,  4,  5,  6,  7,
       8, 10, 12, 14, 16, 18, 20, 22,
       24, 28, 32, 36, 40, 44, 48, 52, 
       56, 64, 72, 80, 88, 96, 104, 112}};
    int[4] intra_dc_mult;

    init {
        intra_dc_mult[0] = 8;
        intra_dc_mult[1] = 4;
        intra_dc_mult[2] = 2;
        intra_dc_mult[3] = 1;
    }

    work pop (pixeldata_per_macroblock+5) push pixeldata_per_macroblock {
        int a = pop();
        if (a != 3278) {
            println("Error - Bitstream must be missaligned" + a);
        }
        int quantiser_scale_code = pop();
        int motion_forward = pop();
        int motion_backward = pop();
        int macroblock_intra = pop();
        // See (cite 1, P. 71) for more details.
        int k = 0;
        int W = 0;
        for (int block = 0; block < 6; block++) { 
            for (int count = 0; count < 64; count++) {
                int QF = pop();
                if (macroblock_intra == 1) {
                    k = 0;
                    W = intra_quantiser_matrix[count];
                } else {
                    if (QF > 0) {
                        k = 1;
                    } else if (QF < 0) {
                        k = -1;
                    } else {
                        k = 0;
                    }
                    W = non_intra_quantiser_matrix[count];
                }
                int F;
                if (count == 0 && macroblock_intra == 1) {
                    F = QF * intra_dc_mult[intra_dc_precision];
                } else {
                    F = (2*QF+k)*(W*quantiser_scale[q_scale_type][quantiser_scale_code])/32;
                }
                push(F);
            }
        }
    }
} 

/**
 * @internal
 */
int->int filter Quantisation(int[64] intra_quantiser_matrix, 
                             int[64] non_intra_quantiser_matrix,
                             int intra_dc_precision, 
                             int q_scale_type,
                             int pixeldata_per_macroblock) {
    // FEATURETODO - Move to globals when globals working properly - also out of decoder
    // (cite 1, P.70 Table 7-6)
    int[2][32] quantiser_scale =
        // Note that quantiser_scale[x][0] is a Forbidden Value
    {{ 0,  2,  4,  6,  8, 10, 12, 14,
       16, 18, 20, 22, 24, 26, 28, 30,
       32, 34, 36, 38, 40, 42, 44, 46,
       48, 50, 52, 54, 56, 58, 60, 62},
     { 0,  1,  2,  3,  4,  5,  6,  7,
       8, 10, 12, 14, 16, 18, 20, 22,
       24, 28, 32, 36, 40, 44, 48, 52, 
       56, 64, 72, 80, 88, 96, 104, 112}};
    int[4] intra_dc_mult;

    init {
        intra_dc_mult[0] = 8;
        intra_dc_mult[1] = 4;
        intra_dc_mult[2] = 2;
        intra_dc_mult[3] = 1;
    }

    // TODO temp - for now only use intra quantization, and 
    // no changes in the scaling.
    work pop pixeldata_per_macroblock+1 push pixeldata_per_macroblock+5 {
        int macroblock_intra = pop();
        push(3278);
        int quantiser_scale_code = 1;
        push(quantiser_scale_code);
        push(0); // motion_forward
        push(0); // motion_backward
        push(macroblock_intra);
        // See (cite 1, P. 71) for more details.
        // macroblock is INTRA TODO temp
        int k = 0;
        int W = 0;
        for (int block = 0; block < 6; block++) { // TODO move out
            for (int count = 0; count < 64; count++) {
                int F = pop();
                if (macroblock_intra == 1) {
                    k = 0;
                    W = intra_quantiser_matrix[count];
                } else {
                    if (F > 0) {
                        k = 1;
                    } else if (F < 0) {
                        k = -1;
                    } else {
                        k = 0;
                    }
                    W = non_intra_quantiser_matrix[count];
                }         
                int QF;
                if (count == 0 && macroblock_intra == 1) {
                    QF = F / intra_dc_mult[intra_dc_precision];
                } else {
                    QF = ((32*F/(W*quantiser_scale[q_scale_type][quantiser_scale_code]))-k)/2;
                }
                push(QF);
            } 
        }
    }
}

/**
 * @internal
 */
int->int filter ZigZagOrdering {
    int[64] Ordering = {00, 01, 08, 16, 09, 02, 03, 10,
                        17, 24, 32, 25, 18, 11, 04, 05,
                        12, 19, 26, 33, 40, 48, 41, 34,
                        27, 20, 13, 06, 07, 14, 21, 28,
                        35, 42, 49, 56, 57, 50, 43, 36,
                        29, 22, 15, 23, 30, 37, 44, 51,
                        58, 59, 52, 45, 38, 31, 39, 46,
                        53, 60, 61, 54, 47, 55, 62, 63};
    work pop 64 push 64 {
        for (int i = 0; i < 64; i++) {
            push(peek(Ordering[i]));
        }
        for (int i = 0; i < 64; i++) {
            pop();
        }
    }
}

/**
 * @internal
 */
int->bit filter MPEGStreamGenerator(int width, int height, int numpictures,
                                    int[64] intra_quantiser_matrix,
                                    int[64] non_intra_quantiser_matrix,
                                    int intra_dc_precision,
                                    int q_scale_type) {
    boolean ran;

    init {
        ran = false;
    }  

    // TODO - might be able to put bounds on this.
    work pop * push * {
        if (!ran) {
            println("Writing M2V File...");
            ran = true;
            int tempval;

            // video_sequence() (cite 1, P.25)

            // sequence_header() (cite 1, P. 26)
            tempval = 0x000001B3;
            pushs(32, tempval);

            int horizontal_size = width;
            int mb_width = (horizontal_size+15) / 16;
            int vertical_size = height;
            int mb_height = (vertical_size+15) / 16;
      
            // Writing Sequence Header      
            int horizontal_size_value = horizontal_size & 0xFFF;
            int vertical_size_value = vertical_size & 0xFFF;
            pushs(12, horizontal_size_value);
            pushs(12, vertical_size_value);

            int aspect_ratio_information = 1;
            // (cite 1, P.41 Table 6-3)
            pushs(4, aspect_ratio_information);

            int frame_rate_code = 4; 
            // (cite 1, P.41-42 Table 6-4)
            pushs(4, frame_rate_code);

            int bit_rate = 1500000; // TODO - Fixed for the sample, might
            // be worthwhile to waste some time understanding
            // what this number means. It doesn't seem very important.
            // (cite 1, P.42)
            bit_rate /= 400;      

            int bit_rate_value = bit_rate & ((0xFFFF << 2) | 0xF);
            // 0b1111 1111 1111 1111 11
            pushs(18, bit_rate_value);

            add_marker_bit();

            int vbv_buffer_size = 66; // TODO - Fixed for the sample, might
                                // be worthwhile to waste some time understanding
                                // what this number means. It doesn't seem very important.

            int vbv_buffer_size_value = vbv_buffer_size & ((0xFF << 2) | 0xF);
            pushs(10, vbv_buffer_size_value);
            int constrained_parameters_flag = 0;
            pushs(1, constrained_parameters_flag);
            // (cite 1, P. 43)

            // Default Values for the quantiser_matrices
            int[64] default_intra_quantiser_matrix = 
            { 8, 16, 19, 22, 26, 27, 29, 34,
              16, 16, 22, 24, 27, 29, 34, 37,
              19, 22, 26, 27, 29, 34, 34, 38,
              22, 22, 26, 27, 29, 34, 37, 40,
              22, 26, 27, 29, 32, 35, 40, 48,
              26, 27, 29, 32, 35, 40, 48, 58,
              26, 27, 29, 34, 38, 46, 56, 69,
              27, 29, 35, 38, 46, 56, 69, 83};
            int[64] default_non_intra_quantiser_matrix =
            {16, 16, 16, 16, 16, 16, 16, 16,
             16, 16, 16, 16, 16, 16, 16, 16,
             16, 16, 16, 16, 16, 16, 16, 16,
             16, 16, 16, 16, 16, 16, 16, 16,
             16, 16, 16, 16, 16, 16, 16, 16,
             16, 16, 16, 16, 16, 16, 16, 16,
             16, 16, 16, 16, 16, 16, 16, 16,
             16, 16, 16, 16, 16, 16, 16, 16};

            // Assumes no alternate_scan
            boolean intra_is_default = true;
            boolean non_intra_is_default = true;
            for (int i = 0; i < 64; i++) {
                if (default_intra_quantiser_matrix[i] != intra_quantiser_matrix[i]) {
                    intra_is_default = false;
                }
                if (default_non_intra_quantiser_matrix[i] != non_intra_quantiser_matrix[i]) {
                    non_intra_is_default = false;
                }
            }

            int load_intra_quantiser_matrix;
            if (intra_is_default) {
                load_intra_quantiser_matrix = 0;
                pushs(1, load_intra_quantiser_matrix);
            } else {
                load_intra_quantiser_matrix = 1;
                pushs(1, load_intra_quantiser_matrix);
                for (int i = 0; i < 64; i++) {
                    pushs(8, intra_quantiser_matrix[i]);
                }
            }
            int load_non_intra_quantiser_matrix;
            if (non_intra_is_default) {
                load_non_intra_quantiser_matrix = 0;
                pushs(1, load_non_intra_quantiser_matrix);
            } else {
                load_non_intra_quantiser_matrix = 1;
                pushs(1, load_non_intra_quantiser_matrix);
                for (int i = 0; i < 64; i++) {
                    pushs(8, non_intra_quantiser_matrix[i]);
                }
            }

            // sequence_extension() (cite 1, P. 28)
            tempval = 0x000001B5;
            pushs(32, tempval);

            int extension_start_code_identifier = 1;
            pushs(4, extension_start_code_identifier);

            int profile_and_level_indication = 72;
            // We don't really care about the profile_and_level indicator - this matters if this implementation
            // were fully MPEG2 compliant to some profile/level, but it isn't.
            pushs(8, profile_and_level_indication);

            int progressive_sequence = 1; // Program Limitation
            // progressive_sequence 1: allows only progressive frames
            pushs(1, progressive_sequence);

            int block_count = 6; // (cite 1, P. 62)
            int chroma_format = 1;
            // chroma_format 4:2:0
            // NOTE - This chroma format is assumed in a huge number of places throughout the whole bitstream.
            // There's no  efficient way to support multiple chroma formats until there are reprogrammable
            // splitters/joiners in the language. FEATURETODO
            pushs(2, chroma_format);
      
            int horizontal_size_extension = horizontal_size >> 12;
            pushs(2, horizontal_size_extension);

            int vertical_size_extension = vertical_size >> 12;
            pushs(2, vertical_size_extension);

            int bit_rate_extension = bit_rate >> 18;
            pushs(12, bit_rate_extension);
            // (cite 1, P.42)
      
            add_marker_bit();

            int vbv_buffer_size_extension = vbv_buffer_size >> 10;
            pushs(8, vbv_buffer_size_extension);

            // low_delay 0 indicates that sequence is allowed to contain B-pictures
            int low_delay = 0;
            pushs(1, low_delay);

            // (cite 1, P. P.41)
            // These values are pretty much useless
            int frame_rate_extension_n = 0;
            pushs(2, frame_rate_extension_n);
            int frame_rate_extension_d = 0;
            pushs(2, frame_rate_extension_d);

            // TODO - This can later be parallelized
            // Start of Group_of_Pictures

            // group_of_pictures_header() (cite 1, P.29)

            tempval = 0x000001B8;
            pushs(32, tempval);

            // -- Time Code - Not Used in Decoding Process --
            int drop_frame_flag = 0;
            int time_code_hours = 0;
            int time_code_minutes = 0;
            int time_code_seconds = 0;
            int time_code_pictures = 0;
            // (cite 1, P.49)
            pushs(1, drop_frame_flag);
            pushs(5, time_code_hours);
            pushs(6, time_code_minutes);
            add_marker_bit();
            pushs(6, time_code_seconds);
            pushs(6, time_code_pictures);
            // -- End of Time Code

            int closed_gop = 0;
            pushs(1, closed_gop);
            int broken_link = 0;
            pushs(1, broken_link);

            for (int pic = 0; pic < numpictures; pic++) {
                // TODO Start of picture - this might later be broken up
                // picture_header() (cite 1, P.30)
                tempval = 0x00000100;
                pushs(32, tempval);

                // (cite 1, P.50)
                // The picture in time order, basically
                int temporal_reference = pop(); 
                pushs(10, temporal_reference);

                int picture_coding_type = pop();     
                if (picture_coding_type < 1 || picture_coding_type > 3) {
                    println("   Error: Forbidden picture_coding_type " + picture_coding_type);
                }
                // picture_coding_type = 1 -> I-picture
                // picture_coding_type = 2 -> P-picture
                // picture_coding_type = 3 -> B-picture
                pushs(3, picture_coding_type);

                // TODO unknown interpretation for vbv_delay, (cite 1, P.50)
                // I really have no idea what this is for. The value I am going
                // to assign it is the value that I found for one frame from
                // one video, and I'm going to hope that, like me, most decoders
                // don't really care about this value.
                // If there are weird problems later, especially anything related
                // to playback timing in something like mplayer, I would assume this
                // is at fault.
                int vbv_delay = 61589;
                pushs(16, vbv_delay);

                // The following is not used by the MPEG-2 specification (cite 1, P.51)
                // Supposed to have certain values, but not guaranteed for most files.
                // (cite 1, P. 51)
                if (picture_coding_type == 2 || picture_coding_type == 3) {
                    int full_pel_forward_vector = 0;
                    pushs(1, full_pel_forward_vector);
                    int forward_f_code = 7;
                    pushs(3, forward_f_code);
                } 
                if (picture_coding_type == 3) {
                    int full_pel_backward_vector = 0;
                    pushs(1, full_pel_backward_vector);
                    int backward_f_code = 7;
                    pushs(3, backward_f_code);
                }

                // Must be 0 for MPEG-2, 1 for supersets of MPEG-2.
                tempval = 0;
                pushs(1, tempval);
      
                // picture_coding_extension() (cite 1, P.30)
                tempval = 0x000001B5;
                pushs(32, tempval);

                extension_start_code_identifier = 0x8;
                pushs(4, extension_start_code_identifier);
            
                int[2][2] f_code;
                if (picture_coding_type == 1) {
                    f_code[0][0] = 0xF;
                    f_code[0][1] = 0xF;
                    f_code[1][0] = 0xF;
                    f_code[1][1] = 0xF; 
                } else if (picture_coding_type == 2) {
                    f_code[0][0] = 9;
                    f_code[0][1] = 9;
                    f_code[1][0] = 0xF;
                    f_code[1][1] = 0xF; 
                } else {
                    f_code[0][0] = 9;
                    f_code[0][1] = 9;
                    f_code[1][0] = 9;
                    f_code[1][1] = 9; 
                }
                pushs(4, f_code[0][0]);
                pushs(4, f_code[0][1]);
                pushs(4, f_code[1][0]);
                pushs(4, f_code[1][1]);
                // (cite 1, P.51)

                pushs(2, intra_dc_precision);

                int picture_structure = 3;
                pushs(2, picture_structure);
 
                int top_field_first = 0;
                pushs(1, top_field_first);

                int frame_pred_frame_dct = 1;
                pushs(1, frame_pred_frame_dct);

                int concealment_motion_vectors = 0;
                // not using concealment_motion_vectors...it just makes everything that
                // much more complicated.
                pushs(1, concealment_motion_vectors);

                pushs(1, q_scale_type);      

                int intra_vlc_format = 0;
                pushs(1, intra_vlc_format);

                int alternate_scan = 0;
                pushs(1, alternate_scan);

                int repeat_first_field = 0;
                pushs(1, repeat_first_field);

                // It should be 1 for 4:2:0 chroma.
                int chroma_420_type = 1;
                pushs(1, chroma_420_type);
                // (cite 1, P.53)

                int progressive_frame = 1;
                pushs(1, progressive_frame);

                int composite_display_flag = 0;
                pushs(1, composite_display_flag);

                // picture_data() (cite 1, P.34)
      
                // I assume 1 slice per macroblock line, for now
                // TODO eventually parallelize this slicing as best as possible.
                for (int slice_vertical_position = 1; slice_vertical_position <= mb_height; slice_vertical_position++) {
                    // slice() (cite 1, P.34)
                    // Reset motion vector predictors, (cite 1, P.77-80)

                    tempval = 0x000001;
                    pushs(24, tempval);
                    pushs(8, slice_vertical_position);

                    if (vertical_size > 2800)
                        println("Error - Program Limitation: Doesn't handle vertical_slices > 2800");
                    int mb_row, previous_macroblock_address;
                    mb_row = slice_vertical_position - 1;
                    previous_macroblock_address = (mb_row * mb_width) - 1;

                    tempval = pop();
                    if (tempval != 3278)
                        println("Error - Stream Misaligned Somehow - got " + tempval + " expected " + 3278); 
                    //          else
                    //            println("Reading Macroblock: " + ((slice_vertical_position-1) * mb_width));

                    int quantiser_scale_code = pop();
                    pushs(5, quantiser_scale_code);
        
                    tempval = 0;
                    pushs(1, tempval);
        
                    int[3] dc_dct_pred; // (cite 1, P.64-65)
                    // I'm not sure about this - see P. 64 and getpic.c Line 1180
                    // they disagree TODO
                    dc_dct_pred[0] = 0; // (int) pow(2,actual_intra_dc_precision - 1);
                    dc_dct_pred[1] = 0; // (int) pow(2,actual_intra_dc_precision - 1);
                    dc_dct_pred[2] = 0; // (int) pow(2,actual_intra_dc_precision - 1);
        
                    for (int slice_horizontal_position = 1; slice_horizontal_position <= mb_width; slice_horizontal_position++) {
                        // macroblock() (cite 1, P.35)
                        // Note - temporary TODO - for now we allow NO skipped macroblocks
                        int macroblock_address_increment = 1;
                        variable_length_encode(macroblock_address_increment, const_macroblock_address_inc);
                        int macroblock_address = previous_macroblock_address + macroblock_address_increment;
                        previous_macroblock_address = macroblock_address;
                        int mb_column = macroblock_address % mb_width;
          
                        int macroblock_quant;

                        if (slice_horizontal_position != 1) {
                            tempval = pop();
                            if (tempval != 3278)
                                println("Error - Stream Misaligned Somehow got " + tempval + " expected " + 3278);
                            //              else           
                            //                println("Reading Macroblock: " + ((slice_vertical_position-1)*mb_width + slice_horizontal_position-1));
                            tempval = pop();
                            if (quantiser_scale_code == tempval) {
                                macroblock_quant = 0;
                            } else {
                                macroblock_quant = 1;
                            }
                            quantiser_scale_code = tempval;
                        } else {
                            // If it's the first block of the slice we already popped it off and included it above
                            // in the slice code section, so there's no reason to do it again.
                            macroblock_quant = 0;
                        }

                        int macroblock_motion_forward = pop();
                        int macroblock_motion_backward = pop();
                        // Must be 0 for intra blocks TODO generalize
                        int macroblock_pattern = 0; 
                        // For now - we are going to force all blocks to be encoded temporaly TODO
                        int macroblock_intra = pop();

                        int spatial_temporal_weight_code_flag = 0;

                        int[block_count][64] QFS;

                        for (int i = 0; i < block_count; i++) {
                            for (int j = 0; j < 64; j++) {
                                QFS[i][j] = pop();
                            }
                            // block(i) (cite 1, P.38)
                            // if macroblocks are skipped, predictor is reset TODO
                        }

                        int[2][2][2] motion_code;
                        int[2][2][2] motion_residual;
                        for (int i = 0; i < 2; i++) {
                            for (int j = 0; j < 2; j++) {
                                for (int k = 0; k < 2; k++) {
                                    if (i == 0) {
                                        motion_code[i][j][k] = pop();
                                        motion_residual[i][j][k] = pop();
                                    } else {
                                        motion_code[i][j][k] = 0;
                                        motion_residual[i][j][k] = 0;
                                    }
                                }
                            }
                        }

                        int macroblock_decision_data = pop(); // which vectors to use if any

                        macroblock_motion_backward = 0;
                        macroblock_motion_forward = 0;
                        if (macroblock_decision_data == 2 || macroblock_decision_data == 4) {
                            if (picture_coding_type == 1) {
                                println("Error - Can't have motion with an intra coded picture");
                            }
                            macroblock_motion_forward = 1;
                        }
                        if (macroblock_decision_data == 3 || macroblock_decision_data == 4) {
                            if (picture_coding_type == 1) {
                                println("Error - Can't have motion with an intra coded picture");
                            }
                            macroblock_motion_backward = 1;
                        }
                        if (macroblock_decision_data == 1) {
                            macroblock_intra = 1;
                            macroblock_pattern = 0;
                        } else  {
                            macroblock_intra = 0;
                            macroblock_pattern = 0;
                            for (int i = 0; i < block_count; i++) {
                                for (int j = 0; j < 64; j++) {
                                    if (QFS[i][j] != 0)
                                        macroblock_pattern = 1;
                                }
                            }
                        }

                        tempval = 0;
                        tempval = tempval | macroblock_quant;
                        tempval <<= 1;
                        tempval = tempval | macroblock_motion_forward;
                        tempval <<= 1;
                        tempval = tempval | macroblock_motion_backward;
                        tempval <<= 1;
                        tempval = tempval | macroblock_pattern;
                        tempval <<= 1;
                        tempval = tempval | macroblock_intra;
                        tempval <<= 1;
                        tempval = tempval | spatial_temporal_weight_code_flag;

                        if (picture_coding_type == 1) { // I-picture
                            variable_length_encode(tempval, const_macroblock_type_Ipictures);
                        } else if (picture_coding_type == 2) { // P-picture
                            variable_length_encode(tempval, const_macroblock_type_Ppictures);
                        } else if (picture_coding_type == 3) { // B-picture
                            variable_length_encode(tempval, const_macroblock_type_Bpictures);
                        }

                        // (cite 1, P.60, Table 6-17)
                        int prediction_type = 2; // 0 = reserved, 1 = field-based, 2=frame-based, 3=dual-prime
                        int mv_format = 1; // 0 = field, 1 = frame
                        int motion_vector_count = 1;
                        int dmv = 0;

                        if (macroblock_quant == 1) {
                            pushs(5, quantiser_scale_code);
                        }
         
                        // Motion Vector Predictor Reset, (cite 1, P.80)     
                        if ((macroblock_intra == 1) ||
                            (macroblock_intra == 0 && macroblock_motion_forward == 0 && 
                             picture_coding_type == 2)) {          
                            // not clear if we should do anything here TODO
                        }
                        
                        if (macroblock_motion_forward == 1) {
                            // motion_vectors(0); (cite 1, P.36, 61)
                            // motion_vector(0,0);
                            // (cite 1, P.61)
                            for (int t = 0; t < 2; t++) {
                                variable_length_encode(motion_code[0][0][t], const_motion_code);                            
                                if ((f_code[0][t] != 1) && (motion_code[0][0][t] != 0)) {
                                    int r_size = f_code[0][t]-1;
                                    pushs(r_size, motion_residual[0][0][t]);
                                }
                            }
                        }

                        if (macroblock_motion_backward == 1) {
                            // motion_vectors(1); (cite 1, P.36, 61)
                            // motion_vector(0,1);
                            // (cite 1, P.61)
                            for (int t = 0; t < 2; t++) {
                                variable_length_encode(motion_code[0][1][t], const_motion_code);
                                if ((f_code[1][t] != 1) && (motion_code[0][1][t] != 0)) {
                                    int r_size = f_code[1][t]-1;
                                    pushs(r_size, motion_residual[0][1][t]);
                                }
                            }
                        }

                        int[12] pattern_code;
                        // TODO - later when skipped blocks allowed, change
                        // The meaning of pattern_code is defined somewhat poorly
                        // on (cite 1, P.62) in the code block
                        for (int i = 0; i < 12; i++) {
                            if (macroblock_intra == 1) {
                                pattern_code[i] = 1;
                            } else {
                                pattern_code[i] = 0;
                            }
                        }

                        if (macroblock_pattern == 1) {
                            // coded_block_pattern() (cite 1, P.37, 62)
                            // For now, if the pattern is 1, we want to encode ALL of the blocks automatically, for now TODO
                            for (int i = 0; i < block_count; i++) {
                                boolean allzeroes = true;
                                for (int j = 0; j < 64; j++) {
                                    if (QFS[i][j] != 0)
                                        allzeroes = false;
                                }
                                if (allzeroes) {
                                    pattern_code[i] = 0;
                                } else {
                                    pattern_code[i] = 1;
                                }
                            }
                            int cbp = 0;
                            for (int i = 0; i < 6; i++) {
                                cbp <<= 1;
                                cbp = cbp | pattern_code[i];
                            }
                            if (chroma_format == 1 && cbp == 0) {
                                println("Error - cbp not allowed to be zero in 4:2:0 format, should have caught this earlier.");
                            }
                            if (chroma_format >= 2) {
                                println("Error - Program Limitation: Doesn't handle non 4:2:0 chroma formats");
                            }
                            variable_length_encode(cbp, const_coded_block_patterns);
                        }

                        for (int i = 0; i < block_count; i++) {
                            int QFS_current;
                            QFS_current = 0;
                            if (pattern_code[i] == 1) {
                                if (macroblock_intra == 1) {
                                    if (i < 4) {
                                        int dc_dct_luminance = QFS[i][0];
                                        int dct_diff = dc_dct_luminance - dc_dct_pred[0];
                                        int dc_dct_size_luminance;
                                        if (dct_diff == 0) {
                                            dc_dct_size_luminance = 0;
                                            variable_length_encode(dc_dct_size_luminance, const_dct_dc_size_luminance);
                                        } else {
                                            int temp = (int) abs(dct_diff);
                                            dc_dct_size_luminance = 0;
                                            while (temp != 0) {
                                                temp /= 2;
                                                dc_dct_size_luminance++;
                                            }
                                            variable_length_encode(dc_dct_size_luminance, const_dct_dc_size_luminance);
                                            int half_range = (int) pow(2,dc_dct_size_luminance-1);
                                            int dc_dct_differential_luminance;
                                            if (dct_diff > 0) {
                                                dc_dct_differential_luminance = dct_diff;
                                            } else {
                                                dc_dct_differential_luminance = (dct_diff + (2*half_range)) - 1;
                                            }
                                            pushs(dc_dct_size_luminance, dc_dct_differential_luminance);
                                        } 
                                        QFS_current++;        
                                        dc_dct_pred[0] = dc_dct_luminance;
                                    } else {
                                        int dc_dct_chrominance = QFS[i][0];
                                        int dct_diff = dc_dct_chrominance - dc_dct_pred[i-3];
                                        int dc_dct_size_chrominance;
                                        if (dct_diff == 0) {
                                            dc_dct_size_chrominance = 0;
                                            variable_length_encode(dc_dct_size_chrominance, const_dct_dc_size_chrominance);
                                        } else {
                                            int temp = (int) abs(dct_diff);
                                            dc_dct_size_chrominance = 0;
                                            while (temp != 0) {
                                                temp /= 2;
                                                dc_dct_size_chrominance++;
                                            }
                                            variable_length_encode(dc_dct_size_chrominance, const_dct_dc_size_chrominance);
                                            int half_range = (int) pow(2, dc_dct_size_chrominance-1);
                                            int dc_dct_differential_chrominance;
                                            if (dct_diff > 0) {
                                                dc_dct_differential_chrominance = dct_diff;
                                            } else {
                                                dc_dct_differential_chrominance = (dct_diff + (2*half_range)) - 1;
                                            } 
                                            pushs(dc_dct_size_chrominance, dc_dct_differential_chrominance);
                                        }  
                                        QFS_current++;
                                        dc_dct_pred[i-3] = dc_dct_chrominance;
                                    }
                                } else {
                                    dc_dct_pred[0] = 0;
                                    dc_dct_pred[1] = 0;
                                    dc_dct_pred[2] = 0;
                                }
                                int run = 0;
                                while (QFS_current < 64) {
                                    if (macroblock_intra == 0 && QFS_current == 0) {
                                        // This section here from end of Table B.14 and 7.2.2.2 (cite 1, P.66)
                                        if (QFS[i][0] == 1 || QFS[i][0] == -1) {
                                            if (QFS[i][0] == 1) {
                                                tempval = 2;
                                            } else {
                                                tempval = 3;
                                            }
                                            pushs(2, tempval);
                                            QFS_current++;
                                        }             
                                    }
                                    // For an understanding of this section see
                                    // (cite 1, 7.2.2 P.65-66)                                    
                                    if (QFS[i][QFS_current] == 0) {
                                        run++;
                                        if (run == 64 || QFS_current == 63) {
                                            if (QFS_current != 63) {
                                                println("Some ERROR ERROR ERROR");
                                            }
                                            if (run == 64) {
                                                println("Error - Cannot encode a block of all zeroes (should have been caught earlier)");
                                            } else {
                                                tempval = 2;
                                                pushs(2, tempval);
                                            }
                                        }                                       
                                        QFS_current++;
                                    } else {
                                        int level = (int) abs(QFS[i][QFS_current]);
                                        int sign = 0;
                                        if (QFS[i][QFS_current] > 0) {
                                            sign = 0;
                                        } else {
                                            sign = 1;
                                        }
                                        if (QFS[i][QFS_current] == -2280) {
                                            println("YEP HERE level  = " + level + " sign: " + sign);
                                        }
                                        boolean found = false;
                                        for (int c = 0; c < const_dct_coefficients_table_zero_len; c++) {
                                            // Regular run/level encoding 
                                            // We write it specially because not all combinations
                                            // are encoded, there are also the escape coded coefficients.
                                            if (const_dct_coefficients_table_zero[c].run == run &&
                                                const_dct_coefficients_table_zero[c].level == level) {
                                                int len = const_dct_coefficients_table_zero[c].len;
                                                tempval = const_dct_coefficients_table_zero[c].code;
                                                pushs(len, tempval);
                                                pushs(1, sign);
                                                found = true;
                                                c = const_dct_coefficients_table_zero_len;
                                            }
                                        }
                                        if (!found) {
                                            // Escape Coding
                                            tempval = 1;
                                            pushs(6, tempval);            
                                            pushs(6, run);
                                            pushs(1, sign);
                                            if (sign == 0) {
                                                level = QFS[i][QFS_current];
                                            } else {
                                                level = QFS[i][QFS_current] - 2048;
                                            }
                                            pushs(11, level);
                                        }
                                        run = 0;
                                        if (QFS_current == 63) {
                                            tempval = 2;
                                            pushs(2, tempval);
                                        }
                                        if (QFS_current == 64) {
                                            println("ERROR ERROR ERROR - here");
                                        }
                                        QFS_current++;
                                    }
                                }
                            } else {
                                // Block was skipped. I don't think we need to do anything.
                            }
                        }
                    }
                }
            }
            // Sequence End Code
            tempval = 0x000001B7;
            pushs(32, tempval);
            tempval = 0;
            // To force flush, below: FEATURETODO
            pushs(32, tempval);
            pushs(32, tempval);
            pushs(32, tempval);  
            pushs(32, tempval);
            println("Done Writing M2V File...");
        } else {
            //      println("Error - Trying to generate M2V file for a second time...");
        }
    }
}
