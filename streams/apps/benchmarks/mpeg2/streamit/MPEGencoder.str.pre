/*
 * Copyright 2005 by the Massachusetts Institute of Technology.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in
 * advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 */

/**
 * @description
 * This file contains functions that allow one to encode MPEG-2 compliant video. 
 * The code is based on the MPEG-2 specification (ISO/IEC 13818-2). The MPEG-2 encoder
 * is a work in progress, although it works within a limited test range. Throughout the 
 * source code, citations are made in cases where an understanding of the code would be
 * helped by looking at an outside source. The format I have chosen is 
 * (cite NUM#, LOOKUP_INFO). NUM=1 refers to ISO/IEC: 13818-2, and NUM=2 refers to the reference
 * MPEG implementation written in C, available at [www.mpeg.org].
 *
 * @author <a href="mailto:madrake@gmail.com">Matthew Drake</a>
 * @file MPEGencoder.str.pre
 * @version 1.0
 */

// Comments for readers of the StreamIt MPEG specification:
//
// TODO notes refer to parts of the MPEG-2 specification which this
// program does not yet handle, or assumptions made by the program.
// FEATURETODO notes refer to changes that ought to be made to the program,
// or support which can be added for more of the MPEG-2 specification, which
// is pending the addition of features to the StreamIt language compiler.
// In general I have tried to document my code, and refer to the MPEG-2
// specification whenever I used it. If you are looking at any particular
// block of code and aren't sure what it is doing, find the previous citation
// comment, and refer to the corresponding page in the MPEG 2 spec.

int->bit pipeline rawImageStream_to_MPEGStream(int width, int height, int numpictures) {
  // Eventually change so that these aren't passed around like parameters.
  int downsample_data_size = (width*height*3)/2;
  int actual_intra_dc_precision = 8;  
  // Default Values for the quantiser_matrices
  int[64] default_intra_quantiser_matrix = 
        { 8, 16, 19, 22, 26, 27, 29, 34,
         16, 16, 22, 24, 27, 29, 34, 37,
         19, 22, 26, 27, 29, 34, 34, 38,
         22, 22, 26, 27, 29, 34, 37, 40,
         22, 26, 27, 29, 32, 35, 40, 48,
         26, 27, 29, 32, 35, 40, 48, 58,
         26, 27, 29, 34, 38, 46, 56, 69,
         27, 29, 35, 38, 46, 56, 69, 83};
  int[64] default_non_intra_quantiser_matrix =
        {16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16};
  int q_scale_type = 0;

  add PicturePreprocessing(width, height);
  // Eventually Wrap in Programmable Splitjoin for Group of Pictures
  add ReorderPictures(2+downsample_data_size);
  // Eventually Wrap in Programmable Splitjoin for Slices - Also need to communicate frame type.

  add splitjoin {
    split roundrobin(2, downsample_data_size);
    add Identity<int>;
    add int->int splitjoin {
      split duplicate;
      add IntraMotionPrediction(64*6, 64*6+4);
      add ForwardMotionPrediction(64*6, 64*6+4, width, height);
      add BackwardMotionPrediction(64*6, 64*6+4);
      join roundrobin(64*6+4);
    }
    join roundrobin(2, 3*(downsample_data_size*(64*6+4)/(64*6)));
  }

  int mp_data_size = (downsample_data_size*(64*6+4)/(64*6));
  int mpd_data_size = (downsample_data_size*(64*6+5)/(64*6));

  add MotionPredictionDecision(mp_data_size, mpd_data_size);

  int macroblock_output_data_size = downsample_data_size*(64*6+5+8+1)/(64*6);

  add int->int splitjoin {
    split roundrobin(2, mpd_data_size);
    add Identity<int>;
    add splitjoin {
      split roundrobin(64*6, 4, 1);
      add MacroBlockEncode(default_intra_quantiser_matrix, default_non_intra_quantiser_matrix,
                           actual_intra_dc_precision-8, q_scale_type);
      add MotionVectorEncode();
      add Identity<int>;
      join roundrobin(64*6+5, 8, 1);
    }
    join roundrobin(2, macroblock_output_data_size);
  }

  add MPEGStreamGenerator(width, height, numpictures,
                          default_intra_quantiser_matrix, 
                          default_non_intra_quantiser_matrix, 
                          actual_intra_dc_precision-8,
                          q_scale_type);
}

int->int splitjoin MotionVectorEncode {
  split roundrobin(1);
  for (int i = 0; i < 4; i++) {
    add IndividualMotionVectorEncode();
  }
  join roundrobin(2);
}

int->int filter IndividualMotionVectorEncode() {
  // TODO This function hasn't been thoroughly checked for correctness yet.  
  int PMV;
  int f_code;

  init {
    PMV = 0;
    f_code = 9; // TODO temp
  }

  work pop 1 push 2 {
    int r_size = f_code-1;
    int f = 1 << r_size;
    int high = (16*f)-1;
    int low = ((-16)*f);
    int range = (32*f);
    int vectorp = pop();

    // TODO: Note - motion prediction vectors get reset at picture boundaries and I THINK
    // on slice changes. We need to reset these here. Upstream messaging on phase
    // boundaries is probably the way to go? Other than that I THINK that motion vectors
    // are working for the most part. 

/*    if (vectorp - range < low) {
      vectorp = vectorp - range;
    }
    if (vectorp + range > high) {
      vectorp = vectorp + range;
    } */ // TODO - not sure when the above is needed.

    int prediction = PMV;
    int delta = vectorp - prediction;

    int motion_code = 0;
    int motion_residual = 0;
    if ((f == 1) || delta == 0) {
      motion_code = delta;
    } else {
      int posdelta = (int) abs(delta);
      int temp3 = posdelta - 1;
      motion_residual = temp3 % f;
      int temp1 = temp3 - motion_residual;
      if (delta < 0) {
        motion_code = (-1*temp1)/f + 1;
      } else {
        motion_code = temp1/f + 1;
      }      
    }
    push(motion_code);
    push(motion_residual);

    PMV = vectorp;
  }
}

int->int filter MotionPredictionDecision(int mp_data_size, int mpd_data_size) {
  work pop 2+3*mp_data_size push 2+mpd_data_size {
    pushpop(1);
    // For now, always go with the forward predicted block for P pictures and backward blocks for B pictures TODO
    int picture_type = peek(0);
    pushpop(1);
    for (int macroblock = 0; macroblock < (mp_data_size/(64*6+4)); macroblock++) {
      int a = 64*6+4;
      if (picture_type == 1) { // I picture
        pushpop(a);
        deadpop(a);
        deadpop(a);
        push(1);
      } else if (picture_type == 2) { // P picture
        deadpop(a);
        pushpop(a);
        deadpop(a);
        push(2);
      } else { // B picture
        deadpop(a);
        deadpop(a);
        pushpop(a);
        push(3);
      }
      // the final value pushed follows this convention:
      // 1 = intra, 2 = forward, 3 = backward, 4 = both
    }
  }
}

int->int filter IntraMotionPrediction(int block_input_data_size, int block_output_data_size) {
  work pop block_input_data_size push block_output_data_size {
    pushpop(block_input_data_size);
    push(0);
    push(0);
    push(0);
    push(0);
  }
}

int->int filter ForwardMotionPrediction(int block_input_data_size, int block_output_data_size, int width, int height) {

  int[width][height] lum;
  int[width/2][height/2] cb;
  int[width/2][height/2] cr;

  int macroblock_count = (width/16)*(height/16);

  work pop macroblock_count*block_input_data_size push macroblock_count*block_output_data_size {
    for (int blockx = 0; blockx < (width/16); blockx++) {
      for (int blocky = 0; blocky < (height/16); blocky++) {
        for (int lum_count = 0; lum_count < 4; lum_count++) {
          for (int y = 0; y < 8; y++) {
            for (int x = 0; x < 8; x++) {
              int input_val = pop();
              int output_val = input_val - lum[blockx*16+(lum_count % 2)*8+x][blocky*16+(lum_count / 2)*8+y];
              push(output_val);
            }
          }
        }
        for (int y = 0; y < 8; y++) {
          for (int x = 0; x < 8; x++) {
            int input_val = pop();
            int output_val = input_val - cb[blockx*8+x][blocky*8+y];
            push(output_val);
          }
        }
        for (int y = 0; y < 8; y++) {
          for (int x = 0; x < 8; x++) {
            int input_val = pop();
            int output_val = input_val - cr[blockx*8+x][blocky*8+y];
            push(output_val);
          }
        }
        // Hardcoded to have no motion right now TODO
        push(22);
        push(22);
        push(22);
        push(22);
      }
    }
  }

  handler referencePic(int[width][height] new_lum, int[width/2][height/2] new_cr, int[width/2][height/2] new_cb) {
    for (int x = 0; x < width; x++) {
      for (int y = 0; y < height; y++) {
        lum[x][y] = new_lum[x][y];
      }
    }
    for (int x = 0; x < width/2; x++) {
      for (int y = 0; y < height/2; y++) {
        cb[x][y] = new_cb[x][y];
        cr[x][y] = new_cr[x][y];
      }
    }
  }
}

int->int pipeline BackwardMotionPrediction(int input_data_size, int output_data_size) {
  // TODO temp for now
  add IntraMotionPrediction(input_data_size, output_data_size);
}

int->int splitjoin MacroBlockScrambler(int width) {
  split roundrobin(16);
  for (int i = 0; i < (width/16); i++) {
    add int->int splitjoin {
      split roundrobin(8);
      for (int j = 0; j < 2; j++) {
        add Identity<int>;
      }
      join roundrobin(8*8);
    }
  }
  join roundrobin(16*16);
}

int->int splitjoin MacroBlockOrder(int width) {
  split roundrobin(16);
  for (int i = 0; i < (width/16); i++) {
    add Identity<int>;
  }
  join roundrobin(16*16);
}

/**
 * @internal
 */
int->int filter DropSecond {
  work pop 2 push 1 {
    push(pop());
    pop();
  }
}

/**
 * @internal
 */
int->int filter ChannelDownsample_1D(float weight1, float weight2) {
  work pop 2 push 1 {
    float a = pop()*weight1;
    float b = pop()*weight2;
    push((int) round(a+b));
  }
}

// Note: We assume we are going from 4:4:4 to 4:2:0
// Otherwise this won't work.
// See (cite 1, P. 14, Figure 6-1) for spacing of the samples.
// I think this works but we should actually test it.
int->int pipeline ChannelDownsample(int width, int height) {
  add DropSecond;
  add int->int splitjoin {
    split roundrobin(1);
    for (int i = 0; i < 8; i++) {
      add DropSecond; // TODO This is actually WRONG!
    }
    join roundrobin(1);
  }
}

int->int pipeline TransformPicture(int width, int height) {
  add ColorSpaceConversion_RGBtoYCbCr;
  add int->int splitjoin {
    split roundrobin(1);
    add MacroBlockScrambler(width);
    for (int i = 0; i < 2; i++) {
      add int->int pipeline {
        add MacroBlockOrder(width);
        add ChannelDownsample(width, height); 
      }
    }
    join roundrobin(64*4, 64, 64);
  }
}

// TODO - AssignPictureType for now sends everything in a SINGLE Group_of_Pictures
// It also assumes everything is a single scene, and just uses a static IPB
// pattern: IBBPBBPBBPBB
// todo: hack for now is IBPPBBPBBPBB
// First Value Pushed: Temporal Reference (Frame Number)
// Second Value Pushed: See interpretation below
// Output Interpretation:
// 1 = I-Picture
// 2 = P-Picture
// 3 = B-Picture
int->int filter AssignPictureType(int width, int height) {
  int frameno;
  init {
    frameno = 0;
  }
  work pop (width*height*3) push 2 {
    push(frameno);
    for (int i = 0; i < width*height*3; i++) {
      pop();
    }
    int pushval;
    int framecount = frameno % 12;
    if (framecount == 0) {
      pushval = 1;
      //  == 2 is a hack TODO see above
    } else if (framecount == 2 || framecount == 3 || framecount == 6 || framecount == 9) {
      pushval = 2;
    } else {
//      pushval = 3;
      // TODO hacked for now for no backward motion compensation till we get forward working
      pushval = 2;
    }
    print("frame " + frameno + " gets type " + pushval);
    push(pushval);      
    frameno++;
  }
}

int->int splitjoin PicturePreprocessing(int width, int height) {
  split duplicate;
  int downsample_data_size = (width*height*3)/2;
  add AssignPictureType(width, height);
  add TransformPicture(width, height);
  join roundrobin(2, downsample_data_size);
}

int->int filter ReorderPictures(int picture_data_size) {
  // This isn't ENTIRELY unbounded - it may be bounded by the implementation of PicturePreprocessing
  // and its implementation - in particular the vbv buffer concept might come into play here, but
  // I'll worry about that later TODO.
  boolean ran;
  // FEATURETODO - change when phases can take parameters
  int PushAheadFrameThrough_nextIPframe;

  init {
    ran = false;
  }

  work pop * push * {
    // How this works: On the first execution this filter pushes an I-frame through. On subsequent
    // executions it pushes an I or P frame through, immediately followed by all B frames that
    // refer to the past two I/P frames.
    if (!ran) {
      ran = true;
      PushFrameThrough();   
    } else {
      int nextIPframe = 0;
      // Find the next I frame
      while (peek(nextIPframe*picture_data_size+1) == 3) {
        nextIPframe++;
      }
      // Push that frame through
      PushAheadFrameThrough_nextIPframe = nextIPframe;
      PushAheadFrameThrough();
      while (peek(1) == 3) {
        PushFrameThrough();
      }
      PopFrameOff();
    }
  }

  phase PushAheadFrameThrough push picture_data_size pop * {
    for (int i = 0; i < picture_data_size; i++) {
      push(peek(PushAheadFrameThrough_nextIPframe*picture_data_size+i));
    }
  }

  phase PopFrameOff pop picture_data_size {
    deadpop(picture_data_size);
  }

  phase PushFrameThrough push picture_data_size pop picture_data_size {
    pushpop(picture_data_size);
  }
}

int->int pipeline MacroBlockEncode(int[64] intra_quantiser_matrix, int[64] non_intra_quantiser_matrix,
                                   int intra_dc_precision, int q_scale_type) {
  add DCT8x8_ieee;
  add Quantisation(intra_quantiser_matrix, non_intra_quantiser_matrix, intra_dc_precision, q_scale_type);
  add int->int splitjoin {
    split roundrobin(5, (64*6));
    add Identity<int>;
    add ZigZagOrdering;
    join roundrobin(5, (64*6));
  }
}

int->int filter Quantisation(int[64] intra_quantiser_matrix, int[64] non_intra_quantiser_matrix,
                             int intra_dc_precision, int q_scale_type) {
  // FEATURETODO - Move to globals when globals working properly - also out of decoder
  // (cite 1, P.70 Table 7-6)
  int[2][32] quantiser_scale =
    // Note that quantiser_scale[x][0] is a Forbidden Value
    {{ 0,  2,  4,  6,  8, 10, 12, 14,
      16, 18, 20, 22, 24, 26, 28, 30,
      32, 34, 36, 38, 40, 42, 44, 46,
      48, 50, 52, 54, 56, 58, 60, 62},
     { 0,  1,  2,  3,  4,  5,  6,  7,
       8, 10, 12, 14, 16, 18, 20, 22,
      24, 28, 32, 36, 40, 44, 48, 52, 
      56, 64, 72, 80, 88, 96, 104, 112}};
  int[4] intra_dc_mult;

  init {
    intra_dc_mult[0] = 8;
    intra_dc_mult[1] = 4;
    intra_dc_mult[2] = 2;
    intra_dc_mult[3] = 1;
  }
  // TODO temp - for now only use intra quantization, and 
  // no changes in the scaling.
  work pop (64*6) push (64*6+5) {
    push(3278);
    int macroblock_intra = 1;
    int quantiser_scale_code = 1;
    push(quantiser_scale_code);
    push(0); // TODO temp motion_forward
    push(0); // TODO temp motion_backward
    push(macroblock_intra);
    // See (cite 1, P. 71) for more details.
    // macroblock is INTRA TODO temp
    int k = 0;
    for (int block = 0; block < 6; block++) { // TODO move out
      for (int count = 0; count < 64; count++) {
        if (count == 0) {
          push(pop() / intra_dc_mult[intra_dc_precision]);
        } else {
          push(16*pop()/
               (intra_quantiser_matrix[count]*quantiser_scale[q_scale_type][quantiser_scale_code]));
        }
      } 
    }
  }
}

/**
 * @internal
 */
int->int filter ZigZagOrdering {
  int[64] Ordering = {00, 01, 08, 16, 09, 02, 03, 10,
                      17, 24, 32, 25, 18, 11, 04, 05,
                      12, 19, 26, 33, 40, 48, 41, 34,
                      27, 20, 13, 06, 07, 14, 21, 28,
                      35, 42, 49, 56, 57, 50, 43, 36,
                      29, 22, 15, 23, 30, 37, 44, 51,
                      58, 59, 52, 45, 38, 31, 39, 46,
                      53, 60, 61, 54, 47, 55, 62, 63};
  work pop 64 push 64 {
    for (int i = 0; i < 64; i++) {
      push(peek(Ordering[i]));
    }
    for (int i = 0; i < 64; i++) {
      pop();
    }
  }
}

int->int filter PartialStreamGenerator_Slice {
  work pop 1 push 1 {
    push(pop());
  }
}

int->int filter PartialStreamGenerator_PictureLevel {
  work pop 1 push 1 {
    push(pop());
  }
}

/** 
 * Notes: This is the sequence of Pop Operations
 * this will perform basically, and expect to
 * receive data in this fashion:
 * for each picture
 *   int temporal_reference = pop()
 *   int picture_coding_type = pop()
 *   for each slice
 *     for each macroblock
 *       int quantiser_scale_code = pop()
 *       int macroblock_motion_forward = pop()
 *       int macroblock_motion_backward = pop()
 *       int macroblock_intra = pop()    
 *       for each block (block_count)
 *         for j from 0 to 63
 *           QFS[i][j] = pop()
 */
int->bit filter MPEGStreamGenerator(int width, int height, int numpictures,
                                    int[64] intra_quantiser_matrix,
                                    int[64] non_intra_quantiser_matrix,
                                    int intra_dc_precision,
                                    int q_scale_type) {
  boolean ran;

  init {
    ran = false;
  }  

  // TODO - might be able to put bounds on this.
  work pop * push * {
    if (!ran) {
      print("Writing M2V File...");
      ran = true;
      int tempval;

      // video_sequence() (cite 1, P.25)

      // sequence_header() (cite 1, P. 26)
      tempval = 0x000001B3;
      pushs(32, tempval);

      int horizontal_size = width;
      int mb_width = (horizontal_size+15) / 16;
      int vertical_size = height;
      int mb_height = (vertical_size+15) / 16;
      
      // Writing Sequence Header      
      int horizontal_size_value = horizontal_size & 0xFFF;
      int vertical_size_value = vertical_size & 0xFFF;
      pushs(12, horizontal_size_value);
      pushs(12, vertical_size_value);

      int aspect_ratio_information = 1;
      // (cite 1, P.41 Table 6-3)
      pushs(4, aspect_ratio_information);

      int frame_rate_code = 4; 
      // (cite 1, P.41-42 Table 6-4)
      pushs(4, frame_rate_code);

      int bit_rate = 1500000; // TODO - Fixed for the sample, might
                              // be worthwhile to waste some time understanding
                              // what this number means. It doesn't seem very important.
      // (cite 1, P.42)
      bit_rate /= 400;      

      int bit_rate_value = bit_rate & ((0xFFFF << 2) | 0xF);
          // 0b1111 1111 1111 1111 11
      pushs(18, bit_rate_value);

      add_marker_bit();

      int vbv_buffer_size = 66; // TODO - Fixed for the sample, might
                                // be worthwhile to waste some time understanding
                                // what this number means. It doesn't seem very important.

      int vbv_buffer_size_value = vbv_buffer_size & ((0xFF << 2) | 0xF);

      int constrained_parameters_flag = 0;
      pushs(1, constrained_parameters_flag);
      // (cite 1, P. 43)

      // Default Values for the quantiser_matrices
      int[64] default_intra_quantiser_matrix = 
        { 8, 16, 19, 22, 26, 27, 29, 34,
         16, 16, 22, 24, 27, 29, 34, 37,
         19, 22, 26, 27, 29, 34, 34, 38,
         22, 22, 26, 27, 29, 34, 37, 40,
         22, 26, 27, 29, 32, 35, 40, 48,
         26, 27, 29, 32, 35, 40, 48, 58,
         26, 27, 29, 34, 38, 46, 56, 69,
         27, 29, 35, 38, 46, 56, 69, 83};
      int[64] default_non_intra_quantiser_matrix =
        {16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16,
         16, 16, 16, 16, 16, 16, 16, 16};

      // Assumes no alternate_scan TODO
      boolean intra_is_default = true;
      boolean non_intra_is_default = true;
      for (int i = 0; i < 64; i++) {
        if (default_intra_quantiser_matrix[i] != intra_quantiser_matrix[i]) {
          intra_is_default = false;
        }
        if (default_non_intra_quantiser_matrix[i] != non_intra_quantiser_matrix[i]) {
          non_intra_is_default = false;
        }
      }
      int load_intra_quantiser_matrix;
      if (intra_is_default) {
        load_intra_quantiser_matrix = 1;
        pushs(1, load_intra_quantiser_matrix);
        for (int i = 0; i < 64; i++) {
          pushs(8, default_intra_quantiser_matrix[i]);
        }
      } else {
        load_intra_quantiser_matrix = 0;
        pushs(0, load_intra_quantiser_matrix);
        for (int i = 0; i < 64; i++) {
          pushs(8, intra_quantiser_matrix[i]);
          // TODO - check about ZIGZAG ORDERING - IMPORTANT
        }
      }
      int load_non_intra_quantiser_matrix;
      if (non_intra_is_default) {
        load_non_intra_quantiser_matrix = 1;
        pushs(1, load_non_intra_quantiser_matrix);
        for (int i = 0; i < 64; i++) {
          pushs(8, default_non_intra_quantiser_matrix[i]);
        }
      } else {
        load_non_intra_quantiser_matrix = 0;
        pushs(0, load_non_intra_quantiser_matrix);
        for (int i = 0; i < 64; i++) {
          pushs(8, non_intra_quantiser_matrix[i]);
          // TODO - check about ZIGZAG ORDERING - IMPORTANT
        }
      }

      // sequence_extension() (cite 1, P. 28)
      tempval = 0x000001B5;
      pushs(32, tempval);

      int extension_start_code_identifier = 1;
      pushs(4, extension_start_code_identifier);

      int profile_and_level_indication = 72;
      // We don't really care about the profile_and_level indicator - this matters if this implementation
      // were fully MPEG2 compliant to some profile/level, but it isn't.
      pushs(8, profile_and_level_indication);

      int progressive_sequence = 1; // TODO - Program Limitation
        // progressive_sequence 1: allows only progressive frames
      pushs(1, progressive_sequence);

      int block_count = 6; // (cite 1, P. 62)
      int chroma_format = 1;
      // chroma_format 4:2:0
      // NOTE - This chroma format is assumed in a huge number of places throughout the whole bitstream.
      // There's no  efficient way to support multiple chroma formats until there are reprogrammable
      // splitters/joiners in the language. FEATURETODO
      pushs(2, chroma_format);
      
      int horizontal_size_extension = horizontal_size >> 12;
      pushs(2, horizontal_size_extension);

      int vertical_size_extension = vertical_size >> 12;
      pushs(2, vertical_size_extension);

      int bit_rate_extension = bit_rate >> 18;
      pushs(12, bit_rate_extension);
      // (cite 1, P.42)
      
      add_marker_bit();

      int vbv_buffer_size_extension = vbv_buffer_size >> 10;
      pushs(8, vbv_buffer_size_extension);

      // low_delay 0 indicates that sequence is allowed to contain B-pictures
      int low_delay = 0;
      pushs(1, low_delay);

      // (cite 1, P. P.41)
      // These values are pretty much useless
      int frame_rate_extension_n = 0;
      pushs(2, frame_rate_extension_n);
      int frame_rate_extension_d = 0;
      pushs(2, frame_rate_extension_d);

      // TODO - This can later be parallelized
      // Start of Group_of_Pictures

      // group_of_pictures_header() (cite 1, P.29)
      tempval = 0x000001B8;
      pushs(32, tempval);

      // -- Time Code - Not Used in Decoding Process --
      int drop_frame_flag = 0;
      int time_code_hours = 0;
      int time_code_minutes = 0;
      int time_code_seconds = 0;
      int time_code_pictures = 0;
      // (cite 1, P.49)
      pushs(1, drop_frame_flag);
      pushs(5, time_code_hours);
      pushs(6, time_code_minutes);
      add_marker_bit();
      pushs(6, time_code_seconds);
      pushs(6, time_code_pictures);
      // -- End of Time Code

      int closed_gop = 0;
      pushs(1, closed_gop);
      int broken_link = 0;
      pushs(1, broken_link);

      // hardcoded for now TODO maybe
      for (int pic = 0; pic < numpictures; pic++) {
        print("Starting picture " + pic);
        // TODO Start of picture - this might later be broken up
        // picture_header() (cite 1, P.30)
        tempval = 0x00000100;
        pushs(32, tempval);

        // (cite 1, P.50)
        // The picture in time order, basically
        int temporal_reference = pop(); 
        pushs(10, temporal_reference);

        int picture_coding_type = pop();     
        // picture_coding_type = 1 -> I-picture
        // picture_coding_type = 2 -> P-picture
        // picture_coding_type = 3 -> B-picture
        pushs(3, picture_coding_type);

        // TODO unknown interpretation for vbv_delay, (cite 1, P.50)
        // I really have no idea what this is for. The value I am going
        // to assign it is the value that I found for one frame from
        // one video, and I'm going to hope that, like me, most decoders
        // don't really care about this value.
        // If there are weird problems later, especially anything related
        // to playback timing in something like mplayer, I would assume this
        // is at fault.
        int vbv_delay = 61589;
        pushs(16, vbv_delay);

        // The following is not used by the MPEG-2 specification (cite 1, P.51)
        // Supposed to have certain values, but not guaranteed for most files.
        // (cite 1, P. 51)
        if (picture_coding_type == 2 || picture_coding_type == 3) {
          int full_pel_forward_vector = 0;
          pushs(1, full_pel_forward_vector);
          int forward_f_code = 7;
          pushs(3, forward_f_code);
        } 
        if (picture_coding_type == 3) {
          int full_pel_backward_vector = 0;
          pushs(1, full_pel_backward_vector);
          int backward_f_code = 7;
          pushs(3, backward_f_code);
        }

        // Must be 0 for MPEG-2, 1 for supersets of MPEG-2.
        tempval = 0;
        pushs(1, tempval);
      
        // picture_coding_extension() (cite 1, P.30)
        tempval = 0x000001B5;
        pushs(32, tempval);

        extension_start_code_identifier = 0x8;
        pushs(4, extension_start_code_identifier);
            
        int[2][2] f_code;
        if (picture_coding_type == 1) {
          f_code[0][0] = 0xF;
          f_code[0][1] = 0xF;
          f_code[1][0] = 0xF;
          f_code[1][1] = 0xF; 
        } else if (picture_coding_type == 2) {
          f_code[0][0] = 9;
          f_code[0][1] = 9;
          f_code[1][0] = 0xF;
          f_code[1][1] = 0xF; 
        } else {
          f_code[0][0] = 9;
          f_code[0][1] = 9;
          f_code[1][0] = 9;
          f_code[1][1] = 9; 
        }
        pushs(4, f_code[0][0]);
        pushs(4, f_code[0][1]);
        pushs(4, f_code[1][0]);
        pushs(4, f_code[1][1]);
        // (cite 1, P.51)

        pushs(2, intra_dc_precision);

        int picture_structure = 3;
        pushs(2, picture_structure);
 
        int top_field_first = 0;
        pushs(1, top_field_first);

        int frame_pred_frame_dct = 1;
        pushs(1, frame_pred_frame_dct);

        int concealment_motion_vectors = 0;
        // not using concealment_motion_vectors...it just makes everything that
        // much more complicated.
        pushs(1, concealment_motion_vectors);

        pushs(1, q_scale_type);      

        int intra_vlc_format = 0;
        pushs(1, intra_vlc_format);

        int alternate_scan = 0;
        pushs(1, alternate_scan);

        int repeat_first_field = 0;
        pushs(1, repeat_first_field);

        // It should be 1 for 4:2:0 chroma.
        int chroma_420_type = 1;
        pushs(1, chroma_420_type);
        // (cite 1, P.53)

        int progressive_frame = 1;
        pushs(1, progressive_frame);

        int composite_display_flag = 0;
        pushs(1, composite_display_flag);

        // picture_data() (cite 1, P.34)
      
        // I assume 1 slice per macroblock line, for now
        // TODO eventually parallelize this slicing as best as possible.
        for (int slice_vertical_position = 1; slice_vertical_position <= mb_height; slice_vertical_position++) {
          // slice() (cite 1, P.34)
          // Reset motion vector predictors, (cite 1, P.77-80)

          tempval = 0x000001;
          pushs(24, tempval);
          pushs(8, slice_vertical_position);

          if (vertical_size > 2800)
            print("Error - Program Limitation: Doesn't handle vertical_slices > 2800");
          int mb_row, previous_macroblock_address;
          mb_row = slice_vertical_position - 1;
          previous_macroblock_address = (mb_row * mb_width) - 1;

          tempval = pop();
          if (tempval != 3278)
            print("Error - Stream Misaligned Somehow - got " + tempval + " expected " + 3278); 
//          else
//            print("Reading Macroblock: " + ((slice_vertical_position-1) * mb_width));

          int quantiser_scale_code = pop();
          pushs(5, quantiser_scale_code);
        
          tempval = 0;
          pushs(1, tempval);
        
          int[3] dc_dct_pred; // (cite 1, P.64-65)
                              // I'm not sure about this - see P. 64 and getpic.c Line 1180
                              // they disagree TODO
          dc_dct_pred[0] = 0; // (int) pow(2,actual_intra_dc_precision - 1);
          dc_dct_pred[1] = 0; // (int) pow(2,actual_intra_dc_precision - 1);
          dc_dct_pred[2] = 0; // (int) pow(2,actual_intra_dc_precision - 1);
        
          for (int slice_horizontal_position = 1; slice_horizontal_position <= mb_width; slice_horizontal_position++) {
            // macroblock() (cite 1, P.35)
            // Note - temporary TODO - for now we allow NO skipped macroblocks
            int macroblock_address_increment = 1;
            variable_length_encode(macroblock_address_increment, const_macroblock_address_inc);
            int macroblock_address = previous_macroblock_address + macroblock_address_increment;
            previous_macroblock_address = macroblock_address;
            int mb_column = macroblock_address % mb_width;
          
            int macroblock_quant;

            if (slice_horizontal_position != 1) {
              tempval = pop();
              if (tempval != 3278)
                print("Error - Stream Misaligned Somehow got " + tempval + " expected " + 3278);
//              else           
//                print("Reading Macroblock: " + ((slice_vertical_position-1)*mb_width + slice_horizontal_position-1));
              tempval = pop();
              if (quantiser_scale_code == tempval) {
                macroblock_quant = 0;
              } else {
                macroblock_quant = 1;
              }
              quantiser_scale_code = tempval;
            } else {
              // If it's the first block of the slice we already popped it off and included it above
              // in the slice code section, so there's no reason to do it again.
              macroblock_quant = 0;
            }

            int macroblock_motion_forward = pop();
            int macroblock_motion_backward = pop();
            // Must be 0 for intra blocks TODO generalize
            int macroblock_pattern = 0; 
              // For now - we are going to force all blocks to be encoded temporarily TODO
            int macroblock_intra = pop();
            int spatial_temporal_weight_code_flag = 0;

            int[block_count][64] QFS;

            for (int i = 0; i < block_count; i++) {
              for (int j = 0; j < 64; j++) {
                QFS[i][j] = pop();
              }
              // block(i) (cite 1, P.38)
              // if macroblocks are skipped, predictor is reset TODO
            }

            int[2][2][2] motion_code;
            int[2][2][2] motion_residual;
            for (int i = 0; i < 2; i++) {
              for (int j = 0; j < 2; j++) {
                for (int k = 0; k < 2; k++) {
                  if (i == 0) {
                    motion_code[i][j][k] = pop();
                    motion_residual[i][j][k] = pop();
                  } else {
                    motion_code[i][j][k] = 0;
                    motion_residual[i][j][k] = 0;
                  }
                }
              }
            }

            int macroblock_decision_data = pop(); // which vectors to use if any

            if (macroblock_decision_data == 2 || macroblock_decision_data == 4)
              macroblock_motion_forward = 1;
            if (macroblock_decision_data == 3 || macroblock_decision_data == 4)
              macroblock_motion_backward = 1;
            if (macroblock_decision_data > 1) {
              macroblock_intra = 0;
              macroblock_pattern = 0;
            } else {
              macroblock_intra = 1;
              macroblock_pattern = 0;
            }
            // TODO: Remove that stuff from the Quantisation blocks.

            tempval = 0;
            tempval = tempval | macroblock_quant;
            tempval <<= 1;
            tempval = tempval | macroblock_motion_forward;
            tempval <<= 1;
            tempval = tempval | macroblock_motion_backward;
            tempval <<= 1;
            tempval = tempval | macroblock_pattern;
            tempval <<= 1;
            tempval = tempval | macroblock_intra;
            tempval <<= 1;
            tempval = tempval | spatial_temporal_weight_code_flag;
          
            if (picture_coding_type == 1) { // I-picture
              variable_length_encode(tempval, const_macroblock_type_Ipictures);
            } else if (picture_coding_type == 2) { // P-picture
              variable_length_encode(tempval, const_macroblock_type_Ppictures);
            } else if (picture_coding_type == 3) { // B-picture
              variable_length_encode(tempval, const_macroblock_type_Bpictures);
            }

            // (cite 1, P.60, Table 6-17)
            int prediction_type = 2; // 0 = reserved, 1 = field-based, 2=frame-based, 3=dual-prime
            int mv_format = 1; // 0 = field, 1 = frame
            int motion_vector_count = 1;
            int dmv = 0;

            if (macroblock_quant == 1) {
              pushs(5, quantiser_scale_code);
            }
         
            // Motion Vector Predictor Reset, (cite 1, P.80)     
            if ((macroblock_intra == 1) ||
                (macroblock_intra == 0 && macroblock_motion_forward == 0 && 
                 picture_coding_type == 2)) {          
              // not clear if we should do anything here TODO
            }

            if (macroblock_motion_forward == 1) {
              // motion_vectors(0); (cite 1, P.36, 61)
              // motion_vector(0,0);
              // (cite 1, P.61)
              for (int t = 0; t < 2; t++) {
                variable_length_encode(motion_code[0][0][t], const_motion_code);                            
                if ((f_code[0][t] != 1) && (motion_code[0][0][t] != 0)) {
                  int r_size = f_code[0][t]-1;
                  pushs(r_size, motion_residual[0][0][t]);
                }
              }
            }

            if (macroblock_motion_backward == 1) {
              // motion_vectors(1); (cite 1, P.36, 61)
              // motion_vector(0,1);
              // (cite 1, P.61)
              for (int t = 0; t < 2; t++) {
                variable_length_encode(motion_code[0][1][t], const_motion_code);
                if ((f_code[1][t] != 1) && (motion_code[0][1][t] != 0)) {
                  int r_size = f_code[1][t]-1;
                  pushs(r_size, motion_residual[0][1][t]);
                }
              }
            }

            int[12] pattern_code;
            // TODO - later when skipped blocks allowed, change
            // The meaning of pattern_code is defined somewhat poorly
            // on (cite 1, P.62) in the code block
            for (int i = 0; i < 12; i++) {
              if (macroblock_intra == 1) {
                pattern_code[i] = 1;
              } else {
                pattern_code[i] = 0;
              }
            }

            for (int i = 0; i < block_count; i++) {
              int QFS_current;
              QFS_current = 0;
              if (pattern_code[i] == 1) {
                if (macroblock_intra == 1) {
                  if (i < 4) {
                    int dc_dct_luminance = QFS[i][0];
                    int dct_diff = dc_dct_luminance - dc_dct_pred[0];
                    int dc_dct_size_luminance;
                    if (dct_diff == 0) {
                      dc_dct_size_luminance = 0;
                      variable_length_encode(dc_dct_size_luminance, const_dct_dc_size_luminance);
                    } else {
                      int temp = (int) abs(dct_diff);
                      dc_dct_size_luminance = 0;
                      while (temp != 0) {
                        temp /= 2;
                        dc_dct_size_luminance++;
                      }
                      variable_length_encode(dc_dct_size_luminance, const_dct_dc_size_luminance);
                      int half_range = (int) pow(2,dc_dct_size_luminance-1);
                      int dc_dct_differential_luminance;
                      if (dct_diff > 0) {
                        dc_dct_differential_luminance = dct_diff;
                      } else {
                        dc_dct_differential_luminance = (dct_diff + (2*half_range)) - 1;
                      }
                      pushs(dc_dct_size_luminance, dc_dct_differential_luminance);
                    } 
                    QFS_current++;        
                    dc_dct_pred[0] = dc_dct_luminance;
                  } else {
                    int dc_dct_chrominance = QFS[i][0];
                    int dct_diff = dc_dct_chrominance - dc_dct_pred[i-3];
                    int dc_dct_size_chrominance;
                    if (dct_diff == 0) {
                      dc_dct_size_chrominance = 0;
                      variable_length_encode(dc_dct_size_chrominance, const_dct_dc_size_chrominance);
                    } else {
                      int temp = (int) abs(dct_diff);
                      dc_dct_size_chrominance = 0;
                      while (temp != 0) {
                        temp /= 2;
                        dc_dct_size_chrominance++;
                      }
                      variable_length_encode(dc_dct_size_chrominance, const_dct_dc_size_chrominance);
                      int half_range = (int) pow(2, dc_dct_size_chrominance-1);
                      int dc_dct_differential_chrominance;
                      if (dct_diff > 0) {
                        dc_dct_differential_chrominance = dct_diff;
                      } else {
                        dc_dct_differential_chrominance = (dct_diff + (2*half_range)) - 1;
                      } 
                      pushs(dc_dct_size_chrominance, dc_dct_differential_chrominance);
                    }  
                    QFS_current++;
                    dc_dct_pred[i-3] = dc_dct_chrominance;
                  }
                } else {
                  dc_dct_pred[0] = 0;
                  dc_dct_pred[1] = 0;
                  dc_dct_pred[2] = 0;
                }
                if (macroblock_intra == 0 && QFS_current == 0) {
                  // This section here from end of Table B.14 and 7.2.2.2 (cite 1, P.66)
                  if (QFS[i][0] == 1 || QFS[i][0] == -1) {
                    if (QFS[i][0] == 1) {
                      tempval = 2;
                    } else {
                      tempval = 3;
                    }
                    pushs(2, tempval);
                    QFS_current++;
                  }             
                }
                int run = 0;
                while (QFS_current < 64) {
                  // For an understanding of this section see
                  // (cite 1, 7.2.2 P.65-66) 
                  if (QFS[i][QFS_current] == 0) {
                    run++;
                  } else {
                    int level = (int) abs(QFS[i][QFS_current]);
                    int sign = 0;
                    if (QFS[i][QFS_current] > 0) {
                      sign = 0;
                    } else {
                      sign = 1;
                    }
                    boolean found = false;
                    for (int c = 0; c < const_dct_coefficients_table_zero_len; c++) {
                      // Regular run/level encoding 
                      // We write it specially because not all combinations
                      // are encoded, there are also the escape coded coefficients.
                      if (const_dct_coefficients_table_zero[c].run == run &&
                          const_dct_coefficients_table_zero[c].level == level) {
                        int len = const_dct_coefficients_table_zero[c].len;
                        tempval = const_dct_coefficients_table_zero[c].code;
                        pushs(len, tempval);
                        pushs(1, sign);
                        found = true;
                        c = const_dct_coefficients_table_zero_len;
                      }
                    }
                    if (!found) {
                      // Escape Coding
                      tempval = 1;
                      pushs(6, tempval);                     
                      pushs(6, run);
                      pushs(1, sign);
                      if (sign == 0) {
                        level = QFS[i][QFS_current];
                      } else {
                        level = QFS[i][QFS_current] - 2048;
                      }
                      pushs(11, level);
                    }
                    run = 0;
                  }
                  QFS_current++;
                }
                tempval = 2;
                pushs(2, tempval);
              } else {
                // Block was skipped. I don't think we need to do anything.
              }
            }
          }
        }
      }
      // Sequence End Code
      tempval = 0x000001B7;
      pushs(32, tempval);
      tempval = 0;
      // To force flush, below:
      pushs(32, tempval);
      pushs(32, tempval);
      pushs(32, tempval);
      pushs(32, tempval);
      print("Done Writing M2V File...");
    } else {
//      print("Error - Trying to generate M2V file for a second time...");
    }
  }
}