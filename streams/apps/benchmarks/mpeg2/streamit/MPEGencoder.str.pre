/*
 * Copyright 2005 by the Massachusetts Institute of Technology.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in
 * advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 */

/**
 * @description
 * This file contains functions that allow one to encode MPEG-2 compliant video. 
 * The code is based on the MPEG-2 specification (ISO/IEC 13818-2). The MPEG-2 encoder
 * is a work in progress, although it works within a limited test range. Throughout the 
 * source code, citations are made in cases where an understanding of the code would be
 * helped by looking at an outside source. The format I have chosen is 
 * (cite NUM#, LOOKUP_INFO). NUM=1 refers to ISO/IEC: 13818-2, and NUM=2 refers to the reference
 * MPEG implementation written in C, available at [www.mpeg.org].
 *
 * @author <a href="mailto:madrake@gmail.com">Matthew Drake</a>
 * @file MPEGencoder.str.pre
 * @version 1.0
 */

// Comments for readers of the StreamIt MPEG specification:
//
// TODO notes refer to parts of the MPEG-2 specification which this
// program does not yet handle, or assumptions made by the program.
// FEATURETODO notes refer to changes that ought to be made to the program,
// or support which can be added for more of the MPEG-2 specification, which
// is pending the addition of features to the StreamIt language compiler.
// In general I have tried to document my code, and refer to the MPEG-2
// specification whenever I used it. If you are looking at any particular
// block of code and aren't sure what it is doing, find the previous citation
// comment, and refer to the corresponding page in the MPEG 2 spec.

/**
 * Interprets an input stream of raw video and encodes a compressed MPEG-2 
 * compliant bit stream, in accordance with the IEEE MPEG-2 specification.
 * @param width The resolution width of the video.
 * @param height The resolution height of the video.
 * @param numpictures The number of pictures to be put into the video.
 * @input A series of images representing the frames of the video. Each image
 *        consists of 3 integers for each pixel, with the number of pixels per
 *        image equalling the width * height of the video. Frames are output
 *        in time order, top to bottom, left to right, and RGB color order.
 * @output An MPEG-2 compliant bit stream of variable length.
 */ 
int->bit pipeline rawImageStream_to_MPEGStream(int width, int height, int numpictures) {

    portal<MotionEstimation> portal_fwdMotion;
    portal<MotionEstimation> portal_bckMotion;
    portal<GeneratorMessageReceiver> portal_picture_number;
    portal<GeneratorMessageReceiver> portal_picture_type;
    portal<SendBackReferenceFrameEncoder> portal_picture_type2;
    portal<MotionPredictionDecision> portal_picture_type3;

    int actual_intra_dc_precision = 8;  
    int blocks_per_macroblock = 6;
    int q_scale_type = 0;

    add PicturePreprocessing(width, height, numpictures);
    // Eventually Wrap in Programmable Splitjoin for Group of Pictures

    add ReorderPictures(width, 
                        height, 
                        portal_picture_number, 
                        portal_picture_type, 
                        portal_picture_type2, 
                        portal_picture_type3);
    // Eventually Wrap in Programmable Splitjoin for Slices - Also need to communicate frame type.

    add int->int splitjoin {
        split duplicate;
        add IntraMotionPrediction(blocks_per_macroblock);
        add MotionEstimation(width, height, 0, blocks_per_macroblock, 32) to portal_fwdMotion;
        add MotionEstimation(width, height, 1, blocks_per_macroblock, 32) to portal_bckMotion;
        join roundrobin((64*blocks_per_macroblock)+5);
    }

    add MotionPredictionDecision(width, 
                                 height, 
                                 blocks_per_macroblock)
        to portal_picture_type3;

    int pixeldata_per_macroblock = blocks_per_macroblock*64;

    add splitjoin {
        split roundrobin(pixeldata_per_macroblock+1, 5);
        add MacroBlockEncode(default_intra_quantiser_matrix, 
                             default_non_intra_quantiser_matrix,
                             actual_intra_dc_precision - 8, 
                             q_scale_type,
                             pixeldata_per_macroblock);       
        add MotionVectorEncode(width/16);
        join roundrobin(pixeldata_per_macroblock+5, 8+1);
    }

    add ReferenceFrameHandler(default_intra_quantiser_matrix, 
                              default_non_intra_quantiser_matrix, 
                              actual_intra_dc_precision - 8,
                              q_scale_type,
                              width,
                              height,
                              portal_fwdMotion,
                              portal_bckMotion,
                              pixeldata_per_macroblock,
                              portal_picture_type2);

    add GeneratorMessageReceiver(width/16, height/16) to portal_picture_type, portal_picture_number;

    add MPEGStreamGenerator(width, 
                            height, 
                            numpictures,
                            default_intra_quantiser_matrix, 
                            default_non_intra_quantiser_matrix, 
                            actual_intra_dc_precision - 8,
                            q_scale_type);

    add BitAlignStartCodes();
}

int->int filter GeneratorMessageReceiver(int macroblock_width, int macroblock_height) {
    int block_count = 6;
    int numpop = (5+block_count*64+8+1)*macroblock_width*macroblock_height;

    int temporal_reference = -1;
    int picture_coding_type = -1;

    handler setPictureType(int picture_type) {
        picture_coding_type = picture_type;
    }

    handler setPictureNumber(int new_temporal_reference) {
        temporal_reference = new_temporal_reference;
    }

    work pop numpop push (numpop+2) {
        push(temporal_reference);
        push(picture_coding_type);
        for (int j = 0; j < macroblock_width*macroblock_height; j++) {
            push(pop()); // tempval = 3278
            push(pop()); // quantiser_scale_code
            push(pop()); // macroblock_motion_forward
            push(pop()); // macroblock_motion_backward
            push(pop()); // macroblock_intra
            for (int i = 0; i < block_count; i++) {
                pushpop(64); // the block
            }
            pushpop(8); // motion vectors
            push(pop()); // macroblock_decision_data
        }
    }
}


/**
 * @internal
 */
int->int pipeline ReferenceFrameHandler(int[64] intra_quantiser_matrix,
                                        int[64] non_intra_quantiser_matrix,
                                        int intra_dc_precision,
                                        int q_scale_type,
                                        int width,
                                        int height,
                                        portal<MotionEstimation> portal_fwdMotion,
                                        portal<MotionEstimation> portal_bckMotion,
                                        int pixeldata_per_macroblock,
                                        portal<SendBackReferenceFrameEncoder> portal_picture_type) {

    int downsampled_data_per_image = (width*height*3)/2;
    int macroblock_output_data_size = downsampled_data_per_image*(pixeldata_per_macroblock+14)/pixeldata_per_macroblock;

    add splitjoin {
        // FEATURETODO - Some kind of message should ignore the right branch if its a B frame
        split duplicate;
        add Identity<int>;
        add DecodeAndSendBackReferenceFrame(intra_quantiser_matrix, 
                                            non_intra_quantiser_matrix, 
                                            intra_dc_precision,
                                            q_scale_type,
                                            width,
                                            height,
                                            portal_fwdMotion,
                                            portal_bckMotion,
                                            downsampled_data_per_image,
                                            pixeldata_per_macroblock,
                                            portal_picture_type);
        join roundrobin(macroblock_output_data_size, 1);
    }
    add int->int filter {
        work pop macroblock_output_data_size + 1 push macroblock_output_data_size {
            pushpop(macroblock_output_data_size);
            pop();
        }
    }
}                                        

/**
 * @internal
 */
int->int pipeline MotionVectorDecodeNoMessage(int macroblock_width) {
    add splitjoin {
        split roundrobin(2);
        for (int i = 0; i < 4; i++) {
            add IndividualMotionVectorDecode(macroblock_width);
        }
        join roundrobin(1);
    }
}

/**
 * @internal
 */
int->int pipeline MotionVectorEncode(int macroblock_width) {
    add splitjoin {
        split roundrobin(4, 1);
        add Identity<int>;
        add Repeat(1, 5);
        join roundrobin(4, 5);
    }
    add splitjoin {
        split roundrobin(8, 1);
        add splitjoin {
            split roundrobin(1);
            add IndividualMotionVectorEncode(macroblock_width, 2);
            add IndividualMotionVectorEncode(macroblock_width, 2);
            add IndividualMotionVectorEncode(macroblock_width, 3);
            add IndividualMotionVectorEncode(macroblock_width, 3);
            join roundrobin(2);
        }        
        add Identity<int>;
        join roundrobin(8, 1);
    }
}

/**
 * @internal
 */
int->int filter IndividualMotionVectorDecode(int macro_width) {

    int PMV;
    int f_code;

    init {
        f_code = 9;
    }

    work pop 2*macro_width push macro_width {
        PMV = 0;
        for (int i = 0; i < macro_width; i++) {
            oneBlock();
        }
    }

    void oneBlock() pop 2 push 1 {
        int motion_code = pop();
        int motion_residual = pop();
        int r_size = f_code - 1;
        int f = 1 << r_size;
        int high = (16*f)-1;
        int low = ((-16)*f);
        int range = 32*f;
        int delta = 0;
        if ((f == 1) || (motion_code == 0))
            delta = motion_code;
        else {
            delta = ((((int) abs(motion_code)) - 1) * f) + motion_residual + 1;
            if (motion_code < 0)
                delta = -delta;
        }
        int prediction = PMV;
        int vectorp = prediction + delta;
        if (vectorp < low)
            vectorp = vectorp + range;
        else if (vectorp > high) {
            vectorp = vectorp - range;
        }

        push(vectorp);

        PMV = vectorp;

    }
        
}

/**
 * @internal
 */
int->int filter IndividualMotionVectorEncode(int macro_width, int vector_type) {
    int PMV;
    int f_code;

    init {
        f_code = 9; // TODO - f_codes can vary in general, but we'll only put this
        // into specific encoder implementations.
    }

    work pop 2*macro_width push 2*macro_width {
        PMV = 0;
        for (int i = 0; i < macro_width; i++) {
            oneBlock();
        }
    }

    void oneBlock() pop 2 push 2 {
        int r_size = f_code-1;
        int f = 1 << r_size;
        int high = (16*f)-1;
        int low = ((-16)*f);
        int range = (32*f);
        int vectorp = pop();
        int macroblock_type = pop();

        if (!((macroblock_type == 3 && vector_type == 2) ||
              (macroblock_type == 2 && vector_type == 3))) {

            int prediction = PMV;

            int delta = vectorp - prediction;
            
            int motion_code = 0;
            int motion_residual = 0;
            if ((f == 1) || delta == 0) {
                motion_code = delta;
            } else {
                int posdelta = (int) abs(delta);
                int temp3 = posdelta - 1;
                motion_residual = temp3 % f;
                int temp1 = temp3 - motion_residual;
                if (delta < 0) {
                    motion_code = (-1*temp1)/f - 1;
                } else {
                    motion_code = temp1/f + 1;
                }      
            }
            push(motion_code);
            push(motion_residual);

            PMV = vectorp;
        } else {
            push(0);
            push(0);
        }
    }
}

/**
 * @internal
 */
int->int filter MotionPredictionDecision(int width, 
                                         int height,
                                         int blocks_per_macroblock) {
    int pixeldata_per_macroblock = blocks_per_macroblock*64;
    int picture_type = -1;

    int a = pixeldata_per_macroblock+4;

    handler setPictureType(int new_picture_type) {
        picture_type = new_picture_type;
    }

    work pop 3*(a+1) push a+2 {
        // TODO - Could have intra coded blocks in P or B frames
        if (picture_type == 1) { // I picture              
            push(1); // macroblock_intra - TODO change to messaging
            pushpop(a);
            deadpop(1);
            deadpop(a);
            deadpop(1);
            deadpop(a);
            deadpop(1);
            push(1);
        } else if (picture_type == 2) { // P picture
            push(0); // macroblock_intra
            deadpop(a);
            deadpop(1);
            pushpop(a);
            deadpop(1);
            deadpop(a);
            deadpop(1);
            push(2);
        } else { // B picture
            push(0); // macroblock_intra
            deadpop(a);
            deadpop(1);
            int error_backward = peek(a);
            int error_forward = peek(2*a+1);
            // Determine if the combination of the forward and backward
            // vectors has lower error than either one seperately.
            float[pixeldata_per_macroblock] combo_data;
            float error_combo = 0;
            for (int i = 0; i < pixeldata_per_macroblock; i++) {
                combo_data[i] = 0.5*(peek(i) + peek(pixeldata_per_macroblock+5+i));
                error_combo += combo_data[i];
            }

            int encode_decision; // 2 = P, 3 = B, 4 = P and B
            if (((int) error_combo) < error_backward &&
                ((int) error_combo) < error_forward) {
                encode_decision = 4;
            } else if (error_backward <= error_forward) {
                encode_decision = 3;
            } else {
                encode_decision = 2;
            }

            if (encode_decision == 4) {
                // Encode with P and B vectors
                for (int i = 0; i < pixeldata_per_macroblock; i++) {
                    push((int) (round(combo_data[i])));                      
                }
                int b = pixeldata_per_macroblock;
                deadpop(b);
                push(peek(5+b));
                push(peek(5+b+1));
                pushpop(2);
                deadpop(2);
                deadpop(1);
                deadpop(a);
                deadpop(1);
                push(encode_decision);
            } else if (encode_decision == 3) { // Encode with B vectors
                int b = pixeldata_per_macroblock;
                pushpop(b);
                push(peek(2));
                push(peek(3));
                push(peek(0));
                push(peek(1));
                pop(); 
                pop(); 
                pop(); 
                pop();
                deadpop(1);
                deadpop(a);
                deadpop(1);
                push(encode_decision);
            } else if (encode_decision == 2) { // Encode with P vectors
                deadpop(a);
                deadpop(1);
                int b = pixeldata_per_macroblock;
                pushpop(a); // Reorder
                deadpop(1);
                push(encode_decision);
            } else {
                println("ERROR - encode_decision must be 2, 3, or 4");
            }
        }
        // the final value pushed follows this convention:
        // 1 = intra, 2 = forward, 3 = backward, 4 = both
    }
}

/**
 * @internal
 */
int->int filter IntraMotionPrediction(int blocks_per_macroblock) {
    int pixeldata_per_macroblock = 64*blocks_per_macroblock;
    work pop pixeldata_per_macroblock push pixeldata_per_macroblock+5 {
        pushpop(pixeldata_per_macroblock);
        push(0);
        push(0);
        push(0);
        push(0);
        push(0); // error value - could use this later for 
                 // decision making TODO on P or B pictures
    }
}

/**
 * @internal
 */
int->int filter MotionEstimation(int width, 
                                 int height, 
                                 int delay, 
                                 int blocks_per_macroblock, 
                                 int window) {
    // The window size determines how many pixels on either side of the specified block that are checked for
    // possible motion estimation matching.
    int macroblock_count = (width/16)*(height/16);

    int[width][height] lum;
    int[width/2][height/2] cb;
    int[width/2][height/2] cr;

    int blockx;
    int blocky;

    init {
        blockx = 0;
        blocky = 0;
    }

    work pop blocks_per_macroblock*64 push blocks_per_macroblock*64+5 {
        int[16][16] curblock_lum;
        int[8][8] curblock_cb;
        int[8][8] curblock_cr;
        for (int lum_count = 0; lum_count < 4; lum_count++) {
            for (int y = 0; y < 8; y++) {
                for (int x = 0; x < 8; x++) {
                    int input_val = pop();
                    curblock_lum[x+8*(lum_count % 2)][y+8*(lum_count / 2)] = input_val;
                }
            }
        }
        for (int y = 0; y < 8; y++) {
            for (int x = 0; x < 8; x++) {
                int input_val = pop();
                curblock_cb[x][y] = input_val;
            }
        }
        for (int y = 0; y < 8; y++) {
            for (int x = 0; x < 8; x++) {
                int input_val = pop();
                curblock_cr[x][y] = input_val;
            }
        }
 
        int best_motionx = 0;
        int best_motiony = 0;
        int best_error = 256*8*8*4*3; // todo - hacked for now to have a limited window size
                                                
        int windowxleft = blockx*32-window;
        if (windowxleft < 0)
            windowxleft = 0;
        int windowxright = blockx*32+32+window;
        if (windowxright > width*2)
            windowxright = width*2;
        int windowytop = blocky*32-window;
        if (windowytop < 0) 
            windowytop = 0;
        int windowybottom = blocky*32+32+window;
        if (windowybottom > height*2)
            windowybottom = height*2;
        // For now we don't try half-pixel motion vectors TODO;
        for (int window_x = windowxleft; window_x <= windowxright - 32; window_x = window_x + 2) {
            for (int window_y = windowytop; window_y <= windowybottom - 32; window_y = window_y + 2) {
                // Try this window and see how well it does.
                int local_error = 0;
                for (int y = 0; y < 16; y++) {
                    for (int x = 0; x < 16; x++) {
                        local_error += (int) abs(curblock_lum[x][y] - lum[(window_x/2)+x][(window_y/2)+y]);
                    }
                }
                for (int y = 0; y < 8; y++) {
                    for (int x = 0; x < 8; x++) {
                        int temp  = ((int) abs(curblock_cb[x][y] - cb[(window_x/4)+x][(window_y/4)+y]));
                        local_error += 4 * temp;
                        int temp2 = ((int) abs(curblock_cr[x][y] - cr[(window_x/4)+x][(window_y/4)+y]));
                        local_error += 4 * temp2;
                    }
                }
                if (local_error < best_error) {
                    best_error = local_error;
                    best_motionx = window_x - blockx*32;
                    best_motiony = window_y - blocky*32;
                }
            }
        }
                             
        for (int lum_count = 0; lum_count < 4; lum_count++) {
            for (int y = 0; y < 8; y++) {
                for (int x = 0; x < 8; x++) {
                    int output_val;
                    int temp1 = x+8*(lum_count % 2);
                    int temp2 = y+8*(lum_count / 2);
                    int temp3 = blockx*16+(lum_count % 2)*8+x+best_motionx/2;
                    int temp4 = blocky*16+(lum_count / 2)*8+y+best_motiony/2;
                    int new_val = curblock_lum[temp1][temp2];
                    int ref_val = lum[temp3][temp4];
                    output_val =  new_val - ref_val;
                    push(output_val); 
                }
            }
        }
        for (int y = 0; y < 8; y++) {
            for (int x = 0; x < 8; x++) {
                int output_val;
                output_val = curblock_cb[x][y] - cb[blockx*8+x+best_motionx/4][blocky*8+y+best_motiony/4];
                push(output_val);
            }
        }
        for (int y = 0; y < 8; y++) {
            for (int x = 0; x < 8; x++) {
                int output_val;
                output_val = curblock_cr[x][y] - cr[blockx*8+x+best_motionx/4][blocky*8+y+best_motiony/4];
                push(output_val);
            }
        }
        push(best_motionx);
        push(best_motiony);
        push(0);
        push(0);
        push(best_error);

        blockx++;
        if (blockx == (width/16)) {
            blockx = 0;
            blocky = (blocky + 1) % (height/16);
        } 
    }

    handler referencePic(int[width][height] new_lum, 
                         int[width/2][height/2] new_cb, 
                         int[width/2][height/2] new_cr, 
                         int[width/16][height/16][4] motion_vectors,
                         int picture_type) {
        int[width][height] old_lum;
        int[width/2][height/2] old_cb;
        int[width/2][height/2] old_cr;

        if (picture_type == 2) {
            for (int x = 0; x < width; x++) {
                for (int y = 0; y < height; y++) {
                    old_lum[x][y] = lum[x][y];
                }
            }
            for (int x = 0; x < width/2; x++) {
                for (int y = 0; y < height/2; y++) {
                    old_cb[x][y] = cb[x][y];
                    old_cr[x][y] = cr[x][y];
                }
            }
        }
         
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                if (picture_type == 1) {
                    lum[x][y] = new_lum[x][y];
                } else {
                    int xloc = x + motion_vectors[x/16][y/16][0]/2;
                    int yloc = y + motion_vectors[x/16][y/16][1]/2;
                    if (xloc < 0 || yloc < 0 || xloc > width || yloc > height) {
                        println("Fatal Error: Motion vectors point outside of image bounds in reference frame");
                        xloc = 0;
                        yloc = 0;
                    }
                    int temp1 = new_lum[x][y];
                    int temp2 = old_lum[xloc][yloc];
                    lum[x][y] = temp1 + temp2;
                }
            }
        }
        for (int x = 0; x < width/2; x++) {
            for (int y = 0; y < height/2; y++) {
                if (picture_type == 1) {                   
                    cb[x][y] = new_cb[x][y];
                    cr[x][y] = new_cr[x][y];
                } else {
                    int xloc = x + motion_vectors[x/8][y/8][0]/4;
                    int yloc = y + motion_vectors[x/8][y/8][1]/4;
                    if (xloc < 0 || yloc < 0 || xloc > width/2 || yloc > height/2) {
                        println("Fatal Error: Motion vectors point outside of image bounds in reference frame");
                        xloc = 0;
                        yloc = 0;
                    }
                    cb[x][y] = new_cb[x][y] +
                        old_cb[xloc][yloc];
                    cr[x][y] = new_cr[x][y] +
                        old_cr[xloc][yloc];
                }
            }
        }
    }
}

/**
 * @internal
 */
int->int splitjoin MacroBlockScrambler(int width) {
    split roundrobin(16);
    for (int i = 0; i < (width/16); i++) {
        add int->int splitjoin {
            split roundrobin(8);
            for (int j = 0; j < 2; j++) {
                add Identity<int>;
            }
            join roundrobin(8*8);
        }
    }
    join roundrobin(16*16);
}

/**
 * @internal
 */
int->int splitjoin MacroBlockOrder(int width) {
    split roundrobin(16);
    for (int i = 0; i < (width/16); i++) {
        add Identity<int>;
    }
    join roundrobin(16*16);
}

/**
 * @internal
 */
int->int filter DropSecond {
    work pop 2 push 1 {
        push(pop());
        pop();
    }
}

/**
 * @internal
 */
int->int filter ChannelDownsample_1D(float weight1, float weight2) {
    work pop 2 push 1 {
        float a = pop()*weight1;
        float b = pop()*weight2;
        push((int) round(a+b));
    }
}

// Note: We assume we are going from 4:4:4 to 4:2:0
// Otherwise this won't work.
// See (cite 1, P. 14, Figure 6-1) for spacing of the samples.
// I think this works but we should actually test it.
int->int pipeline ChannelDownsample() {
    add DropSecond;
    add int->int splitjoin {
        split roundrobin(1);
        for (int i = 0; i < 8; i++) {
            add ChannelDownsample_1D(0.5, 0.5);
        }
        join roundrobin(1);
    }
}

/**
 * @internal
 */
int->int pipeline TransformPicture(int width, int height) {
    add ColorSpaceConversion_RGBtoYCbCr;
    add int->int splitjoin {
        split roundrobin(1);
        add MacroBlockScrambler(width);
        for (int i = 0; i < 2; i++) {
            add int->int pipeline {
                add MacroBlockOrder(width);
                add ChannelDownsample(); 
            }
        }
        join roundrobin(64*4, 64, 64);
    }
}

/**
 * @internal
 */
int->int filter AssignPictureType(int width, int height, int numpictures) {
    // TODO - AssignPictureType for now sends everything in a SINGLE Group_of_Pictures
    // It also assumes everything is a single scene, and just uses a static IPB
    // pattern: IBBPBBPBBPBB
    // First Value Pushed: Temporal Reference (Frame Number)
    // Second Value Pushed: See interpretation below
    // Output Interpretation:
    // 1 = I-Picture
    // 2 = P-Picture
    // 3 = B-Picture
    int frameno;

    init {
        frameno = 0;
    }
    work pop (width*height*3) push 2 {
        push(frameno);
        for (int i = 0; i < width*height*3; i++) {
            pop();
        }
        int pushval;
        int framecount = frameno % 12;
        if (framecount == 0) {
            pushval = 1;
        } else if (framecount == 3 || framecount == 6 || framecount == 9) { 
            pushval = 2;
        } else {
            pushval = 3;
        }
        if ((frameno == (numpictures-1)) && (pushval == 3)) {
            // If the last frame of the video is not a reference frame, 
            // make it one so that preceeding B pictures work correctly. 
            pushval = 2;
        }
        println("frame " + frameno + " gets type " + pushval);
        push(pushval);      
        frameno++;
    }
}

/**
 * @internal
 */
int->int splitjoin PicturePreprocessing(int width, 
                                        int height, 
                                        int numpictures) {
    int downsampled_data_per_image = (width*height*3)/2;
    
    split duplicate;
    add AssignPictureType(width, height, numpictures);
    add TransformPicture(width, height);
    join roundrobin(2, downsampled_data_per_image);
}

/**
 * @internal
 */
int->int pipeline ReorderPictures(int width, 
                                  int height, 
                                  portal<GeneratorMessageReceiver> portal_picture_number,
                                  portal<GeneratorMessageReceiver> portal_picture_type,
                                  portal<SendBackReferenceFrameEncoder> portal_picture_type2,
                                  portal<MotionPredictionDecision> portal_picture_type3) {

    int picture_data_size = (width*height*3)/2;

    add int->int filter {
        // This isn't ENTIRELY unbounded - it may be bounded by the implementation of PicturePreprocessing
        // and its implementation - in particular the vbv buffer concept might come into play here, but
        // I'll worry about that later TODO.

        int picture_data_size_temp = picture_data_size+2; // TODO temp

        prework push picture_data_size_temp {
            PushFrameThrough();   
        }

        work pop * push * {
            // How this works: On the first execution this filter pushes an I-frame through. On subsequent
            // executions it pushes an I or P frame through, immediately followed by all B frames that
            // refer to the past two I/P frames.
            int nextIPframe = 0;
            // Find the next I frame
            while (peek(nextIPframe*picture_data_size_temp+1) == 3) {
                nextIPframe++;
            }
            // Push that frame through
            PushAheadFrameThrough(nextIPframe);
            while (peek(1) == 3) {
                PushFrameThrough();
            }
            PopFrameOff();
        }

        void PushAheadFrameThrough(int nextIPframe) push picture_data_size_temp pop * {
            for (int i = 0; i < picture_data_size_temp; i++) {
                push(peek(nextIPframe*picture_data_size_temp+i));
            }
        }

        void PushFrameThrough() push picture_data_size_temp pop picture_data_size_temp {
            pushpop(picture_data_size_temp);
        }

        void PopFrameOff() pop picture_data_size_temp {
            deadpop(picture_data_size_temp);
        }
    }

    // Temp TODO - combine with previous filter when bug fixed
    add int->int filter {
        work pop 2+picture_data_size push picture_data_size {
            portal_picture_number.setPictureNumber(peek(0)) [0:0];
            portal_picture_type.setPictureType(peek(1)) [0:0];
            portal_picture_type2.setPictureType(peek(1)) [0:0];
            portal_picture_type3.setPictureType(peek(1)) [0:0];
            deadpop(2);
            pushpop(picture_data_size);
        }
    }

}

/**
 * @internal
 */
int->int pipeline MacroBlockEncode(int[64] intra_quantiser_matrix, 
                                   int[64] non_intra_quantiser_matrix,
                                   int intra_dc_precision, 
                                   int q_scale_type,
                                   int pixeldata_per_macroblock) {
    add splitjoin {
        split roundrobin(1, pixeldata_per_macroblock);
        add Identity<int>;
        add DCT8x8_ieee(1); // parallel
        join roundrobin(1, pixeldata_per_macroblock);
    }
    add Quantisation(intra_quantiser_matrix, 
                     non_intra_quantiser_matrix, 
                     intra_dc_precision, 
                     q_scale_type,
                     pixeldata_per_macroblock);
    add int->int splitjoin {
        split roundrobin(5, pixeldata_per_macroblock);
        add Identity<int>;
        add ZigZagOrdering;
        join roundrobin(5, pixeldata_per_macroblock);
    }
}

/**
 * @internal
 */
int->int splitjoin MacroBlockAndMotionVectorDecode(int[64] default_intra_quantiser_matrix,
                                                   int[64] default_non_intra_quantiser_matrix,
                                                   int intra_dc_precision,
                                                   int q_scale_type,
                                                   int width,
                                                   int height,
                                                   int pixeldata_per_macroblock) {
    portal<InverseQuantizationJoinerSubstitute> portal_macroblock_intra;
    portal<InverseQuantization_AC_Coeff> portal_quantiser_data_ac; // DO WE EVEN NEED THESE?
    portal<InverseQuantization_DC_Intra_Coeff> portal_quantiser_data_dc; // DO WE EVEN NEED THESE?
    split roundrobin(pixeldata_per_macroblock+5, 8, 1);
    add pipeline {
        add int->int filter {
            work pop 5+pixeldata_per_macroblock push pixeldata_per_macroblock {
                int a = pop();
                if (a != 3278) {
                    println("Error - Bitstream must be missaligned" + a);
                }
                int quantiser_scale_code;
                quantiser_scale_code = pop();
                portal_quantiser_data_ac.setQuantiserScaleCode(quantiser_scale_code) [0:0];
                deadpop(2);
                int macroblock_intra;
                macroblock_intra = pop();
                portal_macroblock_intra.setMacroblockIntra(macroblock_intra) [0:0];
                pushpop(pixeldata_per_macroblock);                
            }
        }
        add ZigZagUnordering;
        add InverseQuantization(portal_quantiser_data_ac,
                                portal_quantiser_data_dc,
                                portal_macroblock_intra,
                                intra_dc_precision,
                                default_intra_quantiser_matrix,
                                default_non_intra_quantiser_matrix,
                                q_scale_type);
        add iDCT8x8_ieee(2); // fast iDCT
    }
    add MotionVectorDecodeNoMessage(width/16);
    add Identity<int>;
    join roundrobin(pixeldata_per_macroblock, 4, 1);
}

/**
 * @internal
 */
int->int pipeline DecodeAndSendBackReferenceFrame(int[64] default_intra_quantiser_matrix,
                                                  int[64] default_non_intra_quantiser_matrix,
                                                  int intra_dc_precision,
                                                  int q_scale_type,
                                                  int width,
                                                  int height,
                                                  portal<MotionEstimation> portal_fwdMotion,
                                                  portal<MotionEstimation> portal_bckMotion,
                                                  int downsampled_data_per_image,
                                                  int pixeldata_per_macroblock,
                                                  portal<SendBackReferenceFrameEncoder> portal_picture_type) {

    int macroblock_output_data_size = downsampled_data_per_image*(pixeldata_per_macroblock+5+8+1)/pixeldata_per_macroblock;
    int downsample_data_size = downsampled_data_per_image;
    int extended_data_size = downsample_data_size*(pixeldata_per_macroblock+5)/pixeldata_per_macroblock;

    add MacroBlockAndMotionVectorDecode(default_intra_quantiser_matrix,
                                        default_non_intra_quantiser_matrix,
                                        intra_dc_precision,
                                        q_scale_type,
                                        width,
                                        height,
                                        pixeldata_per_macroblock);
    
    add SendBackReferenceFrameEncoder(width, 
                                      height, 
                                      extended_data_size, 
                                      portal_fwdMotion, 
                                      portal_bckMotion)
        to portal_picture_type;
}

/**
 * @internal
 */
int->int filter SendBackReferenceFrameEncoder(int width, 
                                               int height, 
                                               int extended_data_size,
                                               portal<MotionEstimation> portal_fwdMotion,
                                               portal<MotionEstimation> portal_bckMotion) {
    // The word "Encoder" is at the end to avoid namespace conflicts with the SendBackReferenceFrame
    // filter in the decoder, which is similar.
    int[width][height] backward_y_data;
    int[width/2][height/2] backward_cb_data;
    int[width/2][height/2] backward_cr_data;
    int[width/16][height/16][4] backward_motion_vectors;
    int backward_frametype;
    boolean skipframe; // skip sending the first frame backwards
    int frametype;
    
    init {
        skipframe = true;
        backward_frametype = 0;
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                backward_y_data[x][y] = 0;
            }
        }
        for (int x = 0; x < width/2; x++) {
            for (int y = 0; y < height/2; y++) {
                backward_cb_data[x][y] = 0;
                backward_cr_data[x][y] = 0;
            }
        }
        for (int x = 0; x < width/16; x++) {
            for (int y = 0; y < height/16; y++) {
                for (int z = 0; z < 4; z++) {
                    backward_motion_vectors[x][y][z] = 0;
                }
            }
        }
    }

    handler setPictureType(int new_frametype) {
        frametype = new_frametype;
    }

    work pop extended_data_size push 1 {
        int[width][height] y_data;
        int[width/2][height/2] cb_data;
        int[width/2][height/2] cr_data;
        int[width/16][height/16][4] motion_vectors;
               
        if (frametype < 3) {               
            for (int macroblocky = 0; macroblocky < height/16; macroblocky++) {
                for (int macroblockx = 0; macroblockx < width/16; macroblockx++) {
                    for (int blocky = 0; blocky < 2; blocky++) {
                        for (int blockx = 0; blockx < 2; blockx++) {
                            for (int y = 0; y < 8; y++) {
                                for (int x = 0; x < 8; x++) {
                                    y_data[macroblockx*16+blockx*8+x][macroblocky*16+blocky*8+y] = pop();
                                }
                            }
                        }
                    }
                    for (int y = 0; y < 8; y++) {
                        for (int x = 0; x < 8; x++) {
                            cb_data[macroblockx*8+x][macroblocky*8+y] = pop();
                        }
                    }
                    for (int y = 0; y < 8; y++) {
                        for (int x = 0; x < 8; x++) {
                            cr_data[macroblockx*8+x][macroblocky*8+y] = pop();
                        }
                    }
                    for (int i = 0; i < 4; i++) {
                        motion_vectors[macroblockx][macroblocky][i] = pop();
                    }                       
                    deadpop(1);                        
                }
            }
            portal_fwdMotion.referencePic(y_data, 
                                          cb_data, 
                                          cr_data, 
                                          motion_vectors, 
                                          frametype) [0:0];
            if (!skipframe) {
                portal_bckMotion.referencePic(backward_y_data, 
                                              backward_cb_data, 
                                              backward_cr_data, 
                                              backward_motion_vectors, 
                                              backward_frametype) [0:0];
            } else {
                skipframe = false;
            }
            backward_frametype = frametype;
            for (int x = 0; x < width; x++) {
                for (int y = 0; y < height; y++) {
                    backward_y_data[x][y] = y_data[x][y];
                }
            }
            for (int x = 0; x < width/2; x++) {
                for (int y = 0; y < height/2; y++) {
                    backward_cb_data[x][y] = cb_data[x][y];
                    backward_cr_data[x][y] = cr_data[x][y];
                }
            }
            for (int x = 0; x < width/16; x++) {
                for (int y = 0; y < height/16; y++) {
                    for (int z = 0; z < 4; z++) {
                        backward_motion_vectors[x][y][z] = motion_vectors[x][y][z];
                    }
                }
            }
        } else {
            deadpop(extended_data_size);
        }
        push(1);
    }
}

/**
 * @internal
 */
int->int filter Quantisation(int[64] intra_quantiser_matrix, 
                             int[64] non_intra_quantiser_matrix,
                             int intra_dc_precision, 
                             int q_scale_type,
                             int pixeldata_per_macroblock) {
    // FEATURETODO - Move to globals when globals working properly - also out of decoder
    // (cite 1, P.70 Table 7-6)
    int[2][32] quantiser_scale =
        // Note that quantiser_scale[x][0] is a Forbidden Value
    {{ 0,  2,  4,  6,  8, 10, 12, 14,
       16, 18, 20, 22, 24, 26, 28, 30,
       32, 34, 36, 38, 40, 42, 44, 46,
       48, 50, 52, 54, 56, 58, 60, 62},
     { 0,  1,  2,  3,  4,  5,  6,  7,
       8, 10, 12, 14, 16, 18, 20, 22,
       24, 28, 32, 36, 40, 44, 48, 52, 
       56, 64, 72, 80, 88, 96, 104, 112}};
    int[4] intra_dc_mult;

    init {
        intra_dc_mult[0] = 8;
        intra_dc_mult[1] = 4;
        intra_dc_mult[2] = 2;
        intra_dc_mult[3] = 1;
    }

    // TODO temp - for now only use intra quantization, and 
    // no changes in the scaling.
    work pop pixeldata_per_macroblock+1 push pixeldata_per_macroblock+5 {
        int macroblock_intra = pop();
        push(3278);
        int quantiser_scale_code = 1;
        push(quantiser_scale_code);
        push(0); // motion_forward
        push(0); // motion_backward
        push(macroblock_intra);
        // See (cite 1, P. 71) for more details.
        // macroblock is INTRA TODO temp
        int k = 0;
        int W = 0;
        for (int block = 0; block < 6; block++) { // TODO move out
            for (int count = 0; count < 64; count++) {
                int F = pop();
                if (macroblock_intra == 1) {
                    k = 0;
                    W = intra_quantiser_matrix[count];
                } else {
                    if (F > 0) {
                        k = 1;
                    } else if (F < 0) {
                        k = -1;
                    } else {
                        k = 0;
                    }
                    W = non_intra_quantiser_matrix[count];
                }         
                int QF;
                if (count == 0 && macroblock_intra == 1) {
                    QF = F / intra_dc_mult[intra_dc_precision];
                } else {
                    QF = ((32*F/(W*quantiser_scale[q_scale_type][quantiser_scale_code]))-k)/2;
                }
                push(QF);
            } 
        }
    }
}
