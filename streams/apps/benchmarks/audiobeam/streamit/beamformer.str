void->void pipeline beamformer
{
    int     num_mics = 15;
    boolean hamming  = false;
    float   sound_speed   = 342;
    float   sampling_rate = 16000;
    
    float[15][3] mic_locations;
    float[3] source_location;
    
    for (int i = 0; i < num_mics; i++) {
        mic_locations[i][0] = 1.5;
        mic_locations[i][1] = 2.79 + (i * 0.03);
        mic_locations[i][2] = 0.0;
    }
    
    source_location[0] = 1.1677;
    source_location[1] = 2.1677;
    source_location[2] = 1;
    
    //  add FileReader<float>("/home/streamit/compiler-static/audiobeam/data/near-field/data2");
    add FileReader<float>("../data/data2.binary");

    //  add float->float filter { work pop 1 push 1 { float val = pop(); println(val); push(val); } } 

    add calculate_single_position(num_mics, hamming, sound_speed, sampling_rate, 
                                  mic_locations, source_location);    
}


// the  most basic  mode  is to  process  the microphone  data and  to
// calculate  the output  based on  one beam  focused on  a particular
// point in space
float->void pipeline calculate_single_position(int num_mics, boolean hamming,
                                               float sound_speed, float sampling_rate,
                                               float[15][3] mic_locations,
                                               float[3] source_location)
{
    int   num_beams = 1;
    
    float[num_beams][15] delays;
    int  [num_beams][15] delays_floor;
    int  [num_beams][15] delays_ceil;
    float[num_beams][15] delays_diff;
    float[15] distances;
    float[15] weights;
    
    float min_delay = 1e38;
    float max_delay = 0;
    int   index     = 0;
    
    for (int i = 0; i < num_mics; i++) {
        distances[i] = sqrt(((mic_locations[i][0] - source_location[0]) *
                             (mic_locations[i][0] - source_location[0])) + 
                            ((mic_locations[i][1] - source_location[1]) * 
                             (mic_locations[i][1] - source_location[1])) + 
                            ((mic_locations[i][2] - source_location[2]) * 
                             (mic_locations[i][2] - source_location[2])));
	
        delays[0][i] = (distances[i] / sound_speed) * sampling_rate;

        if (delays[0][i] < min_delay) {
            min_delay = delays[0][i];
        }
    }
    
    min_delay = floor(min_delay) - 1;
    
    for (int i = 0; i < num_mics; i++) {
        delays[0][i] -= min_delay;
        delays_floor[0][i] = (int) floor(delays[0][i]);
        delays_ceil [0][i] = (int) ceil (delays[0][i]);
        delays_diff [0][i] = delays[0][i] - delays_floor[0][i];

        if (delays[0][i] > max_delay) {
            max_delay = delays[0][i];
        }
    
        weights[i] = 1;
    }

    max_delay = ceil(max_delay);
	  
    if (hamming) {
        if ((num_mics % 2) == 1) {
            int half = num_mics / 2;
            for (int y = -half; y <= half; y++) {
                weights[index++] = 0.54 + 0.46 * cos(pi * y / half);
            }
        }
        else {
            int half = num_mics / 4;
            for (int z = 1; z >= -1; z -= 2) {
                for (int y = -half; y <= half; y++) {
                    weights[index++] = 0.54 + 0.46 * cos(pi * y / half);
                }
            }
        }
    }

    add process_signal(num_mics, num_beams, (int) max_delay, delays_floor, delays_diff, weights);

    add float->void filter {
        float time_index, time_index_increment;

        init {
            time_index = 0;
            time_index_increment = 1.0 / sampling_rate;
        }
	  
        work pop 1 {
            println(time_index);
            println(pop());
            time_index += time_index_increment;
        }
    }
}


// read in lines  of the signal and run  the beamforming algorithms on
// it:  the main  idea is  that we  have a  circular queue  of samples
// implemented via  an array  of max_delay+1 samples,  so that  we can
// keep max_delay  previous samples and  the current sample;  once the
// queue is "full", that is, we have max_delay+1 samples in it, we can
// start outputting  beamformed results (delay each  microphone by the
// appropriate amount by reading that amount into the future)
float->float pipeline process_signal(int num_mics, int num_beams, int max_delay,
                                     int  [num_beams][15] delays_floor,
                                     float[num_beams][15] delays_diff,
                                     float[15] weights)
{
    add distribute_samples(num_mics, num_beams, max_delay, delays_floor, weights);
  
    add float->float splitjoin {
        split roundrobin(2 * num_mics);
    
        for (int beam = 0; beam < num_beams; beam++) {
            add do_beamforming(num_mics, num_beams, beam, delays_diff, weights);
        }
	  
        join roundrobin;
    }
}


float->float filter distribute_samples(int num_mics, int num_beams, int max_delay,
                                       int  [num_beams][15] delays_floor,
                                       float[15] weights)
{
    int   queue_head;
    float[max_delay + 1][15] sample_queue;
    
    init {
        queue_head = 1;
	
        for (int beam = 0; beam < num_beams; beam++) {
            for (int mic = 0; mic < num_mics; mic++) {
                sample_queue[beam][mic] = 0;
            }
        }
    }
    
    work pop num_mics push (2 * num_beams * num_mics) {
        int   low_index;
        int   high_index;
	
        for (int mic = 0; mic < num_mics; mic++) {
            sample_queue[queue_head-1][mic] = pop();
        }
	
        for (int beam = 0; beam < num_beams; beam++) {
            for (int mic = 0; mic < num_mics; mic++) {
                int delay_floor = delays_floor[beam][mic];
		  
                // low index gets index of sample right before desired sample
                low_index = queue_head + delay_floor;
                if (low_index > max_delay) {
                    low_index -= (max_delay + 1);
                }
		  
                // high index gets index of sample right after desired sample
                high_index = queue_head + delay_floor + 1;
                if (high_index > max_delay) {
                    high_index -= (max_delay + 1);
                }

                push(sample_queue[low_index][mic]);
                push(sample_queue[high_index][mic]);
            }
        }

        queue_head = queue_head + 1;
        if (queue_head > max_delay) {
            queue_head = queue_head - max_delay;
        }
    }
}


// take in  a sample  and a  queue of previous  samples, and  output a
// beamformed  one-channel  sample,  incorporating timing  information
// from max_delay previous samples
float->float pipeline do_beamforming(int num_mics, int num_beams, int beam, 
                                     float[num_beams][15] delays_diff, 
                                     float[15] weights)
{
    add float->float splitjoin {
        split roundrobin(2);
	  
        for (int mic = 0; mic < num_mics; mic++) {
            add float->float filter {
                work pop 2 push 1{
                    float low_sample  = pop();
                    float high_sample = pop();
                    float delay       = delays_diff[beam][mic];
                    float value       = (((high_sample - low_sample) * delay) + low_sample);

                    push(value * weights[mic]);
                }
            }
        }
	  
        join roundrobin;
    }
    
    add float->float filter {
        work pop num_mics push 1 {
            float sum = 0;
            for (int i = 0; i < num_mics; i++) {
                float val = pop();
                sum += val;
            }
            push(sum / (float) num_mics);
        }
    }
}
