// Code adapted FROM formSARimage.m
//
// % Function formSARimage() - part of Kernel 1 - Given the raw SAR complex 
// % data, forms the SAR image.
// %
// % Modified companion code to Mehrdad Soumekh's text book "Synthetic Aperture 
// % Radar Signal Processing with Matlab Algorithms", Wiley, New York, NY, 1999.
// %
// % This function digitally reconstructs the SAR image using spatial frequency 
// % interpolation (see noted text, Section 4.5).

void->void pipeline SAR3() 
{
    //  STATICS {
    float PI  = 3.14159;
    float PI2 = 2 * PI;

    // getUserParameters.m
    float SCALE_FACTOR = 1.0;
    
    // getSARparams0.m
    float ASPECT_RATIO = 0.4;
    float RANGE_FACTOR = 10.0;
    
    /* synthetic aperture is 2*L */
    float L = 100 * SCALE_FACTOR;
    
    /* target area in cross-range is within */
    float Y0 = L;

    /* target area in range is within [Xc-X0,Xc+X0] */
    float X0 = Y0 * ASPECT_RATIO;

    /* range distance to center of target area */
    float Xc = Y0 * RANGE_FACTOR;                

    /** getSARparams.m **/
    float RELATIVE_BANDWIDTH = 0.5;
    int   RPULSE = 75;

    /* propagation speed */
    float c = 3e8;

    /* carrier frequency*/
    float fc = 400e6;

    /* SPATIAL/GEOMETRIC PARAMETERS. */
    float Rmin = Xc - X0;
    float Rmax = sqrt(((Xc + X0)*(Xc + X0)) + ((Y0 + L)*(Y0 + L)));

    /* Chirp pulse duration */
    float Tp = RPULSE / c;    

    /* baseband bandwidth */
    float f0 = 0.5 * RELATIVE_BANDWIDTH * fc;

    /* Wavelength at highest frequency*/
    float lambda_min = c / (fc + f0);

    /* letter image size */
    int N_pix = 24;

    // genRawSAR.m
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    // %% u domain parameters and arrays for compressed SAR signal %%
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    //
    // duc=(Xc*lambda_min)/(4*Y0)/1.2;   % sample spacing in aperture domain
    //                                   % for compressed SAR signal
    //                                   % 10 percent guard band; this guard band
    //                                   % would not be sufficient for targets
    //                                   % outside digital spotlight filter (use
    //                                   % a larger guard band, i.e., PRF)
    // mc=2*ceil(L/duc);                 % number of samples on aperture
    // dku=pi2/(mc*duc);                 % sample spacing in ku domain
    // uc=duc*(-mc/2:mc/2-1);            % synthetic aperture array
    // kuc=dku*(-mc/2:mc/2-1);           % kuc array
    
    float duc = ((Xc * lambda_min) / (4 * Y0)) / 1.2;

    /* number of samples on aperture */
    int   mc  = 2 * (int) ceil(L / duc);

    float dku = PI2 / ((float) mc * duc);
          
    /* synthetic aperture array */
    float[mc] uc;           
    float[mc] kuc;

    for (int i = 0; i < mc; i++) {
        uc[i]  = duc * (((float) i) - ((float) mc) / 2.0);
        kuc[i] = dku * (((float) i) - ((float) mc) / 2.0);
    }

    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    // %%    u domain parameters and arrays for SAR signal     %%
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    // 
    // theta_min=atan((-Y0-L)/(Xc-X0));  % minimum aspect angle
    // theta_max=atan((Y0+L)/(Xc-X0));   % max aspect angle [p79(3/7)]
    // du=lambda_min/(1.4*2*( sin(theta_max)- sin(theta_min) ));
    //                                   % sample spacing in aperture
    //                                   % domain for SAR signal [Delta u, p79(4/7)]
    //                                   % 20 percent guard band
    // m=2*ceil(pi/(du*dku));            % number of samples on aperture
    // du=pi2/(m*dku);                   % readjust du
    // u=du*(-m/2:m/2-1);                % synthetic aperture array
    // ku=dku*(-m/2:m/2-1);              % ku array
    
    
    float theta_min = atan((0 - Y0 - L) / (Xc - X0));
    float theta_max = atan((Y0 + L) / (Xc - X0)); 
    
    float du = lambda_min / (1.4 * 2 * (sin(theta_max) - sin(theta_min)));

    /* number of samples on aperture */
    int   m  = 2 * (int) ceil(PI / (du * dku));
          du = PI2 / (m * dku);                   
    
    /* synthetic aperture array */
    float[m] u;
    float[m] ku;           

    for (int i = 0; i < m; i++) {
        u[i]  = du  * (((float) i) - ((float) m) / 2.0);
        ku[i] = dku * (((float) i) - ((float) m) / 2.0);
    }
    
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    // %%       Fast-time domain parmeters and arrays          %%
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    //
    // Ts=(2/c)*Rmin;                 % start time of sampling [p19(2/6)]
    // Tf=(2/c)*Rmax+Tp;              % end time of sampling [p19(3/6)]
    // T=Tf-Ts;                       % fast-time interval of measurement
    // Ts = Ts - 0.1*T;
    // Tf = Tf + 0.1*T;
    // T=Tf-Ts;
    // Tmin=max(T,(4*X0)/(c*cos(theta_max)));  % Minimum required T
    // dt=1/(4*f0);                 % Time domain sampling (guard band factor 2)
    // n=2*ceil((.5*Tmin)/dt);      % number of time samples
    // t=Ts+(0:n-1)*dt;             % time array for data acquisition
    // k = (pi2/c)*(fc + 4*f0*(-n/2:n/2-1)/n);  % Wavenumber array
    
    float Ts   = (2 / c) * Rmin; 
    float Tf   = (2 / c) * Rmax + Tp;
    float T    = Tf - Ts;
    Ts         = Ts - 0.1 * T;  
    Tf         = Tf + 0.1 * T;  
    T          = Tf - Ts;
    float Tmin = max(T, (4 * X0) / (c * cos(theta_max))); 
    float dt   = 1 / (4 * f0);

    /* number of time samples */
    int   n    = 2 * (int) ceil((0.5 * Tmin) / dt);     
    
    /* Wavenumber array */
    float[n] t;
    float[n] k;
    
    for (int i = 0; i < n; i++) {
        t[i] = Ts + i * dt;
        k[i] = (PI2 / c) * (fc + 4 * f0 * (((float) i) - ((float) n) / 2.0) / n);
    }

    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    // %%  Pre-determine the pixel size of the eventual image in the   %%
    // %%  X-dimm, to control placement of SAR returns relative to     %%
    // %%  pixel-based templates placement. (Code from formSARimage()) %%
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    //
    // kusave = ku;
    // ku=ones(n,1)*ku;                     % ku array
    // kx=(4*k(:).^2)*ones(1,m)-ku.^2;      % [p197(1/6), p200(1/6)(3/6)]
    // kx=sqrt(kx.*(kx > 0));               % kx array
    // kxmin=min(min(kx));
    // kxmax=max(max(kx));
    // dkx=pi/X0;            % Nyquist sample spacing in kx domain
    // nx=2*ceil((.5*(kxmax-kxmin))/dkx); % Required number of
    //                       % samples in kx domain;
    //                       % This value will be increased slightly
    //                       % to avoid negative array index
    // is=8;         % number of neighbors (sidelobes) used for sinc interpolator.
    // nx=nx+2*is+4; % increase number of samples to avoid negative
    // ku = kusave;  % return variable to what it was originally.

    float[n][m] kx;
    float kxmin = 1e25;
    float kxmax = 0;

    for (int i = 0; i < n; i++) {
	  for(int j = 0; j < m; j++) {
          float val = (4 * (k[i] * k[i])) - (ku[j] * ku[j]);
		
		if (val > 0) {
		    kx[i][j] = sqrt(val);
		} 
        else { 
            kx[i][j] = 0; 
        }
		
		if (kxmax < kx[i][j]) {
		    kxmax = kx[i][j];
		}
		if (kxmin > kx[i][j]) {
		    kxmin = kx[i][j];
		}
	  }
    }
    
    float dkx = PI / X0;            
    int   nx  = 2 * (int) ceil((0.5 * (kxmax - kxmin)) / dkx);
    int   is  = 8;    
          nx  = nx + 2 * is + 4; 

    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    // %%           Parameters of Targets                 %%
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    //
    // % SAR reflectors within digital spotlight filter
    // % [targets in an equally spaced mesh, all with unity
    // % reflection coefficient.]
    // xn = [];  yn = [];  fn = [];
    // npixx = (N_pix/nx)*2*X0; % template pixels noramlized to X0
    // npixy = (N_pix/m)*2*Y0;  % template pixels noramlized to Y0
    // % Place the SAR lobes appart from eachother by twice a template's size.
    // for xni = floor(npixx/2):2*npixx:2*X0-ceil(npixx/2)
    //     for yni = floor(npixy/2):2*npixy:2*Y0-ceil(npixy/2)
    //         xn = [xn xni-X0];
    //         yn = [yn yni-Y0];
    //     end
    // end
    // ntarget=length(xn);
    // fn = ones(1,size(xn,2));
    
    float npixx = (N_pix / (float) nx) * 2 * X0;
    float npixy = (N_pix / (float) m ) * 2 * Y0;

    int xni = (int) ((((2 * X0 - ceil(npixx / 2)) 
                       - floor(npixx / 2))
                      / (2 * npixx)) 
                     + 1);
    
    int yni = (int) ((((2 * Y0 - ceil(npixy / 2))
                       - floor(npixy / 2))
                      / (2 * npixy))
                     + 1);

    /* number of targets */
    int ntarget = xni * yni;

    float[ntarget] xn;
    float[ntarget] yn;
    float[ntarget] fn;
    
    for (int i = 0; i < xni; i++) {
        for (int j = 0; j < yni; j++) {
            xn[i * yni + j] = (floor(npixx / 2) + 2 * npixx * i) - X0;
            yn[i * yni + j] = (floor(npixy / 2) + 2 * npixy * j) - Y0;
            fn[i * yni + j] = 1;
        }
    }
    // } STATICS

    // Generate Raw Image

    /// s=ftx(s).*fast_time_filter;
    add void->complex pipeline {
        add void->complex splitjoin {
            split roundrobin(0);
            add FastTimeFilter(PI2, c, Xc, fc, f0, Tp, n, t);
            add void->complex pipeline {
                /// generate s
                add genRawSAR(PI2, L, c, Xc, fc, f0, Tp, Tf, n, mc, ntarget, t, uc, xn, yn, fn);
                /// s = ftx(s)
                add ftx2d(mc, n);
            }
            join roundrobin(1, mc);
        }
        
        add complex->complex filter {
            work pop n+n*mc push n*mc {
                for (int i = 0; i < n; i++) {
                    complex ftf = pop();
                    for (int j = 0; j < mc; j++) {
                        complex s   = pop();
                        complex out;
                        
                        out.real = s.real * ftf.real - s.imag * ftf.imag;
                        out.imag = s.imag * ftf.real + s.real * ftf.imag;
                        
                        push(out);
                    }
                }
            }
        }
    }
    add PrintComplex();
}

/*


    // Digital Spotlighting and Bandwidth Expansion in ku Domain  
    // via Slow-time Compression and Decompression

    //// Compression
    //// cs=s.*exp(cj*2*(k(:)*ones(1,mc)).*
    ////           (ones(n,1)*sqrt(Xc^2+(-uc).^2))-
    ////           cj*2*k(:)*Xc*ones(1,mc));
    add Compression(Xc, n, mc, k, uc);    
    //// Narrow-bandwidth Polar Format Processed reconstruction
    //// fp=fty(cs);
    add fty2d(mc, n);   

    //// Zero-padding in ku domain for slow-time upsampling
    //// mz=m-mc;
    //// fcs=(m/mc)*[zeros(n,mz/2),fp,zeros(n,mz/2)];
    add ZeroPadding(n, m, mc);
    
    //// Transform to (omega,u) domain
    //// cs=ifty(fcs);
    add ifty2d(m, n);
    
    //// Decompression
    //// s=cs.*exp(-cj*2*(k(:)*ones(1,m)).*
    ////          (ones(n,1)*sqrt(Xc^2+(-u).^2))+
    ////          cj*2*k(:)*Xc*ones(1,m));
    add Decompression(Xc, n, m, k, u);

    //// Digitally-spotlighted SAR signal spectrum
    //// fs=fty(s);                 
    add fty2d(m, n);
  
    // SAR RECONSTRUCTION
    // 2D Fourier Matched Filtering and Interpolation
    add Reconstruction(PI, Xc, X0, n, m, k, ku, 
                       kx, kxmax, kxmin, dkx, nx, is);

    /// Inverse 2D FFT for spatial domain image f(x,y) [p203 fig4.6]
    /// f=iftx(ifty(F)); 
    add ifty2d(m, nx);
    add iftx2d(m, nx);
    
    /// image=abs(f)';
    add complex->float filter {
        work push nx*m pop nx*m {
            float[m][nx] X_image;
            
            for (int i = 0; i < nx; i++) {
                for (int j = 0; j < m; j++){
                    complex in = pop(); // f[i][j]
                    X_image[j][i] = sqrt(pow(in.real, 2) +
                                         pow(in.imag, 2));
                }
            }
            for (int i = 0; i < nx; i++) {
                for (int j = 0; j < m; j++){
                    push(X_image[i][j]);
                }
            }
        }
    }
    
    add PrintFloat();
}


// Zero-padding
// fcs=(m/mc)*[zeros(n,mz/2),fp,zeros(n,mz/2)];
complex->complex filter ZeroPadding(int n, 
                                    int m, 
                                    int mc)
{
    int     mz;
    float   q;
    complex zero;
    
    init {
        mz = m - mc;
        q  = (float) m / (float) mc;
        
        zero.real = 0;
        zero.imag = 0;
    }
    
    work push n*m pop n*mc {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if ((j < mz / 2) || ( j >= mc+mz / 2)) {
                    push(zero);
                } else {
                    complex in = pop();
                    complex out;
                    out.real = q * in.real; //fp[i][j-mz/2].real;
                    out.imag = q * in.imag; //fp[i][j-mz/2].imag;
                    push(out);
                }
            }
        }
    }
}

// Compression
// cs=s.*exp(cj*2*(k(:)*ones(1,mc)).*
//           (ones(n,1)*sqrt(Xc^2+(-uc).^2))-
//           cj*2*k(:)*Xc*ones(1,mc));
complex->complex filter Compression(float Xc, 
                                    int n, 
                                    int mc, 
                                    float[n] k, 
                                    float[mc] uc)
{
    float[n][mc] cos_value;
    float[n][mc] sin_value;
    
    init {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < mc; j++){
                float value = 
                    2 * (k[i] * (sqrt(pow(Xc, 2) + pow(uc[j], 2)) - Xc));
                
                cos_value[i][j] = cos(value);
                sin_value[i][j] = sin(value);
            }
        }
    }
    
    work push n*mc pop n*mc {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < mc; j++){
                complex in = pop(); // s[i][j]
                complex out;
                
                out.real = 
                    (in.real * cos_value[i][j]) - 
                    (in.imag * sin_value[i][j]);
                
                out.imag =
                    (in.imag * cos_value[i][j]) + 
                    (in.real * sin_value[i][j]);
                
                push(out);
            }
        }
    }
}

// Decompression
// s=cs.*exp(-cj*2*(k(:)*ones(1,m)).*
//          (ones(n,1)*sqrt(Xc^2+(-u).^2))+
//          cj*2*k(:)*Xc*ones(1,m));
complex->complex filter Decompression(float Xc, 
                                      int n, 
                                      int m, 
                                      float[n] k, 
                                      float[m] u)
{
    float[n][m] cos_value;
    float[n][m] sin_value;
    
    init {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++){
                float value = 
                    2 * (k[i] * (sqrt(pow(Xc, 2) + pow(u[j], 2)) - Xc));
                
                cos_value[i][j] = cos(value);
                sin_value[i][j] = sin(value);
            }
        }
    }
    
    work push n*m pop n*m {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++){
                complex in = pop(); // cs[i][j]
                complex out;
                
                out.real = 
                    (in.real * cos_value[i][j]) +
                    (in.imag * sin_value[i][j]);
                
                out.imag =
                    (in.imag * cos_value[i][j]) - 
                    (in.real * sin_value[i][j]);
                
                push(out);
            }
        }
    }
}

// Reconstruction (multistage)
complex->complex pipeline Reconstruction(float PI, 
                                         float Xc, 
                                         float X0, 
                                         int n, 
                                         int m, 
                                         float[n] k_, 
                                         float[m] ku,
                                         float[n][m] kx, 
                                         float kxmax, 
                                         float kxmin, 
                                         float dkx, 
                                         int nx, 
                                         int is)
{
    // ku=ones(n,1)*ku;                    % ku array
    // kx=(4*k(:).^2)*ones(1,m)-ku.^2;     % [p197(1/6), p200(1/6)(3/6)]
    // kx=sqrt(kx.*(kx > 0));              % kx array
    // kxmin=min(min(kx));
    // kxmax=max(max(kx));
    // dkx=pi/X0;           % Nyquist sample spacing in kx domain
    // nx=2*ceil((.5*(kxmax-kxmin))/dkx); % Required number of
    //                      % samples in kx domain;
    //                      % This value will be increased slightly
    //                      % to avoid negative array index
    // NOTE: already initialized in globals

    // % 2D Matched filtering [p203, fast-time and slow-time domains]
    // fs0=(kx > 0).*exp(cj*kx*Xc+cj*ku+cj*.25*pi ...
    //            -cj*2*k(:)*ones(1,m)*Xc); % reference signal complex conjugate
    // fsm=fs.*fs0;
    add complex->complex filter {
	  complex[n][m] fs0;
	  
	  init {
		for (int i = 0; i < n; i++) {
		    for (int j = 0; j < m; j++) {
			  if (kx[i][j] > 0) {
				float value = kx[i][j] * Xc + ku[j] + 0.25 * PI - 2 * k_[i] * Xc;
				fs0[i][j].real = cos(value);
				fs0[i][j].imag = sin(value);
			  }
			  // else{ fs0[i][j].real=0; fs0[i][j].imag=0; }
		    }
		}
	  }

	  work pop n*m push n*m {
		for (int i = 0; i < n; i++) {
		    for (int j = 0; j < m; j++) {
			  complex fs = pop();
			  complex out;
			  
			  out.real = fs.real * fs0[i][j].real - fs.imag * fs0[i][j].imag;
			  out.imag = fs.real * fs0[i][j].imag + fs.imag * fs0[i][j].real;
			  push(out);
		    }
		}
	  }
    }

    // is=single(8);    % number of neighbors (sidelobes) used for sinc interpolator
    // nx=nx+2*is+4;    % increase number of samples to avoid negative
    //                  % array index during interpolation in kx domain
    // NOTE: already initialized in globals

    // I=2*is+1;
    // kxs=is*dkx; % plus/minus size of interpolation neighborhood in KX domain
    int   I   = 2 * is + 1;
    float kxs = (float) is * dkx;

    // KX=kxmin+(-is-2:nx-is-3)*dkx;     % uniformly-spaced kx points where
    //                                   % interpolation is done
    // kxc=KX(nx/2+1);                   % carrier frequency in kx domain
    float[nx] KX;

    for (int i = 0; i < nx; i++) {
	  KX[i] = kxmin + ((0 - is) - 2 + i) * dkx;
    }
        
    float kxc = KX[nx / 2]; 

    // F=single(zeros(nx,m));         % initialize F(kx,ku) array for interpolation output        
    // for i=1:n                      % for each k loop
    //  icKX=round((kx(i,:)-KX(1,1))/dkx)+1; % closest grid point in KX domain
    //  ikx=ones(I,1)*icKX+[-is:is]'*ones(1,m);
    //  ikx=ikx+nx*ones(I,1)*[0:m-1];
    //  nKX=KX(ikx);
    //  SINC=sinc((nKX-ones(I,1)*kx(i,:))/dkx);             % interpolating sinc [p144(3/4),p204(1/7)]
    //  HAM=.54+.46*cos((pi/kxs)*(nKX-ones(I,1)*kx(i,:)));  % Hamming window [p204(4/7)]
    //          %%%%%   Sinc Convolution (interpolation) follows  %%%%%%%%
    //  % [I = subsampled index in ku domain]
    //  F(ikx)=F(ikx)+(single(ones(I,1))*fsm(i,:)).*(SINC.*HAM);
    // end

    add complex->complex splitjoin {
	  split roundrobin(m);

	  for (int i = 0; i < n; i++) {	  
		add complex->complex pipeline {
		    int[m]      icKX;
		    int[I][m]   ikx;
		    float[I][m] nKX;
		    float[I][m] SINC;
		    float[I][m] HAM;
		    
		    for (int j = 0; j < m; j++) {
			  // icKX=round((kx(i,:)-KX(1,1))/dkx)+1;
			  icKX[j] = (int) round((kx[i][j] - KX[0]) / dkx) + 1;
			  
			  for (int k = 0; k < I; k++) {
				// ikx=ones(I,1)*icKX+[-is:is]'*ones(1,m);
				ikx[k][j] = icKX[j] + (k - is);
				//  ikx=ikx+nx*ones(I,1)*[0:m-1];
				ikx[k][j] = ikx[k][j] + nx * j;
				//  nKX=KX(ikx);
				nKX[k][j] = KX[ikx[k][j] % nx];
				// SINC=sinc((nKX-ones(I,1)*kx(i,:))/dkx);
				if ((nKX[k][j] - kx[i][j]) / dkx == 0) {
				    SINC[k][j] = 1;
				}
				else {
				    SINC[k][j] = sin(PI * (nKX[k][j] - kx[i][j]) / dkx) / (PI * (nKX[k][j] - kx[i][j]) / dkx);
				}
				
				// HAM=.54+.46*cos((pi/kxs)*(nKX-ones(I,1)*kx(i,:)));
				HAM[k][j] = 0.54 + 0.46 * cos((PI / kxs) * (nKX[k][j] - kx[i][j]));
			  }
		    }
            
		    add complex->complex filter {
			  complex[nx][m] F;

			  work push nx*m pop m {
				for (int j = 0; j < I; j++) {
				    for(int k = 0; k < m; k++) {
                        //  F(ikx)=F(ikx)+(single(ones(I,1))*fsm(i,:)).*(SINC.*HAM);
                        complex t = peek(k);

                        int ri = ikx[j][k] % nx;
                        int ci = (ikx[j][k] - ikx[j][k] % nx) / nx;

                        F[ri][ci].real += t.real * SINC[j][k] * HAM[j][k];
                        F[ri][ci].imag += t.imag * SINC[j][k] * HAM[j][k];
				    }
				}

				for (int j = 0; j < nx; j++) {
				    for(int k = 0; k < m; k++) {
					  push(F[j][k]);
				    }
				}

				for(int k = 0; k < m; k++) {
				    pop();
				}
			  }
		    }
		}
	  }

	  join roundrobin(1);
    }

    add complex->complex filter {
	  work pop n push 1 {
		complex out;

		for (int i = 0; i < n; i++) {
		    complex in = pop();
		    out.real += in.real;
		    out.imag += in.imag;
		}
		push(out);
	  }
    }
}
*/

float->void filter PrintFloat()
{
    work pop 1 {
	  print(pop());
    }
}

complex->void filter PrintComplex()
{
    work pop 1 {
        complex t = pop();
        print(t.real);
        print("+");
        print(t.imag);
        print("i\n");
    }
}

complex->complex filter DebugComplex()
{
    work pop 1 push 1 {
        complex t = pop();
        print(t.real);
        print("+");
        print(t.imag);
        print("i\n");
        push(t);
    }
}
