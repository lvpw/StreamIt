// Code adapted FROM formSARimage.m
// (rodric rabbah, <rabbah@mit.edu>)
//
// % Function formSARimage() - part of Kernel 1 - Given the raw SAR complex 
// % data, forms the SAR image.
// %
// % Modified companion code to Mehrdad Soumekh's text book "Synthetic Aperture 
// % Radar Signal Processing with Matlab Algorithms", Wiley, New York, NY, 1999.
// %
// % This function digitally reconstructs the SAR image using spatial frequency 
// % interpolation (see noted text, Section 4.5).

void->void pipeline SAR()
{
    // genRawSAR.m
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    // %% u domain parameters and arrays for compressed SAR signal %%
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    //
    // duc=(Xc*lambda_min)/(4*Y0)/1.2;   % sample spacing in aperture domain
    //                                   % for compressed SAR signal
    //                                   % 10 percent guard band; this guard band
    //                                   % would not be sufficient for targets
    //                                   % outside digital spotlight filter (use
    //                                   % a larger guard band, i.e., PRF)
    // mc=2*ceil(L/duc);                 % number of samples on aperture
    // dku=pi2/(mc*duc);                 % sample spacing in ku domain
    // uc=duc*(-mc/2:mc/2-1);            % synthetic aperture array
    // kuc=dku*(-mc/2:mc/2-1);           % kuc array
    
    float duc = ((Xc * lambda_min) / (4 * Y0)) / 1.2;

    /* number of samples on aperture */
    int   mc  = 2 * (int) ceil(L / duc);

    float dku = PI2 / ((float) mc * duc);
          
    /* synthetic aperture array */
    float[mc] uc;           
    float[mc] kuc;

    for (int i = 0; i < mc; i++) {
        uc[i]  = duc * (((float) i) - ((float) mc) / 2.0);
        kuc[i] = dku * (((float) i) - ((float) mc) / 2.0);
    }

    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    // %%    u domain parameters and arrays for SAR signal     %%
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    // 
    // theta_min=atan((-Y0-L)/(Xc-X0));  % minimum aspect angle
    // theta_max=atan((Y0+L)/(Xc-X0));   % max aspect angle [p79(3/7)]
    // du=lambda_min/(1.4*2*( sin(theta_max)- sin(theta_min) ));
    //                                   % sample spacing in aperture
    //                                   % domain for SAR signal [Delta u, p79(4/7)]
    //                                   % 20 percent guard band
    // m=2*ceil(pi/(du*dku));            % number of samples on aperture
    // du=pi2/(m*dku);                   % readjust du
    // u=du*(-m/2:m/2-1);                % synthetic aperture array
    // ku=dku*(-m/2:m/2-1);              % ku array
    
    float theta_min = atan((0 - Y0 - L) / (Xc - X0));
    float theta_max = atan((Y0 + L) / (Xc - X0)); 
    
    float du = lambda_min / (1.4 * 2 * (sin(theta_max) - sin(theta_min)));

    /* number of samples on aperture */
    int   m  = 2 * (int) ceil(PI / (du * dku));
          du = PI2 / (m * dku);                   
    
    /* synthetic aperture array */
    float[m] u;
    float[m] ku;           

    for (int i = 0; i < m; i++) {
        u[i]  = du  * (((float) i) - ((float) m) / 2.0);
        ku[i] = dku * (((float) i) - ((float) m) / 2.0);
    }
    
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    // %%       Fast-time domain parmeters and arrays          %%
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    //
    // Ts=(2/c)*Rmin;                 % start time of sampling [p19(2/6)]
    // Tf=(2/c)*Rmax+Tp;              % end time of sampling [p19(3/6)]
    // T=Tf-Ts;                       % fast-time interval of measurement
    // Ts = Ts - 0.1*T;
    // Tf = Tf + 0.1*T;
    // T=Tf-Ts;
    // Tmin=max(T,(4*X0)/(c*cos(theta_max)));  % Minimum required T
    // dt=1/(4*f0);                 % Time domain sampling (guard band factor 2)
    // n=2*ceil((.5*Tmin)/dt);      % number of time samples
    // t=Ts+(0:n-1)*dt;             % time array for data acquisition
    // k = (pi2/c)*(fc + 4*f0*(-n/2:n/2-1)/n);  % Wavenumber array
    
    float Ts   = (2 / c) * Rmin; 
    float Tf   = (2 / c) * Rmax + Tp;
    float T    = Tf - Ts;
    Ts         = Ts - 0.1 * T;  
    Tf         = Tf + 0.1 * T;  
    T          = Tf - Ts;
    float Tmin = max(T, (4 * X0) / (c * cos(theta_max))); 
    float dt   = 1 / (4 * f0);

    /* number of time samples */
    int   n    = 2 * (int) ceil((0.5 * Tmin) / dt);     
    
    /* Wavenumber array */
    float[n] t;
    float[n] k;
    
    for (int i = 0; i < n; i++) {
        t[i] = Ts + i * dt;
        k[i] = (PI2 / c) * (fc + 4 * f0 * (((float) i) - ((float) n) / 2.0) / n);
    }
    
    // NOTE: the last three stages of of genRawSAR appear in genRawSAR.str

    // Generate Raw Image
    /// s=ftx(s).*fast_time_filter;
    add void->int filter { // NOTE: mock filter to ger around compiler limitation w.r.t. null splitters
        work push 1 { push(1); }
    }
    add int->complex pipeline {
        add int->complex splitjoin {
            split duplicate;
            add FastTimeFilter(n, t);
            add pipeline {
                /// generate s
                add genRawSAR(Tf, n, m, mc, t, k, ku, uc);
                /// s = ftx(s)
                add FTX2D(n, mc);
            }
            join roundrobin(1, mc);
        }
        
        add complex->complex filter {
            work pop n+n*mc push n*mc {
                for (int i = 0; i < n; i++) {
                    complex ftf = pop();
                    for (int j = 0; j < mc; j++) {
                        complex s   = pop();
                        complex out;
                        
                        out.real = s.real * ftf.real - s.imag * ftf.imag;
                        out.imag = s.imag * ftf.real + s.real * ftf.imag;
                        
                        push(out);
                    }
                }
            }
        }
    }

    // Digital Spotlighting and Bandwidth Expansion in ku Domain  
    // via Slow-time Compression and Decompression

    //// Compression
    //// cs=s.*exp(cj*2*(k(:)*ones(1,mc)).*
    ////           (ones(n,1)*sqrt(Xc^2+(-uc).^2))-
    ////           cj*2*k(:)*Xc*ones(1,mc));
    add Compression(n, mc, k, uc);    

    //// Narrow-bandwidth Polar Format Processed reconstruction
    //// fp=fty(cs);
    add FTY2D(n, mc);   

    add PrintComplex(n, mc, false);

    /* NOTE: rest of pipeline not verified against matlab code

    //// Zero-padding in ku domain for slow-time upsampling
    //// mz=m-mc;
    //// fcs=(m/mc)*[zeros(n,mz/2),fp,zeros(n,mz/2)];
    add ZeroPadding(n, m, mc);
    
    //// Transform to (omega,u) domain
    //// cs=ifty(fcs);
    add iFTY2D(n, m);
    
    //// Decompression
    //// s=cs.*exp(-cj*2*(k(:)*ones(1,m)).*
    ////          (ones(n,1)*sqrt(Xc^2+(-u).^2))+
    ////          cj*2*k(:)*Xc*ones(1,m));
    add Decompression(n, m, k, u);

    //// Digitally-spotlighted SAR signal spectrum
    //// fs=fty(s);                 
    add FTY2D(n, m);
  
    // SAR RECONSTRUCTION (multiple stages)
    // - 2D Fourier Matched Filtering and Interpolation
    // - Inverse 2D FFT for spatial domain image
    //add Reconstruction(n, m, k, ku);

    // add PrintComplex(n, mc, true);
    //add PrintFloat();

    */
}


// Zero-padding
// fcs=(m/mc)*[zeros(n,mz/2),fp,zeros(n,mz/2)];
complex->complex filter ZeroPadding(int n, 
                                    int m, 
                                    int mc)
{
    int     mz = m - mc;
    float   q  = (float) m / (float) mc;
    complex zero;

    init {
        zero = 0 + 0i;
    }
    
    work push n*m pop n*mc {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if ((j < mz / 2) || ( j >= mc+mz / 2)) {
                    push(zero);
                } else {
                    complex in = pop();
                    complex out;
                    out.real = q * in.real; //fp[i][j-mz/2].real;
                    out.imag = q * in.imag; //fp[i][j-mz/2].imag;
                    push(out);
                }
            }
        }
    }
}

// Compression
// cs=s.*exp(cj*2*(k(:)*ones(1,mc)).*
//           (ones(n,1)*sqrt(Xc^2+(-uc).^2))-
//           cj*2*k(:)*Xc*ones(1,mc));
complex->complex filter Compression(int n, 
                                    int mc, 
                                    float[n] k, 
                                    float[mc] uc)
{
    float[n][mc] cos_value;
    float[n][mc] sin_value;
    
    init {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < mc; j++){
                float value = 
                    2 * (k[i] * (sqrt(pow(Xc, 2) + pow(uc[j], 2)) - Xc));
                
                cos_value[i][j] = cos(value);
                sin_value[i][j] = sin(value);
            }
        }
    }
    
    work push n*mc pop n*mc {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < mc; j++){
                complex in = pop(); // s[i][j]
                complex out;
                
                out.real = 
                    (in.real * cos_value[i][j]) - 
                    (in.imag * sin_value[i][j]);
                
                out.imag =
                    (in.imag * cos_value[i][j]) + 
                    (in.real * sin_value[i][j]);
                
                push(out);
            }
        }
    }
}

// Decompression
// s=cs.*exp(-cj*2*(k(:)*ones(1,m)).*
//          (ones(n,1)*sqrt(Xc^2+(-u).^2))+
//          cj*2*k(:)*Xc*ones(1,m));
complex->complex filter Decompression(int n, 
                                      int m, 
                                      float[n] k, 
                                      float[m] u)
{
    float[n][m] cos_value;
    float[n][m] sin_value;
    
    init {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++){
                float value = 
                    2 * (k[i] * (sqrt(pow(Xc, 2) + pow(u[j], 2)) - Xc));
                
                cos_value[i][j] = cos(value);
                sin_value[i][j] = sin(value);
            }
        }
    }
    
    work push n*m pop n*m {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++){
                complex in = pop(); // cs[i][j]
                complex out;
                
                out.real = 
                    (in.real * cos_value[i][j]) +
                    (in.imag * sin_value[i][j]);
                
                out.imag =
                    (in.imag * cos_value[i][j]) - 
                    (in.real * sin_value[i][j]);
                
                push(out);
            }
        }
    }
}

// Reconstruction (multiple stages)
complex->float pipeline Reconstruction(int n,
                                       int m,
                                       float[n] k, 
                                       float[m] ku)
{
    // ku=ones(n,1)*ku;                    % ku array
    // kx=(4*k(:).^2)*ones(1,m)-ku.^2;     % [p197(1/6), p200(1/6)(3/6)]
    // kx=sqrt(kx.*(kx > 0));              % kx array
    // % 2D Matched filtering [p203, fast-time and slow-time domains]
    // fs0=(kx > 0).*exp(cj*kx*Xc+cj*ku+cj*.25*pi ...
    //            -cj*2*k(:)*ones(1,m)*Xc); % reference signal complex conjugate
    // fsm=fs.*fs0;
    add matchedFiltering(n, m, k, ku);

    // kxmin=min(min(kx));
    // kxmax=max(max(kx));
    // dkx=pi/X0;           % Nyquist sample spacing in kx domain
    // nx=2*ceil((.5*(kxmax-kxmin))/dkx); % Required number of
    //                      % samples in kx domain;
    //                      % This value will be increased slightly
    //                      % to avoid negative array index
    // is=single(8);        % number of neighbors (sidelobes) used for sinc interpolator
    // nx=nx+2*is+4;        % increase number of samples to avoid negative
    //                      % array index during interpolation in kx domain
    // NOTE: <nx> is predefined because it cannot be practically
    // resolved at compile time (requires a 70K element to be 
    // unrolled, which in turns leads to 1.4M LOC that choke gcc)
    int nx  = 266;

    // I=2*is+1;
    // KX=kxmin+(-is-2:nx-is-3)*dkx;     % uniformly-spaced kx points where
    //                                   % interpolation is done
    // kxs=is*dkx; % plus/minus size of interpolation neighborhood in KX domain
    // F=single(zeros(nx,m));         % initialize F(kx,ku) array for interpolation output        
    // for i=1:n                      % for each k loop
    //  icKX=round((kx(i,:)-KX(1,1))/dkx)+1; % closest grid point in KX domain
    //  ikx=ones(I,1)*icKX+[-is:is]'*ones(1,m);
    //  ikx=ikx+nx*ones(I,1)*[0:m-1];
    //  nKX=KX(ikx);
    //  SINC=sinc((nKX-ones(I,1)*kx(i,:))/dkx);             % interpolating sinc [p144(3/4),p204(1/7)]
    //  HAM=.54+.46*cos((pi/kxs)*(nKX-ones(I,1)*kx(i,:)));  % Hamming window [p204(4/7)]
    //          %%%%%   Sinc Convolution (interpolation) follows  %%%%%%%%
    //  % [I = subsampled index in ku domain]
    //  F(ikx)=F(ikx)+(single(ones(I,1))*fsm(i,:)).*(SINC.*HAM);
    // end
    add complex->complex splitjoin {
	  split roundrobin(m);

	  for (int i = 0; i < n; i++) {	  
          add convolutionInterpolation(i, n, nx, m, k, ku);
	  }

	  join roundrobin(1);
    }
    // NOTE: replace with user programmable splitjoin
    add complex->complex filter {
	  work pop n push 1 {
		complex out;

		for (int i = 0; i < n; i++) {
		    complex in = pop();
		    out.real += in.real;
		    out.imag += in.imag;
		}
		push(out);
	  }
    }

    /// Inverse 2D FFT for spatial domain image f(x,y) [p203 fig4.6]
    /// f=iftx(ifty(F)); 
    add iFTY2D(nx, m);
    add iFTX2D(nx, m);
    
    /// image=abs(f)';
    add complex->float filter {
        work push nx*m pop nx*m {
            float[m][nx] X_image;
            
            for (int i = 0; i < nx; i++) {
                for (int j = 0; j < m; j++){
                    complex in = pop(); // f[i][j]
                    X_image[j][i] = sqrt(pow(in.real, 2) +
                                         pow(in.imag, 2));
                }
            }
            for (int i = 0; i < nx; i++) {
                for (int j = 0; j < m; j++){
                    push(X_image[j][i]);
                }
            }
        }
    }
}

// matchedFilterting (stage 1 of Reconstruction)
// ku=ones(n,1)*ku;                    % ku array
// kx=(4*k(:).^2)*ones(1,m)-ku.^2;     % [p197(1/6), p200(1/6)(3/6)]
// kx=sqrt(kx.*(kx > 0));              % kx array
// % 2D Matched filtering [p203, fast-time and slow-time domains]
// fs0=(kx > 0).*exp(cj*kx*Xc+cj*ku+cj*.25*pi ...
//            -cj*2*k(:)*ones(1,m)*Xc); % reference signal complex conjugate
// fsm=fs.*fs0;
complex->complex filter matchedFiltering(int n,
                                         int m, 
                                         float[n] k, 
                                         float[m] ku)
{
    // NOTE: <kx> is redefined because of a lack of proper support
    // for global arrays the array itself is too big to be fully 
    // unrolled since it leads to 1.4M lines of code and chokes gcc    
    float[n][m]   kx;
    complex[n][m] fs0;

    init {
        // ku=ones(n,1)*ku;                    % ku array
        // kx=(4*k(:).^2)*ones(1,m)-ku.^2;     % [p197(1/6), p200(1/6)(3/6)]
        // kx=sqrt(kx.*(kx > 0));              % kx array
        for (int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                float val = (4 * (k[i] * k[i])) - (ku[j] * ku[j]);
                
                if (val > 0) {
                    kx[i][j] = sqrt(val);
                } 
                else { 
                    kx[i][j] = 0; 
                }
            }
        }

        // fs0=(kx > 0).*exp(cj*kx*Xc+cj*ku+cj*.25*pi ...
        //            -cj*2*k(:)*ones(1,m)*Xc); % reference signal complex conjugate
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (kx[i][j] > 0) {
                    float value = kx[i][j] * Xc + ku[j] + 0.25 * PI - 2 * k[i] * Xc;
                    fs0[i][j].real = cos(value);
                    fs0[i][j].imag = sin(value);
                }
                // else{ fs0[i][j].real=0; fs0[i][j].imag=0; }
            }
        }
    }
    
    work pop n*m push n*m {
        // fsm=fs.*fs0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                complex fs = pop();
                complex out;
                
                out.real = fs.real * fs0[i][j].real - fs.imag * fs0[i][j].imag;
                out.imag = fs.real * fs0[i][j].imag + fs.imag * fs0[i][j].real;
                push(out);
            }
        }
    }
}

// convolutionInterpolation (stage 2 of Reconstruction)
// ku=ones(n,1)*ku;                    % ku array
// kx=(4*k(:).^2)*ones(1,m)-ku.^2;     % [p197(1/6), p200(1/6)(3/6)]
// kx=sqrt(kx.*(kx > 0));              % kx array
// kxmin=min(min(kx));
// kxmax=max(max(kx));
// dkx=pi/X0;           % Nyquist sample spacing in kx domain
// nx=2*ceil((.5*(kxmax-kxmin))/dkx); % Required number of
//                      % samples in kx domain;
//                      % This value will be increased slightly
//                      % to avoid negative array index
// is=single(8);        % number of neighbors (sidelobes) used for sinc interpolator
// nx=nx+2*is+4;        % increase number of samples to avoid negative
//                      % array index during interpolation in kx domain
// I=2*is+1;
// kxs=is*dkx; % plus/minus size of interpolation neighborhood in KX domain

// KX=kxmin+(-is-2:nx-is-3)*dkx;     % uniformly-spaced kx points where
//                                   % interpolation is done
// F=single(zeros(nx,m));                % initialize F(kx,ku) array for interpolation output        
// (in parent splitjoin): for i=1:n                     % for each k loop
//  icKX=round((kx(i,:)-KX(1,1))/dkx)+1; % closest grid point in KX domain
//  ikx=ones(I,1)*icKX+[-is:is]'*ones(1,m);
//  ikx=ikx+nx*ones(I,1)*[0:m-1];
//  nKX=KX(ikx);
//  SINC=sinc((nKX-ones(I,1)*kx(i,:))/dkx);             % interpolating sinc [p144(3/4),p204(1/7)]
//  HAM=.54+.46*cos((pi/kxs)*(nKX-ones(I,1)*kx(i,:)));  % Hamming window [p204(4/7)]
//          %%%%%   Sinc Convolution (interpolation) follows  %%%%%%%%
//  % [I = subsampled index in ku domain]
//  F(ikx)=F(ikx)+(single(ones(I,1))*fsm(i,:)).*(SINC.*HAM);
// (in parent splitjoin): end
complex->complex filter convolutionInterpolation(int streamIndex,
                                                 int n,
                                                 int nx, 
                                                 int m, 
                                                 float[n] k, 
                                                 float[m] ku)
{
    // NOTE: <kx> is redefined because of a lack of proper support
    // for global arrays the array itself is too big to be fully 
    // unrolled since it leads to 1.4M lines of code and chokes gcc
    float[n][m] kx;
    float kxmin = 1e25;
    float kxmax = 0;
    // dkx=pi/X0;  % Nyquist sample spacing in kx domain
    float dkx = PI / X0;
    int   is  = 8;
    // nx=2*ceil((.5*(kxmax-kxmin))/dkx); % Required number of
    //                      % samples in kx domain;
    //                      % This value will be increased slightly
    //                      % to avoid negative array index
    // nx=nx+2*is+4;        % increase number of samples to avoid negative
    //                      % array index during interpolation in kx domain
    // NOTE: <nx> is predefined, see comment in parent pipeline
    // I=2*is+1;
    int   I   = 2 * is + 1;
    // kxs=is*dkx; % plus/minus size of interpolation neighborhood in KX domain
    float kxs = (float) is * dkx;
    float[nx] KX;

    int[m]      icKX;
    int[I][m]   ikx;
    float[I][m] nKX;
    float[I][m] SINC;
    float[I][m] HAM;

    complex[nx][m] F;

    init {
        // ku=ones(n,1)*ku;                    % ku array
        // kx=(4*k(:).^2)*ones(1,m)-ku.^2;     % [p197(1/6), p200(1/6)(3/6)]
        // kx=sqrt(kx.*(kx > 0));              % kx array
        // kxmin=min(min(kx));
        // kxmax=max(max(kx));
        for (int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                float val = (4 * (k[i] * k[i])) - (ku[j] * ku[j]);
                
                if (val > 0) {
                    kx[i][j] = sqrt(val);
                } 
                else { 
                    kx[i][j] = 0; 
                }

                if (kxmax < kx[i][j]) {
                    kxmax = kx[i][j];
                }
                if (kxmin > kx[i][j]) {
                    kxmin = kx[i][j];
                }
            }
        }

        // KX=kxmin+(-is-2:nx-is-3)*dkx;     % uniformly-spaced kx points where
        // 
        for (int i = 0; i < nx; i++) {
            KX[i] = kxmin + ((0 - is) - 2 + i) * dkx;
        }

        for (int j = 0; j < m; j++) {
            // icKX=round((kx(i,:)-KX(1,1))/dkx)+1;
            icKX[j] = (int) round((kx[streamIndex][j] - KX[0]) / dkx) + 1;
            
            for (int l = 0; l < I; l++) {
                // ikx=ones(I,1)*icKX+[-is:is]'*ones(1,m);
                ikx[l][j] = icKX[j] + (l - is);
                //  ikx=ikx+nx*ones(I,1)*[0:m-1];
                ikx[l][j] = ikx[l][j] + nx * j;
                //  nKX=KX(ikx);
                nKX[l][j] = KX[ikx[l][j] % nx];
                // SINC=sinc((nKX-ones(I,1)*kx(i,:))/dkx);
                if ((nKX[l][j] - kx[streamIndex][j]) / dkx == 0) {
                    SINC[l][j] = 1;
                }
                else {
                    SINC[l][j] = sin(PI * (nKX[l][j] - kx[streamIndex][j]) / dkx) / 
                                  (PI * (nKX[l][j] - kx[streamIndex][j]) / dkx);
                }
                
                // HAM=.54+.46*cos((pi/kxs)*(nKX-ones(I,1)*kx(i,:)));
                HAM[l][j] = 0.54 + 0.46 * cos((PI / kxs) * (nKX[l][j] - kx[streamIndex][j]));
            }
        }
    }
    
    work push nx*m pop m {
        for (int j = 0; j < I; j++) {
            for(int l = 0; l < m; l++) {
                //  F(ikx)=F(ikx)+(single(ones(I,1))*fsm(i,:)).*(SINC.*HAM);
                complex t = peek(l);

                int ri = ikx[j][l] % nx;
                int ci = (ikx[j][l] - ikx[j][l] % nx) / nx;

                F[ri][ci].real += t.real * SINC[j][l] * HAM[j][l];
                F[ri][ci].imag += t.imag * SINC[j][l] * HAM[j][l];
            }
        }

        for (int j = 0; j < nx; j++) {
            for(int l = 0; l < m; l++) {
                push(F[j][l]);
            }
        }
        
        for(int l = 0; l < m; l++) {
            pop();
        }
    }
}


complex->void filter PrintComplex(int n, int m, boolean transpose)
{
    work pop n*m {
        complex[n][m] t;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                t[i][j] = pop();
            }
        }

        if (!transpose) {
            for (int i = 0; i < n; i++)
                for (int j = 0; j < m; j++)
                    println(t[i][j].real);

            for (int i = 0; i < n; i++)
                for (int j = 0; j < m; j++)
                    println(t[i][j].imag);
        }
        else {
            for (int j = 0; j < m; j++)
                for (int i = 0; i < n; i++)
                    println(t[i][j].real);

            for (int j = 0; j < m; j++)
                for (int i = 0; i < n; i++)
                    println(t[i][j].imag);
        }
    }
}

float->void filter PrintFloat()
{
    work pop 1 {
	  println(pop());
    }
}

complex->complex filter DebugComplex()
{
    work pop 1 push 1 {
        complex t = pop();
        print(t.real);
        print("+");
        print(t.imag);
        println("i");
        push(t);
    }
}
