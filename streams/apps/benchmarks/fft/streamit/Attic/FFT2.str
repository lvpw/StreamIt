complex->complex filter CombineDFT(int n)
{  
    complex[n] Ws;
    complex[n] results;

    init
    {
	complex wn;
	wn = exp(2i * 3.14159265358979 / n);	
	Ws[0].real=1;
	Ws[0].imag=0;
	for (int i=1; i < n; i++)
	    Ws[i]=Ws[i-1]*wn;	
    }

    work push n peek n pop n 
    {
        int i;

	for (i = 0; i < n/2; i ++)
        {
	    complex y0;
	    complex y1;
	    complex y1t;
	    
	    y0=peek(i);
	    y1=peek(n/2+i);
	    
	    y1t=y1*Ws[i];

            results[i] = y0 + y1t;
        
            results[n/2 + i] = y0-y1t;
	    
         }

        for (i = 0; i < n; i++)
        {
	    pop();
	    push(results[i]);
        }
    }
}

complex->complex filter FFTReorderSimple(int n)
{
    work peek n push n pop n
    {
        int i;
        
        for (i = 0; i < n; i+=2)
            push(peek(i));
        
        for (i = 1; i < n; i+=2)
            push(peek(i));
        
        for (i=0;i<n;i++)
            pop();
    }
}

complex->complex pipeline FFTReorder(int nWay) 
{
    int n = nWay;
    while (n > 2)
    {
        add FFTReorderSimple(n);
	n = n / 2;
    }    
}

complex->complex pipeline check(int nWay)
{
        add FFTReorder(nWay);
        int n = 2;
        while (n <= nWay)
        {
            add CombineDFT(n);
            n = n * 2;
        }
    
}

void->complex filter source(){
    int i;

    init{
    i=0;
    }
    
    work pop 0 push 1 {
        complex c = i;
	push(c);
	i++;
    }
}

complex->void filter sink(){
    work pop 1 push 0 {
        complex c = pop();
        print(c.real);
        print(c.imag);
    }
}

void->void pipeline FFT2() {
    add source();
    add check(8);
    add sink();
}
	
/*

public class FFT2 extends StreamIt
{
    public static void main(String[] args)
    {
        new FFT2().run(args);
    }
    public void init()
    {
        add(new OneSource());
        add(new FFTKernel2(16));
        add(new FloatPrinter());
    }
}


*/








