complex->complex filter CombineDFT(int nWay)
{
  complex wn;
  init { wn = exp(2i*pi/nWay); }
  work pop nWay push nWay
  {
    int i;
    complex w = 0;
    complex[nWay] results;
    for (i = 0; i < nWay; i++)
    {
      complex y0 = peek(i);
      complex y1 = peek(nWay/2 + i);
      complex y1w = y1 * w;
      results[i] = y0 + y1w;
      results[nWay/2 + i] = y0 - y1w;
      w = w * wn;
    }
    for (i = 0; i < nWay; i++)
    {
      pop();
      push(results[i]);
    }
  }
}

complex->complex filter FFTReorderSimple(int nWay)
{
  work pop nWay push nWay
  {
    int i;
    for (i = 0; i < nWay; i += 2)
      push(peek(i));
    for (i = 1; i < nWay; i += 2)
      push(peek(i));
    for (i = 0; i < nWay; i++)
      pop();
  }
}

complex->complex pipeline FFTReorder(int nWay)
{
  for (int i = 1; i < nWay/2; i *= 2)
    add FFTReorderSimple(nWay / i);
}

complex->complex pipeline FFTKernel(int nWay)
{
  if (nWay > 2) add splitjoin {
    split roundrobin;
    add FFTKernel(nWay / 2);
    add FFTKernel(nWay / 2);
    join roundrobin(nWay / 2);
  }
  add CombineDFT(nWay);
}

void->complex filter FFTTestSource(int nWay)
{
  work push nWay
  {
    push(0+0i);
    push(1+0i);
    for (int i = 2; i < nWay; i++)
      push(0+0i);
  }
}

void->void pipeline FFT
{
  add FFTTestSource(64);
  add FFTKernel(64);
  add complex->void filter {
    work pop 1 { complex c = pop(); print(c.real); print(c.imag); }
  }
}
