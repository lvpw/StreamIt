#!/usr/uns/bin/perl
#
# strc: StreamIt compiler wrapper
# David Maze <dmaze@cag.lcs.mit.edu>
# $Id: strc,v 1.65 2005-12-17 02:25:18 rabbah Exp $
#
# Copyright 2003 by the Massachusetts Institute of Technology.
#
# Permission to use, copy, modify, and distribute this
# software and its documentation for any purpose and without
# fee is hereby granted, provided that the above copyright
# notice appear in all copies and that both that copyright
# notice and this permission notice appear in supporting
# documentation, and that the name of M.I.T. not be used in
# advertising or publicity pertaining to distribution of the
# software without specific, written prior permission.
# M.I.T. makes no representations about the suitability of
# this software for any purpose.  It is provided "as is"
# without express or implied warranty.
#

use strict;
use warnings;
use vars qw(%opts $java $javac $cc $have_fftw);
use POSIX qw(:sys_wait_h);

# QMTest 2.3 running in some way different from QMTest 2.0.3
#foreach (sort keys(%ENV)) { print "$_ = $ENV{$_}\n"; }
#print STDERR getcwd(), "\n";

use Cwd;

# AUTOCONFISCATE $var = "@VAR@";
$java = "java";
$javac = "javac";
$cc = "gcc";
$have_fftw = "1";
# END AUTOCONFISCATE

# Enable assertions globally:
$java = $java . " -ea";

use Getopt::Long;
Getopt::Long::Configure("bundling", "bundling_override", "no_ignore_case");

get_options() or die "Error parsing options";
if ($opts{'much-more-help'})
  {
    usage(\*STDOUT, 2);
    exit(0);
  }
if ($opts{'more-help'})
  {
    usage(\*STDOUT, 1);
    exit(0);
  }
if ($opts{help})
  {
    usage(\*STDOUT, 0);
    exit(0);
  }
if (!$opts{home})
  {
    print <<EOH;
The STREAMIT_HOME environment variable is unset.  Please see the
instructions in the INSTALL file; you will need to modify your shell's
startup files, then log out and log in again.
EOH
#'
    exit(1);
  }
if (!@ARGV)
  {
    print <<EOH;
strc: StreamIt compiler wrapper
Usage: strc [options] file.str ...
Run 'strc --help' for option listing
EOH
    exit(0);
  }
my $fns = \@ARGV;
# Autodetect old-syntax code:
if (!exists $opts{java})
  {
    my $non_java = grep(!/\.java$/, @$fns);
    $opts{java} = !$non_java;
    # which is to say, 1 if there are no non-java files, 0 otherwise
  }
$fns = new_to_old($fns) unless ($opts{java} || $opts{tokopi});
exit(1) if !$fns;
if ($opts{streamit}) {
  $fns = streamit_to_streamit($fns);
  exit(1) if !$fns;
  # Stop now if no other backends were requested.
  exit(0) unless $opts{'library'} || $opts{'uni'} || $opts{raw} ||
    $opts{cluster};
  # Well, okay, get old syntax again.
  $fns = new_to_old($fns) unless $opts{tokopi};
}
exit(1) if !$fns;
if ($opts{'library'}) {
    exit(1) if ! defined run_in_library($fns);
    exit(0);
}
$fns = old_to_c($fns) unless $opts{tokopi};
exit(1) if !$fns;
$fns = new_to_c($fns) if $opts{tokopi};
exit(1) if !$fns;
$fns = c_to_out($fns, $opts{output}) unless 
    ($opts{raw} || $opts{cluster} || $opts{absarray} || $opts{doloops});
exit(1) if !$fns;
exit(0);

sub usage
  {
    my ($fh, $more) = @_;
    my $text = <<'EOT';
strc: StreamIt compiler wrapper

Usage: strc [options] file.str ...
	
Options:
  --help              Show this screen
  --more-help         Include extra options
* --much-more-help    Include internal-only options
+ --java              Input file is "old" syntax (in Java)
  --output, -o file   Write a binary to given filename
  --uni               Compile for uniprocessor with C library (default)
  --raw n, -r n       Compile for Raw, with an n-by-n grid
  --standalone, -S    Generate C file without library dependencies
  --rstream, -R       Generate C file to be compiled by RStream compiler 
* --streamit          Output of the compiler is a StreamIt program
+ --cluster n         Compile for a networked cluster with n nodes
* --viram             Compile for VIRAM, a vector uniprocessor
* --backend class     Explicitly specify the backend class
  --library           Run in the Java library instead of compiling
  --memory, -Xmx      Specify Java runtime heap limit
  --verbose           Print commands as they are executed

Options available for all backends:
  -O0, -O1, -O2       Use predefined optimization sets
+ --destroyfieldarray Break arrays in structures into component elements
* --clone-with-serialization
*                     Use old serialization code to copy objects
+ --debug             Output debugging information in the compiler
+ --fusion            Fuse entire program to a single filter
+ --fission           Do vertical fission up to limit of argument
  --linearreplacement, -l
                      Perform linear transformations based on analysis
* --linearreplacement2
*                     Do linear replacement using a level of indirection
* --linearreplacement3
*                     Do linear replacement using diagonal replacement
+ --macros            Convert small functions to macros (inlining them)
+ --modfusion         Use wraparound buffers (vs. copying) for fusion
* --nofieldprop       Do not propagate constant field values
* --nolinearcollapse
*                     Do not combine filters with linear replacement
+ --print-partitioned-source
+                     Print equivalent source after partitioning
* --redundantreplacement
*                     Create linear filters without redundant computation
* --server            Run with "java -server", faster for large programs
* --simplesjfusion    Revert to the old, simple SplitJoin fusion algorithm
+ --sjtopipe          Convert split-joins to pipelines
+ --statespace        Use state-space representation for linear analyses
* --stats             Gather statistics for program characterization
* --tokopi            Use experimental frontend-to-SIR conversion
+ --sync              Turn on sync removal
  --unroll, -u        Specify loop unrolling limit

Options specific to Raw backend:
  --partition, -p     Automatically partition stream graph
+   --partition-dp       Dynamic programming partitioner (default)
+   --partition-greedy   Greedy partitioner (fuse lightest streams first)
+   --partition-greedier Greedier partitioner (fuse lightest filter pairs)
* --altcodegen        Alternate Raw communication code generation
* --decoupled         Generate dummy communication code
* --dpscaling         Collect theoretical scaling statistics
* --forceunroll       Force unroll to -u amount (even if overflows IMEM)
+ --manual            Specify Java class for performing manual optimizations
  --magic-net, -M     Generate Raw "magic network" code
* --noanneal          Do not run simulated annealing for layout
  --numbers n, -N     Automatically gather numbers and put in results.out
+ --ptraccess         Access buffers through a pointer
+ --ratematch         Turn on rate matching
  --rawcol, -c        Specify number of columns; --raw has number of rows
+ --removeglobals     Inline all functions and turn globals into locals
+ --simulatework, -s  Use simulator for work estimation
* --spacetime         Use space-time partitioner
* --spacedynamic      Use the space-muliplexing Raw backend with dynamic rate support
* --dynamicnet        Use dynamic network for communication for space multplexing raw backend
* --magicdram         Use magic DRAMs in the space-tile partitioner
  --wbs               Use work-based simulator for communication code
* --steadymul n       For the SpaceTime Raw backend, multiply the steady-state multiplicities by n
* --forceplacement    For the SpaceTime Raw backend, try to minimize communication in layout
* --scheduler         For the SpaceTime Raw backend, either work, dep, or comm
* --malloczeros       For spacedynamic, generate malloc instead of calloc (malloc will zero)
* --nopartition       For spacedynamic, do not attempt to partition each static subgraph
* --layoutfile        For spacedynamic, specify a layout file (a new-line separated list of tiles)
* --devassignfile     For spacedynamic, specify a device-to-port assignment file (a new-line separated list of tiles)

Options specific to uniprocessor backend:
  --frequencyreplacement, -F
                      Convert FIR filters to frequency
  --linearpartition, -L
                      Automatically selecting targets of linear analyses
* --atlas             Use ATLAS for generated matrix multiplies
+ --poptopeek         Convert all pop expressions into peeks
  --profile           Compile with profiling information

Options specific to the RStream backend:
  --doloops           Generate doloops instead of for loops where possible
  --absarray          Generate abstract arrays instead of C arrays

Options specific to Java library backend:
  --iterations, -i    Specify number of iterations to run
  --norun             Schedule but do not run the program
  --nosched           Run the program in pull mode, not under the scheduler
  --marksteady        Print * after each steady-state execution
  --printreps         Print number of times filters execute in schedule
  --printsched        Print the full program schedule
EOT
    $text =~ s/^\*/ /mg if $more >= 2;
    $text =~ s/^\+/ /mg if $more >= 1;
    $text =~ s/^[*+].*\n//mg;
    print $fh $text;
}

sub get_options
  {
    $opts{home} = $ENV{STREAMIT_HOME};
    $opts{memory} = "1700M";
    # Note: the exclamation points below indicate negatable options.  That is,
    # for an option "myoption!", you can pass either "--myoption" or
    # "--no-myoption" at the command line.  Only makes sense for boolean 
    # options.
    my $result = GetOptions(\%opts,
			    "help",
			    "more-help|help-more",
			    "much-more-help|help-much-more",
			    "java!",
			    "output|o=s",
			    "raw|r=i",
			    "verbose|v",
			    "optimize|O=i",
			    "altcodegen",
			    "atlas!",
			    "backend=s",
			    "clone-with-serialization|clone_with_serialization",
			    "debug!",
			    "decoupled",
			    "dpscaling",
			    "fission=i",
			    "frequencyreplacement|F",
			    "forceunroll",
			    "fusion",
			    "iterations|i=i",
			    "library!",
			    "linearanalysis",
			    "linearpartition|L",
			    "linearreplacement|l",
			    "linearreplacement2",
			    "linearreplacement3",
			    "magic-net|magic_net|M",
			    "macros",
			    "manual=s",
			    "memory|Xmx=s",
			    "modfusion",
			    "noanneal",
			    "nofieldprop",
			    "nolinearcollapse",
			    "norun",
			    "nosched",
			    "numbers|N=i",
			    "partition|p",
			    "partition-dp|pdp",
			    "partition-greedy|pgreedy",
			    "partition-greedier|pgreedier",
			    "poptopeek",
			    "marksteady!",
			    "printreps!",
			    "printsched!",
			    "print-partitioned-source|print_partitioned_source",
			    "profile!",
			    "ptraccess",
			    "ratematch",
			    "rawcol|c=i",
			    "redundantreplacement",
			    "removeglobals",
			    "simplesjfusion",
			    "simulatework|s",
			    "sjtopipe",
			    "spacetime!",
			    "spacedynamic!",
			    "dynamicnet!",
			    "statespace!",
			    "absarray!",
			    "doloops!",
			    "magicdram!",
			    "standalone|S",
			    "rstream|R",
			    "server!",
			    "stats!",
			    "streamit",
			    "sync",
			    "tokopi!",
			    "uni",
			    "unroll|u=i",
			    "viram",
			    "wbs!",
			    "cluster=i",
			    "steadymult=i",
			    "forceplacement!",
			    "malloczeros!",
			    "nopartition!",
			    "layoutfile=s",
			    "devassignfile=s",
			    "scheduler=s",
			    "destroyfieldarray!",
			    "cacheopt!",
			    "nomult!",
			    "rename1!",
			    "rename2!",
			    "peekratio=i");
    return $result if !$result;
    # Figure out which partitioning is in use, if any:
    $opts{partition} = "greedier" if $opts{'partition-greedier'};
    $opts{partition} = "greedy" if $opts{'partition-greedy'};
    $opts{partition} = "dp" if $opts{'partition-dp'};
    # Default to DP partitioning, if we've selected partitioning
    # but none of these options.
    $opts{partition} = "dp" if $opts{partition} &&
      !grep {$opts{partition} eq $_} ('dp', 'greedy', 'greedier');
    # If the user specified -O#, transform that into appropriate options,
    # but don't override things otherwise on the command line.
    if (exists $opts{optimize})
      {
	if ($opts{optimize} >= 2)
	  {
	    $opts{unroll} = 256 unless exists $opts{unroll};
	    $opts{removeglobals} = 1 unless exists $opts{removeglobals};
	    $opts{partition} = "dp" unless $opts{partition};
            # macros don't work yet in the cluster backend
            $opts{macros} = 1 unless (exists $opts{macros} || exists $opts{cluster});
	  }
	if ($opts{optimize} >= 1)
	  {
	    $opts{unroll} = 16 unless exists $opts{unroll};
	    $opts{ratematch} = 1 unless exists $opts{ratematch};
	    $opts{wbs} = 1 unless exists $opts{wbs};
	    $opts{destroyfieldarray} = 1 unless
	      exists $opts{destroyfieldarray};
	    $opts{partition} = "dp" unless $opts{partition};
	  }
	if ($opts{optimize} >= 0)
	  {
	    $opts{unroll} = 0 unless exists $opts{unroll};
	  }
      }
    return 1;
  }

sub call
  {
    my ($cmd) = @_;
    print "$cmd\n" if $opts{verbose};
    my $result = system($cmd);
    if ($opts{verbose} && $result != 0)
      {
	if (WIFSIGNALED($?))
	  {
	    print "(exited with signal " . WTERMSIG($?) . ")\n";
	  }
	else
	  {
	    print "(exited with value " . WEXITSTATUS($?) . ")\n";
	  }
      }
    return $result;
  }

sub change_extension
  {
    my ($old, $from, $to) = @_;
    my $fn = $old;
    $fn =~ s/.$from$//;
    $fn .= ".$to";
    return $fn;
  }

sub remove_extension
  {
    my ($old, $from) = @_;
    my $fn = $old;
    $fn =~ s/.$from$//;
    return $fn;
  }

sub new_to_old
  {
    my ($fns) = @_;
    return [] if !@$fns;
    my $xmx = "-Xmx" . $opts{memory};
    my $server = $opts{server} ? "-server" : "";
    my $target = change_extension($fns->[0], "str", "java");
    my $libflag = "";
    $libflag = "--library" if $opts{library};
    my $result = call("$java $xmx $server streamit.frontend.ToJava --output $target " .
		      "$libflag " . join(' ', @$fns));
    return undef if $result != 0;
    return [$target];
  }

sub streamit_to_streamit
  {
    my ($fns) = @_;
    return [] if !@$fns;
    my $kjcopts = get_kjc_opts();
    my $xmx = "-Xmx" . $opts{memory};
    my $server = $opts{server} ? "-server" : "";
    my $jfiles = join(' ', @$fns);
    my $target = change_extension($fns->[0], "java", "str");
    # Add "_c" to the basename.
    $target =~ s/^([^.]*)/$1_c/;
    my $result = call("$java $xmx $server at.dms.kjc.Main --streamit " .
		      "--backend at.dms.kjc.sir.SIRToStreamIt " .
		      "$kjcopts $jfiles > $target");
    return undef if $result != 0;
    return [$target];
  }

sub old_to_c
  {
    my ($fns) = @_;
    return [] if !@$fns;
    my $kjcopts = get_kjc_opts();
    my $xmx = "-Xmx" . $opts{memory};
    my $server = $opts{server} ? "-server" : "";
    my $jfiles = join(' ', @$fns);
    if (!$opts{raw} && !$opts{standalone} && !$opts{cluster} && !$opts{rstream})
      {
	my $target = change_extension($fns->[0], "java", "c");
	$target = $opts{output} . ".c" if $opts{outputs};
	my $result = call("$java $xmx $server at.dms.kjc.Main --streamit $kjcopts " .
			  "$jfiles > $target");
	return undef if $result != 0;
	return [$target];
      }
    else
      {
	my $result = call("$java $xmx $server at.dms.kjc.Main --streamit $kjcopts $jfiles");
	return undef if $result != 0;
	return ["tile0.c"] if $opts{standalone};
	return ["str.c"] if $opts{rstream};
	return [];
      }
  }

sub new_to_c
  {
    my ($fns) = @_;
    return [] if !@$fns;
    my $kjcopts = get_kjc_opts();
    my $xmx = "-Xmx" . $opts{memory};
    my $server = $opts{server} ? "-server" : "";
    my $sfiles = join(' ', @$fns);
    my $result;
    if (!$opts{raw} && !$opts{cluster})
      {
	my $target = change_extension($fns->[0], "str", "c");
	$target = $opts{output} . ".c" if $opts{outputs};
	$result = call("$java $xmx $server streamit.frontend.ToKopi $kjcopts $sfiles > $target");
	return undef if $result != 0;
	return [$target];
      }
    else
      {
	$result = call("$java $xmx $server at.dms.kjc.Main --streamit $kjcopts $sfiles");
	return undef if $result != 0;
	return [];
      }
  }

sub run_in_library
  {
    my ($fns) = @_;
    return if !@$fns;
    my @out = ();
    my $xmx = "-Xmx" . $opts{memory};
    my $server = $opts{server} ? "-server" : "";
    my $result;
    foreach my $jfile (@$fns)
      {
	  my $class = remove_extension($jfile, "java");
	  $result = call("$javac $jfile");
	  return undef if $result != 0;
	  $result = call("$java $xmx $server $class " . get_lib_opts());
	  return undef if $result != 0;
      }
    return [];
  }

sub c_to_out
  {
    my ($fns, $target) = @_;
    return [] if !@$fns;
    my $tfn = $target || "a.out";
    $target = $target ? "-o$target" : ""; # but never undef
    my $sh = $opts{home};
    my ($gcc, $libs);

    $gcc = "$cc";
    my $ccflags  = "-O2";
    my $incflags = "";
    my $libflags = "";

    if ($opts{rstream}) 
    {
	  $libs .= " -lm";
    }
    else 
    {
	  $incflags = "-L$sh/library/c";
	  $libflags = "-I$sh/library/c";

	  if ($opts{profile}) 
	  {
		$gcc  .= " -pg -a";
		$libs .= " -nodefaultlibs -lstreamit_p";
		$libs .= " -lsrfftw -lssftw" if $have_fftw;
		$libs .= " -lm_p -lc_p -lgcc";
	  }
	  else {
		$libs .= " -lstreamit";
		$libs .= " -lsrfftw -lsfftw" if $have_fftw;
		$libs .= " -lm";
	  }
    }

    my $result = call("$gcc $ccflags $target " . join(' ', @$fns) . " $incflags $libflags $libs");
    return undef if $result != 0;
    return [$tfn];
  }

sub get_kjc_opts
  {
    my $kjcopts = "";
    $opts{raw} && ($kjcopts .= " -raw " . $opts{raw});
    $opts{raw} && $opts{iterations} &&
      ($kjcopts .= " --outputs " . $opts{iterations});
    if (exists $opts{partition})
      {
	$opts{partition} eq 'dp' && ($kjcopts .= " --partition_dp");
	$opts{partition} eq 'greedy' && ($kjcopts .= " --partition_greedy");
	$opts{partition} eq 'greedier' && ($kjcopts .= " --partition_greedier");
      }
    $opts{altcodegen} && ($kjcopts .= " --altcodegen");
    $opts{atlas} && ($kjcopts .= " --atlas");
    $opts{backend} && ($kjcopts .= " --backend " . $opts{backend});
    $opts{'clone-with-serialization'} && ($kjcopts .= " --clone_with_serialization");
    $opts{debug} && ($kjcopts .= " --debug");
    $opts{decoupled} && ($kjcopts .= " --decoupled");
    $opts{dpscaling} && ($kjcopts .= " --dpscaling");
    $opts{forceunroll} && ($kjcopts .= " --forceunroll");
    $opts{frequencyreplacement} && ($kjcopts .= " --frequencyreplacement");
    $opts{fission} && ($kjcopts .= " --fission " . $opts{fission});
    $opts{fusion} && ($kjcopts .= " --fusion");
    $opts{linearanalysis} && ($kjcopts .= " --linearanalysis");
    $opts{linearpartition} && ($kjcopts .= " --linearpartition");
    $opts{linearreplacement} && ($kjcopts .= " --linearreplacement");
    $opts{linearreplacement2} && ($kjcopts .= " --linearreplacement2");
    $opts{linearreplacement3} && ($kjcopts .= " --linearreplacement3");
    $opts{'magic-net'} && ($kjcopts .= " --magic_net");
    $opts{macros} && ($kjcopts .= " --macros ");
    $opts{manual} && ($kjcopts .= " --manual " . $opts{manual});
    $opts{modfusion} && ($kjcopts .= " --modfusion");
    $opts{noanneal} && ($kjcopts .= " --noanneal");
    $opts{nofieldprop} && ($kjcopts .= " --nofieldprop");
    $opts{nolinearcollapse} && ($kjcopts .= " --nolinearcollapse");
    $opts{numbers} && ($kjcopts .= " --numbers " . $opts{numbers});
    $opts{poptopeek} && ($kjcopts .= " --poptopeek");
    $opts{'print-partitioned-source'} && ($kjcopts .= " --print_partitioned_source");
    $opts{ptraccess} && ($kjcopts .= " --ptraccess");
    $opts{ratematch} && ($kjcopts .= " --ratematch");
    $opts{rawcol} && ($kjcopts .= " --rawcol ". $opts{rawcol});
    $opts{standalone} && ($kjcopts .= " --standalone");
    $opts{rstream} && ($kjcopts .= " --rstream");
    $opts{removeglobals} && ($kjcopts .= " --removeglobals");
    $opts{simplesjfusion} && ($kjcopts .= " --simplesjfusion");
    $opts{simulatework} && ($kjcopts .= " --simulatework");
    $opts{sjtopipe} && ($kjcopts .= " --sjtopipe");
    $opts{statespace} && ($kjcopts .= " --statespace");
    $opts{stats} && ($kjcopts .= " --stats");
    $opts{sync} && ($kjcopts .= " --sync");
    defined $opts{unroll} && ($kjcopts .= " --unroll " . $opts{unroll});
    $opts{viram} && ($kjcopts .= " --viram");
    $opts{cluster} && ($kjcopts .= " --cluster " . $opts{cluster});
    $opts{destroyfieldarray} && ($kjcopts .= " --destroyfieldarray");
    $opts{cacheopt} && ($kjcopts .= " --cacheopt");
    $opts{nomult} && ($kjcopts .= " --nomult");
    $opts{rename1} && ($kjcopts .= " --rename1");
    $opts{rename2} && ($kjcopts .= " --rename2");
    $opts{peekratio} && ($kjcopts .= " --peekratio " . $opts{peekratio});
    $opts{wbs} && ($kjcopts .= " --wbs");
    $opts{spacetime} && ($kjcopts .= " --spacetime");
    $opts{spacedynamic} && ($kjcopts .= " --spacedynamic");
    $opts{dynamicnet} && ($kjcopts .= " --dynamicnet");
    $opts{magicdram} && ($kjcopts .= " --magicdram");
    $opts{absarray} && ($kjcopts .= " --absarray");
    $opts{doloops} && ($kjcopts .= " --doloops");
    $opts{forceplacement} && ($kjcopts .= " --forceplacement");
    $opts{malloczeros} && ($kjcopts .= " --malloczeros");
    $opts{nopartition} && ($kjcopts .= " --nopartition");
    $opts{steadymult} && ($kjcopts .= " --steadymult ". $opts{steadymult});
    $opts{scheduler} && ($kjcopts .= " --scheduler ". $opts{scheduler});
    $opts{layoutfile} && ($kjcopts .= " --layoutfile ". $opts{layoutfile});
    $opts{devassignfile} && ($kjcopts .= " --devassignfile ". $opts{devassignfile});
    return $kjcopts;
}

sub get_lib_opts
  {
    my $libopts = '';
    $opts{iterations} && ($libopts .= " -i " . $opts{iterations});
    $opts{nosched} && ($libopts .= " -nosched");
    $opts{norun} && ($libopts .= " -norun");
    $opts{marksteady} && ($libopts .= " -marksteady");
    $opts{printsched} && ($libopts .= " -printsched");
    $opts{printreps} && ($libopts .= " -printreps");
    return $libopts;
  }
