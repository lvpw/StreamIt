#!/usr/bin/perl -w
#
# strc: StreamIt compiler wrapper
# David Maze <dmaze@cag.lcs.mit.edu>
# $Id: strc,v 1.16 2003-10-07 03:19:20 thies Exp $
#

use strict;
use vars qw(%opts $java $javac $cc $have_fftw);
use POSIX qw(:sys_wait_h);

# AUTOCONFISCATE $var = "@VAR@";
$java = "java";
$javac = "javac";
$cc = "gcc";
$have_fftw = "1";
# END AUTOCONFISCATE

use Getopt::Long;
Getopt::Long::Configure("bundling", "no_ignore_case");

get_options() or die "Error parsing options";
if ($opts{'much-more-help'})
  {
    usage(\*STDOUT, 2);
    exit(0);
  }
if ($opts{'more-help'})
  {
    usage(\*STDOUT, 1);
    exit(0);
  }
if ($opts{help})
  {
    usage(\*STDOUT, 0);
    exit(0);
  }
if (!@ARGV)
  {
    print <<EOH;
strc: StreamIt compiler wrapper
Usage: strc [options] file.str ...
Run 'strc --help' for option listing
EOH
    exit(0);
  }
my $fns = \@ARGV;
# Autodetect old-syntax code:
if (!exists $opts{java})
  {
    my $non_java = grep(!/\.java$/, @$fns);
    $opts{java} = !$non_java;
    # which is to say, 1 if there are no non-java files, 0 otherwise
  }
$fns = new_to_old($fns) unless ($opts{java} || $opts{tokopi});
exit(1) if !$fns;
if ($opts{'library'}) {
    run_in_library($fns);
    exit(0);
}
$fns = old_to_c($fns) unless $opts{tokopi};
exit(1) if !$fns;
$fns = new_to_c($fns) if $opts{tokopi};
exit(1) if !$fns;
c_to_out($fns, $opts{output}) unless ($opts{raw} || $opts{cluster});
exit(0);

sub usage
  {
    my ($fh, $more) = @_;
    my $text = <<'EOT';
strc: StreamIt compiler wrapper

Usage: strc [options] file.str ...
	
Options:
  --help              Show this screen
  --more-help         Include extra options
* --much-more-help    Include internal-only options
+ --java              Input file is "old" syntax (in Java)
  --output filename   Write a binary to filename
  --raw n, -r n       Compile for RAW, with an n-by-n grid
  --standalone, -S    Generate C file without library dependencies
* --cluster           Compile for a networked cluster
* --viram, -V         Compile for VIRAM, a vector uniprocessor
  --verbose           Print commands as they are executed
  --library           Run in the Java library instead of compiling
  --memory, -Xmx      Specify Java runtime heap limit

Options available for all backends:
  -O0, -O1, -O2       Use predefined optimization sets
+ --destroyfieldarray Break arrays in structures into component elements
* --clone-with-serialization
*                     Use old serialization code to copy objects
+ --debug             Output debugging information in the compiler
+ --fusion, -f        Fuse entire program to a single filter
+ --fission           Do vertical fission up to limit of argument
  --linearreplacement, -l
                      Perform linear transformations based on analysis
+ --linearreplacement2
+                     Do linear replacement using a level of indirection
+ --linearreplacement3
+                     Do linear replacement using diagonal replacement
+ --nofieldprop       Do not propagate constant field values
+ --nolinearcollapse, -H
+                     Do not combine filters with linear replacement
+ --print-partitioned-source, -c
+                     Print equivalent source after partitioning
+ --redundantreplacement, -t
+                     Create linear filters without redundant computation
* --simplesjfusion    Revert to the old, simple SplitJoin fusion algorithm
+ --sjtopipe, -J      Convert split-joins to pipelines
* --stats             Gather statistics for program characterization
* --tokopi            Use experimental frontend-to-SIR conversion
+ --sync, -k          Turn on sync removal
  --unroll, -u        Specify loop unrolling limit

Options specific to RAW backend:
  --partition, -p     Automatically partition stream graph
+   --partition=dp      Dynamic programming partitioner (default)
+   --partition=greedy  Greedy partitioner
*   --partition=ilp     Integer linear programming partitioner
* --altcodegen, -z    Alternate RAW communication code generation
* --decoupled, -X     Generate dummy communication code
* --dpscaling, -Y     Collect theoretical scaling statistics
  --magic-net, -M     Generate RAW "magic network" code
* --noanneal, -W      Do not run simulated annealing for layout
  --numbers n, -N     Automatically gather numbers and put in results.out
+ --ptraccess, -Q     Access buffers through a pointer
+ --ratematch, -x     Turn on rate matching
  --rawcol, -c        Specify number of columns; --raw has number of rows
+ --removeglobals, -G Inline all functions and turn globals into locals
  --simulatework, -s  Use simulator for work estimation
* --spacetime         Use space-time partitioner
  --wbs               Use work-based simulator for communication code

Options specific to uniprocessor backend:
  --frequencyreplacement, -F
                      Convert FIR filters to frequency
  --linearpartition, -L
                      Automatically selecting targets of linear analyses
* --atlas             Use ATLAS for generated matrix multiplies
+ --poptopeek, -P     Convert all pop expressions into peeks
  --profile           Compile with profiling information

Options specific to Java library backend:
  --iterations, -i    Specify number of iterations to run
  --norun             Schedule but do not run the program
  --nosched           Run the program in pull mode, not under the scheduler
  --marksteady        Print * after each steady-state execution
  --printsched        Dump the program schedule
EOT
    $text =~ s/^\*/ /mg if $more >= 2;
    $text =~ s/^\+/ /mg if $more >= 1;
    $text =~ s/^[*+].*\n//mg;
    print $fh $text;
}

sub get_options
  {
    $opts{home} = $ENV{STREAMIT_HOME};
    $opts{memory} = "1700M";
    my $result = GetOptions(\%opts,
			    "help",
			    "more-help|help-more",
			    "much-more-help|help-much-more",
			    "java!",
			    "output|o=s",
			    "raw|r=i",
			    "verbose|v",
			    "optimize|O=i",
			    "altcodegen|z",
			    "atlas!",
			    "clone-with-serialization|clone_with_serialization",
			    "debug!",
			    "decoupled|X",
			    "dpscaling|Y",
			    "fission|fission=i",
			    "frequencyreplacement|F",
			    "fusion|f",
			    "iterations|i=i",
			    "library!",
			    "linearpartition|L",
			    "linearreplacement|l",
			    "linearreplacement2",
			    "linearreplacement3",
			    "magic-net|magic_net|M",
			    "memory|Xmx=s",
			    "noanneal|W",
			    "nofieldprop",
			    "nolinearcollapse|H",
			    "norun",
			    "nosched",
			    "numbers|N=i",
			    "partition|p:s",
			    "poptopeek|P",
			    "marksteady!",
			    "printsched!",
			    "print-partitioned-source|print_partitioned_source|c",
			    "profile!",
			    "ptraccess|Q",
			    "ratematch|x",
			    "rawcol|c=i",
			    "redundantreplacement|t",
			    "removeglobals|G",
			    "simplesjfusion",
			    "simulatework|s",
			    "sjtopipe|J",
			    "spacetime!",
			    "standalone|S",
			    "stats!",
			    "sync|k",
			    "tokopi!",
			    "unroll|u=i",
			    "viram|V",
			    "wbs!",
			    "cluster!",
			    "destroyfieldarray!");
    return $result if !$result;
    # If the user specified -O#, transform that into appropriate options,
    # but don't override things otherwise on the command line.
    if (exists $opts{optimize})
      {
	if ($opts{optimize} >= 2)
	  {
	    $opts{unroll} = 256 unless exists $opts{unroll};
	    $opts{removeglobals} = 1 unless exists $opts{removeglobals};
	    $opts{simulatework} = 1 unless exists $opts{simulatework};
	  }
	if ($opts{optimize} >= 1)
	  {
	    $opts{unroll} = 16 unless exists $opts{unroll};
	    $opts{ratematch} = 1 unless exists $opts{ratematch};
	    $opts{wbs} = 1 unless exists $opts{wbs};
	    $opts{destroyfieldarray} = 1 unless
	      exists $opts{destroyfieldarray};
	  }
	if ($opts{optimize} >= 0)
	  {
	    $opts{unroll} = 0 unless exists $opts{unroll};
	  }
      }
    # Validate partitioning:
    if (exists $opts{partition})
      {
	$opts{partition} = "dp" if $opts{partition} eq "";
	$opts{partition} = "dp" if $opts{partition} eq "dynamic";
	if (!grep {$opts{partition} eq $_} ('dp', 'greedy', 'ilp'))
	  {
	    print STDERR "Unsupported --partition option $opts{partition};" .
	      " run strc --more-help for valid options";
	    return 0;
	  }
      }
    return 1;
  }

sub call
  {
    my ($cmd) = @_;
    print "$cmd\n" if $opts{verbose};
    my $result = system($cmd);
    if ($opts{verbose} && $result != 0)
      {
	if (WIFSIGNALED($?))
	  {
	    print "(exited with signal " . WTERMSIG($?) . ")\n";
	  }
	else
	  {
	    print "(exited with value " . WEXITSTATUS($?) . ")\n";
	  }
      }
    return $result;
  }

sub change_extension
  {
    my ($old, $from, $to) = @_;
    my $fn = $old;
    $fn =~ s/.$from$//;
    $fn .= ".$to";
    return $fn;
  }

sub remove_extension
  {
    my ($old, $from) = @_;
    my $fn = $old;
    $fn =~ s/.$from$//;
    return $fn;
  }

sub new_to_old
  {
    my ($fns) = @_;
    return [] if !@$fns;
    my $target = change_extension($fns->[0], "str", "java");
    my $libflag = "";
    $libflag = "--library" if $opts{library};
    my $result = call("$java streamit.frontend.ToJava --output $target " .
		      "$libflag " . join(' ', @$fns));
    return undef if $result != 0;
    return [$target];
  }

sub old_to_c
  {
    my ($fns) = @_;
    return [] if !@$fns;
    my $kjcopts = get_kjc_opts();
    my $xmx = "-Xmx" . $opts{memory};
    my $jfiles = join(' ', @$fns);
    if (!$opts{raw} && !$opts{standalone} && !$opts{cluster})
      {
	my $target = change_extension($fns->[0], "java", "c");
	$target = $opts{output} . ".c" if $opts{outputs};
	my $result = call("$java $xmx at.dms.kjc.Main -s $kjcopts " .
			  "$jfiles > $target");
	return undef if $result != 0;
	return [$target];
      }
    else
      {
	my $result = call("$java $xmx at.dms.kjc.Main -s $kjcopts $jfiles");
	return undef if $result != 0;
	return ["tile0.c"] if $opts{standalone};
	return [];
      }
  }

sub new_to_c
  {
    my ($fns) = @_;
    return [] if !@$fns;
    my $kjcopts = get_kjc_opts();
    my $xmx = "-Xmx" . $opts{memory};
    my $sfiles = join(' ', @$fns);
    if (!$opts{raw} && !$opts{cluster})
      {
	my $target = change_extension($fns->[0], "str", "c");
	$target = $opts{output} . ".c" if $opts{outputs};
	call("$java $xmx streamit.frontend.ToKopi $kjcopts $sfiles > $target");
	return [$target];
      }
    else
      {
	call("$java $xmx at.dms.kjc.Main -s $kjcopts $sfiles");
	return [];
      }
  }

sub run_in_library
  {
    my ($fns) = @_;
    return if !@$fns;
    my @out = ();
    my $xmx = "-Xmx" . $opts{memory};
    foreach my $jfile (@$fns)
      {
	  my $class = remove_extension($jfile, "java");
	  call("$javac $jfile");
	  call("$java $xmx $class " . get_lib_opts());
      }
  }

sub c_to_out
  {
    my ($fns, $target) = @_;
    return [] if !@$fns;
    $target = $target ? "-o$target" : ""; # but never undef
    my $sh = $opts{home};
    my ($gcc, $libs);
    if ($opts{profile})
      {
	$gcc = "$cc -pg -a";
	$libs = "-nodefaultlibs -lstreamit_p ";
	$libs .= "-lsrfftw -lssftw " if $have_fftw;
	$libs .= "-lm_p -lc_p -lgcc";
      }
    else
      {
	$gcc = "$cc";
	$libs = "-lstreamit ";
	$libs .= "-lsrfftw -lsfftw " if $have_fftw;
	$libs .= "-lm";
      }
    call("$gcc -g -O2 $target -I$sh/library/c " . join(' ', @$fns) .
	 " -L$sh/library/c $libs");
  }

sub get_kjc_opts
  {
    my $kjcopts = "";
    $opts{raw} && ($kjcopts .= " -raw " . $opts{raw});
    (exists $opts{partition}) && $opts{partition} eq 'dp' && ($kjcopts .= " -y");
    (exists $opts{partition}) && $opts{partition} eq 'greedy' && ($kjcopts .= " -a");
    (exists $opts{partition}) && $opts{partition} eq 'ilp' && ($kjcopts .= " -A");
    $opts{altcodegen} && ($kjcopts .= " -z");
    $opts{atlas} && ($kjcopts .= " -E");
    $opts{'clone-with-serialization'} && ($kjcopts .= " -K");
    $opts{debug} && ($kjcopts .= " --debug");
    $opts{decoupled} && ($kjcopts .= " -X");
    $opts{dpscaling} && ($kjcopts .= " -Y");
    $opts{frequencyreplacement} && ($kjcopts .= " -F");
    $opts{fission} && ($kjcopts .= " --fission " . $opts{fission});
    $opts{fusion} && ($kjcopts .= " -o");
    $opts{linearpartition} && ($kjcopts .= " -B");
    $opts{linearreplacement} && ($kjcopts .= " -I");
    $opts{linearreplacement2} && ($kjcopts .= " -Z");
    $opts{linearreplacement3} && ($kjcopts .= " -R");
    $opts{'magic-net'} && ($kjcopts .= " -M");
    $opts{noanneal} && ($kjcopts .= " -W");
    $opts{nofieldprop} && ($kjcopts .= " -L");
    $opts{nolinearcollapse} && ($kjcopts .= " -H");
    $opts{numbers} && ($kjcopts .= " -N" . $opts{numbers});
    $opts{poptopeek} && ($kjcopts .= " -P");
    $opts{'print-partitioned-source'} && ($kjcopts .= " -c");
    $opts{ptraccess} && ($kjcopts .= " -Q");
    $opts{ratematch} && ($kjcopts .= " -x");
    $opts{rawcol} && ($kjcopts .= " -q ". $opts{rawcol});
    $opts{standalone} && ($kjcopts .= " -U");
    $opts{removeglobals} && ($kjcopts .= " -G");
    $opts{simplesjfusion} && ($kjcopts .= " -S");
    $opts{simulatework} && ($kjcopts .= " -T");
    $opts{sjtopipe} && ($kjcopts .= " -J");
    $opts{stats} && ($kjcopts .= " -.");
    $opts{sync} && ($kjcopts .= " -k");
    defined $opts{unroll} && ($kjcopts .= " -u " . $opts{unroll});
    $opts{viram} && ($kjcopts .= " -V");
    $opts{cluster} && ($kjcopts .= " -cluster");
    $opts{destroyfieldarray} && ($kjcopts .= " -destroyfieldarray");
    $opts{wbs} && ($kjcopts .= " -wbs");
    $opts{spacetime} && ($kjcopts .= " -spacetime");
    return $kjcopts;
}

sub get_lib_opts
  {
    my $libopts = '';
    $opts{iterations} && ($libopts .= " -i " . $opts{iterations});
    $opts{nosched} && ($libopts .= " -nosched");
    $opts{norun} && ($libopts .= " -norun");
    $opts{marksteady} && ($libopts .= " -marksteady");
    $opts{printsched} && ($libopts .= " -printsched");
    return $libopts;
  }
