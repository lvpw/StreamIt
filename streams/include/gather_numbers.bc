//Number gathering bc code
//global gMagicInstrHMS;
global lastCycle;

//the blood graph variables
global gPPMFILE;
global gRedP;
global gGreenP;
global gBlueP;
global gBloodCycles;
global gTraceWidth = 7 + (64 / gNumProc);

global gSteadyState = 0;
//record the total number of prints for each steady 
//state, not just for the sink we are interested in
global gSteadyStatePrints = 0;

global lastSteadyStartCycle = 0;
//the numbers of prints for the current steady state
//for the sink we are monitoring
global currentPrints = 0;
global steadyStateExecutions = 0;
global outputFile;
global currentSkipped = 0;
global gWorkCount = 0;
global gWorkCountTotal = 0;
global gFpuCount = 0;
global gMemCount = 0;
global gBrCount = 0;
global gAdminCount = 0;
global gAluCount = 0;

global gFpuCountTotal = 0;
global gMemCountTotal = 0;
global gBrCountTotal = 0;
global gAdminCountTotal = 0;
global gAluCountTotal = 0;
global totalCycles = 0;
global gNumberDone = 0;

fn gather_numbers_calc(procNum, rs, imm, result_ptr)
{
  local sender_x;
  local sender_y;
  local time_hi, time_lo;
  local proc = Machine_GetProc(machine, procNum);

  //get the cycle
  Proc_GetCycleCounter(proc, &time_hi, &time_lo);

  //calculate the x, y coordinates...
  sender_y = procNum / gXSize;
  sender_x = procNum - (sender_y * gXSize);

  if (!((rs == 0) && (imm == 2)))
    return 0;

  //record the total number of steady state prints the 
  //current cycle
  if (gSteadyState == 1) 
    gSteadyStatePrints++;
	  
  //that this print was issued at the sink we are interested in.
  //check that the number gathering is not done and
  if (gNumberDone != 1 && 
      gSinkX == sender_x &&
      gSinkY == sender_y) {
    currentPrints++;
    //skip anything printed in the init
    if (currentSkipped < skipPrints) {
      currentSkipped++;
      currentPrints = 0;
    }
    else if (currentPrints == printsPerSteady) {
      //hit the end of a steady
      //reset the number of prints we have seen in this
      //steady state
      currentPrints = 0;
      steadyStateExecutions ++;
	    
      //quit after quitAfter executions
      if (steadyStateExecutions == quitAfter + 2) {
	printf("Generating results.out\n");
	//we are done number gathering
	gNumberDone = 1;
	fprintf(outputFile, "\nSummmary:\n");
	fprintf(outputFile, "Steady State Executions: %d\n", quitAfter);
	fprintf(outputFile, "Total Cycles: %d\n", totalCycles);
	fprintf(outputFile, "Total Steady State Outputs: %d\n", gSteadyStatePrints);
	fprintf(outputFile, "Avg Cycles per Steady-State: %d\n", totalCycles/quitAfter);
	fprintf(outputFile, "Thruput per 10^5: %d\n", 
		(100000) / (totalCycles/gSteadyStatePrints));
	fprintf(outputFile, "Total Non-Blocked Cycles: %d\n\n", 
		(gWorkCountTotal));
	// The following should no longer be necessary
	// - ((gNumProc - gStreamItTilesUsed) * totalCycles)));
	 
	//we need to account for the unused tiles, should show up as jump instructions
	fprintf(outputFile, "Instruction Mix:\n");
	fprintf(outputFile, "FPU: %d\n", gFpuCountTotal);
	fprintf(outputFile, "MEM: %d\n", gMemCountTotal);
	fprintf(outputFile, "BRANCH: %d\n", gBrCountTotal); 
	// the following should no longer be necessary
	//   ((gNumProc - gStreamItTilesUsed) * totalCycles));
	fprintf(outputFile, "ADMIN: %d\n", gAdminCountTotal);
	fprintf(outputFile, "ALU: %d\n\n", gAluCountTotal);
	      
	//printf("gWorkCountTotal: %d\n", gWorkCountTotal);
	//printf("((gNumProc - gStreamItTilesUsed) * totalCycles): %d\n", 
	//	     ((gNumProc - gStreamItTilesUsed) * totalCycles));

	fprintf(outputFile, "workCount* = %d / %d\n", 
		gWorkCountTotal,
		//- ((gNumProc - gStreamItTilesUsed) * totalCycles)),
		gStreamItTiles*totalCycles);
	fprintf(outputFile, "Avg MFLOPS: %d\n", (250*gFpuCountTotal)/totalCycles);	   
	fprintf(outputFile, "* Note: the numerator is the total non-blocked cycles\n");
	fprintf(outputFile, "  for *assigned* tiles in the configuration.\n");
	fprintf(outputFile, "  The denominator is the total number of cycles\n");
	fprintf(outputFile, "  for all the tiles in the streamit configuration.\n");
	      
	//print the numbers in a nicer format for automatic
	//extracting
	fprintf(outputFile,
		"\n# format: tiles in config:tiles assigned:cycles/steady:thruput:MFLOPS:");
	fprintf(outputFile, 
		"instr issued:fpu:mem:branch:admin:alu:max instr issued:\n");
	fprintf(outputFile, "%d;%d;%d;%d;%d;%d;%d;%d;%d;%d;%d;%d\n",
		gStreamItTiles, gStreamItTilesUsed, totalCycles/quitAfter,
		((100000) / (totalCycles/gSteadyStatePrints)),
		(250*gFpuCountTotal)/totalCycles,
		gWorkCountTotal, // - ((gNumProc - gStreamItTilesUsed) * totalCycles)),
		gFpuCountTotal, gMemCountTotal, 
		gBrCountTotal, //- ((gNumProc - gStreamItTilesUsed) * totalCycles),
		gAdminCountTotal, gAluCountTotal, 
		gStreamItTiles*totalCycles);
	//we are done getting the numbers, deregister the handler.
	EventManager_DeRegisterHandler("issued_instruction", "__event_instr_count");
	//now get the blood graph	   
	setup_bloodgraph("bloodgraph.ppm", totalCycles/quitAfter);
	//this should exit!!!!!
	//gInterrupted = 1;
	//this will exit the thread
	//exit_now(0);
      }
      else if (steadyStateExecutions > 1) {
	local dif = time_lo - lastSteadyStartCycle; 
	      
	//from now on, we are in the steady state
	gSteadyState = 1;


	totalCycles += dif;
	if (totalCycles < 0) {
	  printf("\n** Total Cycles Overflow **\n\n");
	}
	gWorkCountTotal += gWorkCount;
	if (gWorkCountTotal < 0) {
	  printf("\n** Total Work Count Overflow **\n\n");
	}
	gFpuCountTotal += gFpuCount;
	gMemCountTotal += gMemCount;
	gBrCountTotal += gBrCount;
	gAdminCountTotal += gAdminCount;
	gAluCountTotal += gAluCount;
	
	printf("Cycles: %d,  MFLOPS: %d\n", dif, (250*gFpuCount)/dif);
	fprintf(outputFile, "%d %d %d\n", dif, (250*gFpuCount)/dif, gWorkCount);
      }	  
      //set the last steady state time
      lastSteadyStartCycle = time_lo;
      //reset the flops count and workCount
      gFpuCount = 0;
      gMemCount = 0;
      gBrCount = 0;
      gAdminCount = 0;
      gAluCount = 0;
      gWorkCount = 0;
    }
  }
  return 1;
}

fn gather_numbers_init()
{
  //register the magic instruction
  listi_add(gMagicInstrHMS.theList, & fn (procNum, rs, imm, result_ptr)
  {
    return gather_numbers_calc(procNum, rs, imm, result_ptr);
  });
  
  //open the file to dump the data to
  outputFile = fopen("results.out", "w");
 
  //print some shit
  fprintf(outputFile, "Performance Results\n\n");
  fprintf(outputFile, "Tiles in configuration: %d\n", gStreamItTiles);
  fprintf(outputFile, "Tiles assigned (to filters or joiners): %d\n", gStreamItTilesUsed);
  fprintf(outputFile, "Run for %d steady state cycles.\n", quitAfter);
  fprintf(outputFile, "With %d items skipped for init.\n", skipPrints);
  fprintf(outputFile, "With %d items printed per steady state.\n\n", printsPerSteady);
  fprintf(outputFile, "cycles MFLOPS work_count\n");
  fprintf(outputFile, "--------------------------\n");

  //register the workcount event
  EventManager_RegisterHandler("issued_instruction", "__event_instr_count");

  return 1;
}

fn close_bloodgraph() {
  free(gRedP); free(gGreenP); free(gBlueP);

  close_ppm(gPPMFILE);
  //this should exit!!!!!
  gInterrupted = 1;
  //this will exit the thread
  exit_now(0);
}

fn update_bloodgraph(hms) {
  local j;
  local value;
  
  //stop updating the blood graph
  if (gBloodCycles <= 0) {
    close_bloodgraph();
  }
    
  for (j = 0; j < gNumProc; ++j)
    {
      local k;
      local popcount;
      local delta;
      local curPos = 0;
      local status = Proc_GetStallReason(Machine_GetProc(machine,j));
      popcount = ((status & 1)
		  + ((status >> 1) & 1)
		  + ((status >> 2) & 1)
		  + ((status >> 3) & 1)
		  + ((status >> 4) & 1)
		  + ((status >> 5) & 1)
		  + ((status >> 6) & 1));
      delta = (popcount << 16)/gTraceWidth;
      
      for (k = 0; k < gTraceWidth-1; k++)
      {
	value = get_proc_state_color(j, status,gRedP,gGreenP,gBlueP,curPos>>16);
	write_ppm(gPPMFILE, *gRedP, *gGreenP, *gBlueP);
	curPos += delta;
      }
      write_ppm(gPPMFILE,0,0,0);
    }
  gBloodCycles--;
}


fn setup_bloodgraph(filename, cycles) {
  gPPMFILE = open_ppm(filename, cycles, gNumProc*gTraceWidth);
  if (gPPMFILE == NULL)
  {
    printf("Error opening %s\n",filename);
    return 0;
  }
  gRedP = malloc(4);
  gGreenP = malloc(4);
  gBlueP = malloc(4);

  gBloodCycles = cycles;
  EventManager_RegisterHandler("clock", "update_bloodgraph"); 
}

fn __event_instr_count(hms)
{
  local instrWord = hms.instrWord;
  local lWorkCount = gWorkCount;
  local tileNumber = hms.y * gXSize + hms.x;

  //the definition of mapped_tile(int) is in 
  // the fileio.bc generated by the compiler
  //make sure this tile is mapped before we count it as work
  if (mapped_tile(tileNumber) == 0) {
    return;
  }
  
  AtomicIncrement(&gWorkCount);

  if (InstrWord_IsFPU(instrWord))
  {
    AtomicIncrement(&gFpuCount);
  }

  else if (InstrWord_IsCacheMissOp(instrWord))
  {
    AtomicIncrement(&gMemCount);
  }

  else if (InstrWord_CanMispredict(instrWord) ||
	   InstrWord_IsDirectJump(instrWord))
  {
    AtomicIncrement(&gBrCount);
  }

  else if (InstrWord_IsAdmin(instrWord))
  {
    AtomicIncrement(&gAdminCount);
  }

  else
  {
    AtomicIncrement(&gAluCount);
  }
}
