/* to_file
 *
 * streams values from a static network port to a file.
 * makes use of the data_transmitter generic device.
 *
 * Michael Gordon
 */

//for number gathering
global gNGlastSteady = 0;
global gNGisSteady = 0;
//for deadlock detection
global gDEADLOCK_COUNT = 2000;
global gLastInsCycle = 0;
//
global gFpuCount = 0;
global gMemCount = 0;
global gBrCount = 0;
global gAdminCount = 0;
global gAluCount = 0;

if (FindFunctionInSymbolHash(gSymbolTable, "dev_data_transmitter_init",3) == NULL)
  include("<dev/data_transmitter.bc>");


//type: 0 = int, 1 = float, can be extended
fn dev_NG_to_file(id, filename, port, type)
{
  local receive_device_descriptor = hms_new();

  // open the file
  receive_device_descriptor.fileName = filename;
  receive_device_descriptor.theFile = fopen(receive_device_descriptor.fileName,
                                            "w");
  receive_device_descriptor.format = "";
  receive_device_descriptor.ioPort = port;
  receive_device_descriptor.type = type;
  receive_device_descriptor.id = id;
  
  if (type == 0)
    receive_device_descriptor.format = "%d\n";
  else if (type == 1)
    receive_device_descriptor.format = "%f\n";
  else {
    printf("Invalid format arg passed to dev_to_file\n");
    exit(-1);
  }
    

  verify(receive_device_descriptor.theFile != NULL,
         "### Failed to open output file\n");


  receive_device_descriptor.calc =
    & fn(this)
  {
    local theFile = this.theFile;
    local format = this.format;
    local filename = this.fileName;
    local ioPort = this.ioPort;
    local type = this.type;
    
    while (1)
    {
      local time_lo, time_hi;
      local proc = Machine_GetProc(machine, 0);
      local value = this.receive();
      
      //get the cycle
      Proc_GetCycleCounter(proc, &time_hi, &time_lo);
      //update the numbers gathering stuff
      NG_numbers_record_item(id);
      if (type == 0) {
	//write to file
	fprintf(theFile,format,value);
	fflush(theFile);
	//write to screen
	printf("%s [%d]: ", filename, time_lo);
	printf(format, value);
	printf("\n");
      }
      else if (type == 1) {
	//write to file
	fprintf(theFile,format,double(value));
	fflush(theFile);
	//write to screen
	printf("%s [%d]: ", filename, time_lo);
	printf(format, double(value));
	printf("\n");
      }
      else {
	printf("Invalid format arg passed to dev_NG_to_file\n");
	exit(-1);
      }
    }
  };

  return dev_data_transmitter_init("NG_to_file",
				   port,
				   0, //don't wait for static trigger 
				   receive_device_descriptor);
}

//need to define 
//items to skip for each filewriter
//items in the steady state for each file writer
//total items received into each fw
//is steady = 0
//total number of fw

fn NG_numbers_record_item(id) 
{
  //update the total number of item received into fw
  gNGItems[id] += 1;
  //see if we have executed a steady-state
  NG_update();
}

fn NG_update() {
  local i, time_hi, time_lo;
  local proc = Machine_GetProc(machine, 0);
  local dif, MFLOPS;

  if (gNGisSteady == 0) {
    for (i = 0; i < gNGfws; i++) {
      //make sure everyone is done the init/pp stage
      if (gNGItems[i] < gNGskip[i]) {
	return;
      } 
    }
    //if we get here everyone is done with init/pp
    //subtract the number to skip from init/pp from
    //everyone's items
    for (i = 0; i < gNGfws; i++) {
      gNGItems[i] -= gNGskip[i];
    }
    //we are now in the steady state
    gNGisSteady = 1;
  } 
  
  if (gNGisSteady == 1) {
    //in steady-state, check to see if
    //have executed a full steady state
    for (i = 0; i < gNGfws; i++) {
      if (gNGItems[i] < gNGsteady[i]) {
	//someone is still in the init/pp stage
	return;
      }
    }
    
    //if we get here we have executed a full steady state
    //first subtract from everyone's items
    for (i = 0; i < gNGfws; i++) {
      gNGItems[i] -= gNGsteady[i];
    } 

    //get the cycle
    Proc_GetCycleCounter(proc, &time_hi, &time_lo);
    

    
    //next print what we want to print 
    dif = time_lo - gNGlastSteady;
    //MFLOPS = 0;
    if (dif == 0) {
      printf("\n** Error: SS cycle difference is zero\n");
      //this should exit!!!!!
      gInterrupted = 1;
      //this will exit the thread
      exit_now(0);
    }
    MFLOPS = (gMHz * gFpuCount) / dif; 
    printf("SS: cycle = %d, dif = %d, MFLOPS = %d\n", 
	   time_lo, dif, MFLOPS);
    //reset the last steady state
    gNGlastSteady = time_lo;
    //reset the mflops counter
    gFpuCount = 0;
  }
}

fn install_event_handlers() {
  //install any devices that need to be installed
  //register the workcount event
  EventManager_RegisterHandler("issued_instruction", "__event_instr_count");
  EventManager_RegisterHandler("clock", "__check_deadlock");
}

fn __check_deadlock(hms) {
  local time_hi, time_lo;
  local proc = Machine_GetProc(machine, 0);
  //get the cycle
  Proc_GetCycleCounter(proc, &time_hi, &time_lo);

  if (time_lo > gLastInsCycle + gDEADLOCK_COUNT) {
    printf("\n\n ***** DEADLOCK! ***** \n\n");
    //this should exit!!!!!
    gInterrupted = 1;
    //this will exit the thread
    exit_now(0);
  }
}

fn __event_instr_count(hms)
{
  local instrDynamic = hms.instr_dynamic;
  local instrWord = InstrDynamic_GetInstrWord(instrDynamic);
//  local lWorkCount = gWorkCount;
  local tileNumber = Proc_GetTileNumber(hms.theProc);
  local time_hi, time_lo;
  
  //get the cycle
  Proc_GetCycleCounter(hms.theProc, &time_hi, &time_lo);
  
  //the definition of mapped_tile(int) is in 
  // the fileio.bc generated by the compiler
  //make sure this tile is mapped before we count it as work
  if (mapped_tile(tileNumber) == 0) {
    return;
  }

  //reset the last useful cycle
  gLastInsCycle = time_lo;
  
//  AtomicIncrement(&gWorkCount);

  if (InstrWord_IsFPU(instrWord))
  {
    AtomicIncrement(&gFpuCount);
  }

  else if (InstrWord_IsCacheMissOp(instrWord))
  {
    AtomicIncrement(&gMemCount);
  }

  else if (InstrWord_CanMispredict(instrWord) ||
	   InstrWord_IsDirectJump(instrWord))
  {
    AtomicIncrement(&gBrCount);
  }

  else if (InstrWord_IsAdmin(instrWord))
  {
    AtomicIncrement(&gAdminCount);
  }

  else
  {
    AtomicIncrement(&gAluCount);
  }
  

}
