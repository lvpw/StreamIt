#!/usr/bin/perl -w
#
# knit: StreamIt compiler wrapper
# David Maze <dmaze@cag.lcs.mit.edu>
# $Id: knit,v 1.46 2003-09-25 20:10:51 dmaze Exp $
#

use strict;
use vars qw(%opts $java $javac $cc $have_fftw);

# AUTOCONFISCATE $var = "@VAR@";
$java = "java";
$javac = "javac";
$cc = "gcc";
$have_fftw = "1";
# END AUTOCONFISCATE

use Getopt::Long;
Getopt::Long::Configure("bundling", "no_ignore_case");

get_options() or die "Error parsing options";
if ($opts{'more-help'})
  {
    usage(\*STDOUT, 1);
    exit(0);
  }
if ($opts{help})
  {
    usage(\*STDOUT, 0);
    exit(0);
  }
if (!@ARGV)
  {
    print <<EOH;
knit: StreamIt compiler wrapper
Usage: knit [options] file.str ...
Run 'knit --help' for option listing
EOH
    exit(0);
  }
my $fns = \@ARGV;
# Autodetect old-syntax code:
if (!exists $opts{java})
  {
    my $non_java = grep(!/\.java$/, @$fns);
    $opts{java} = !$non_java;
    # which is to say, 1 if there are no non-java files, 0 otherwise
  }
$fns = new_to_old($fns) unless ($opts{java} || $opts{tokopi});
if ($opts{'library'}) {
    run_in_library($fns);
    exit(0);
}
$fns = old_to_c($fns) unless $opts{tokopi};
$fns = new_to_c($fns) if $opts{tokopi};
c_to_out($fns, $opts{output}) unless ($opts{raw} || $opts{cluster});
exit(0);

sub usage
  {
    my ($fh, $more) = @_;
    my $text = <<'EOT';
knit: StreamIt compiler wrapper

Usage: knit [options] file.str ...
	
Options:
  --help              Show this screen
* --more-help         Include internal-only options
  --java              Input file is "old" syntax (in Java)
  --output filename   Write a binary to filename
  --raw n             Compile for RAW, with an n-by-n grid
  --cluster           Compile for a networked cluster
* --viram, -V         Compile for VIRAM, a vector uniprocessor
  --verbose           Print commands as they are executed
  --library           Run in the Java library instead of compiling
  --memory, -Xmx      Specify Java runtime heap limit

Options available for all backends:
  -O0, -O1, -O2       Use predefined optimization sets
  --destroyfieldarray Break arrays in structures into component elements
* --clone-with-serialization, -K
*                     Use old serialization code to copy objects
* --fusion, -f        Fuse entire program to a single filter
* --fission           Do vertical fission up to limit of argument
  --linearreplacement, -I
                      Perform linear transformations based on analysis
* --linearreplacement2, -Z
*                     Do linear replacement using a level of indirection
* --linearreplacement3, -R
*                     Do linear replacement using diagonal replacement
  --nofieldprop, -L   Do not propagate constant field values
  --nolinearcollapse, -H
                      Do not combine filters with linear replacement
* --print-partitioned-source, -c
*                     Print equivalent source after partitioning
* --redundantreplacement, -t
*                     Create linear filters without redundant computation
* --simplesjfusion    Revert to the old, simple SplitJoin fusion algorithm
  --sjtopipe, -J      Convert split-joins to pipelines
* --stats             Gather statistics for program characterization
* --tokopi            Use experimental frontend-to-SIR conversion
  --sync, -k          Turn on sync removal
  --unroll, -u        Specify loop unrolling limit

Options specific to RAW backend:
  --partition, -a     Automatically partition stream graph (greedy)
  --dppartition, -y   Use the dynamic programming partitioner
  --altcodegen, -z    Alternate RAW communication code generation
* --decoupled, -X     Generate dummy communication code
* --dpscaling, -Y     Collect theoretical scaling statistics
* --ilppartition, -A  Use the integer linear programming partitioner
  --magic-net, -M     Generate RAW "magic network" code
* --noanneal, -W      Do not run simulated annealing for layout
  --numbers n, -N     Automatically gather numbers and put in results.out
* --ptraccess, -Q     Access buffers through a pointer
* --ratematch, -x     Turn on rate matching
  --rawcol, -q        Specify number of columns; --raw has number of rows
  --raw-uni, -U       Use RAW backend to generate uniprocessor code
* --removeglobals, -G Inline all functions and turn globals into locals
  --simulatework, -T  Use simulator for work estimation
* --spacetime         Use space-time partitioner
  --wbs               Use work-based simulator for communication code

Options specific to uniprocessor backend:
  --frequencyreplacement, -F
                      Convert FIR filters to frequency
  --linearpartition, -B
                      Automatically selecting targets of linear analyses
* --atlas, -E         Use ATLAS for generated matrix multiplies
  --poptopeek, -P     Convert all pop expressions into peeks
  --profile           Compile with profiling information

Options specific to Java library backend:
  --iterations, -i    Specify number of iterations to run
  --norun             Schedule but do not run the program
  --nosched           Run the program in pull mode, not under the scheduler
  --printdot          Print . at each steady-state execution
  --printsched        Dump the program schedule
EOT
    if ($more) {
      $text =~ s/^\*/ /mg;
    } else {
      $text =~ s/^\*.*\n//mg;
    }
    print $fh $text;
}

sub get_options
  {
    $opts{home} = $ENV{STREAMIT_HOME};
    $opts{memory} = "1700M";
    my $result = GetOptions(\%opts,
			    "help",
			    "more-help|help-more",
			    "java!",
			    "output|o=s",
			    "raw|r=i",
			    "verbose|v",
			    "optimize|O=i",
			    "altcodegen|z",
			    "atlas|E",
			    "clone-with-serialization|clone_with_serialization|K",
			    "decoupled|X",
			    "dppartition|y",
			    "dpscaling|Y",
			    "fission|fission=i",
			    "frequencyreplacement|F",
			    "fusion|f",
			    "ilppartition|A",
			    "iterations|i=i",
			    "library!",
			    "linearpartition|B",
			    "linearreplacement|I",
			    "linearreplacement2|Z",
			    "linearreplacement3|R",
			    "magic-net|magic_net|M",
			    "memory|Xmx=s",
			    "noanneal|W",
			    "nofieldprop|L",
			    "nolinearcollapse|H",
			    "norun!",
			    "nosched!",
			    "numbers|N=i",
			    "partition|a",
			    "poptopeek|P",
			    "printdot!",
			    "printsched!",
			    "print-partitioned-source|print_partitioned_source|c",
			    "profile!",
			    "ptraccess|Q",
			    "ratematch|x",
			    "rawcol|q=i",
			    "raw-uni|raw_uni|U",
			    "redundantreplacement|t",
			    "removeglobals|G",
			    "simplesjfusion|S",
			    "simulatework|T",
			    "sjtopipe|J",
			    "spacetime!",
			    "stats!",
			    "sync|k",
			    "tokopi!",
			    "unroll|u=i",
			    "viram|V",
			    "wbs!",
			    "cluster!",
			    "destroyfieldarray!");
    return $result if !$result;
    # If the user specified -O#, transform that into appropriate options,
    # but don't override things otherwise on the command line.
    if (exists $opts{optimize})
      {
	if ($opts{optimize} >= 2)
	  {
	    $opts{unroll} = 4096 unless exists $opts{unroll};
	    $opts{removeglobals} = 1 unless exists $opts{removeglobals};
	    $opts{simulatework} = 1 unless exists $opts{simulatework};
	  }
	if ($opts{optimize} >= 1)
	  {
	    $opts{unroll} = 256 unless exists $opts{unroll};
	    $opts{altcodegen} = 1 unless exists $opts{altcodegen};
	    $opts{ratematch} = 1 unless exists $opts{ratematch};
	    $opts{wbs} = 1 unless exists $opts{wbs};
	    $opts{destroyfieldarray} = 1 unless
	      exists $opts{destroyfieldarray};
	  }
      }
    return 1;
  }

sub call
  {
    my ($cmd) = @_;
    print "$cmd\n" if $opts{verbose};
    return system($cmd);
  }

sub change_extension
  {
    my ($old, $from, $to) = @_;
    my $fn = $old;
    $fn =~ s/.$from$//;
    $fn .= ".$to";
    return $fn;
  }

sub remove_extension
  {
    my ($old, $from) = @_;
    my $fn = $old;
    $fn =~ s/.$from$//;
    return $fn;
  }

sub new_to_old
  {
    my ($fns) = @_;
    return [] if !@$fns;
    my $target = change_extension($fns->[0], "str", "java");
    $target = $opts{output} . ".java" if $opts{output};
    my $libflag = "";
    $libflag = "--library" if $opts{library};
    call("$java streamit.frontend.ToJava --output $target $libflag " .
	 join(' ', @$fns));
    return [$target];
  }

sub old_to_c
  {
    my ($fns) = @_;
    return [] if !@$fns;
    my $kjcopts = get_kjc_opts();
    my $xmx = "-Xmx" . $opts{memory};
    my $jfiles = join(' ', @$fns);
    if (!$opts{raw} && !$opts{cluster})
      {
	my $target = change_extension($fns->[0], "java", "c");
	$target = $opts{output} . ".c" if $opts{outputs};
	call("$java $xmx at.dms.kjc.Main -s $kjcopts $jfiles > $target");
	return [$target];
      }
    else
      {
	call("$java $xmx at.dms.kjc.Main -s $kjcopts $jfiles");
	return [];
      }
  }

sub new_to_c
  {
    my ($fns) = @_;
    return [] if !@$fns;
    my $kjcopts = get_kjc_opts();
    my $xmx = "-Xmx" . $opts{memory};
    my $sfiles = join(' ', @$fns);
    if (!$opts{raw} && !$opts{cluster})
      {
	my $target = change_extension($fns->[0], "str", "c");
	$target = $opts{output} . ".c" if $opts{outputs};
	call("$java $xmx streamit.frontend.ToKopi $kjcopts $sfiles > $target");
	return [$target];
      }
    else
      {
	call("$java $xmx at.dms.kjc.Main -s $kjcopts $sfiles");
	return [];
      }
  }

sub run_in_library
  {
    my ($fns) = @_;
    my @out = ();
    my $xmx = "-Xmx" . $opts{memory};
    foreach my $jfile (@$fns)
      {
	  my $class = remove_extension($jfile, "java");
	  call("$javac $jfile");
	  call("$java $xmx $class " . get_lib_opts());
      }
  }

sub c_to_out
  {
    my ($fns, $target) = @_;
    $target = $target ? "-o$target" : ""; # but never undef
    my $sh = $opts{home};
    my ($gcc, $libs);
    if ($opts{profile})
      {
	$gcc = "$cc -pg -a";
	$libs = "-nodefaultlibs -lstreamit_p ";
	$libs .= "-lsrfftw -lssftw " if $have_fftw;
	$libs .= "-lm_p -lc_p -lgcc";
      }
    else
      {
	$gcc = "$cc";
	$libs = "-lstreamit ";
	$libs .= "-lsrfftw -lsfftw " if $have_fftw;
	$libs .= "-lm";
      }
    call("$gcc -g -O2 $target -I$sh/library/c " . join(' ', @$fns) .
	 " -L$sh/library/c $libs");
  }

sub get_kjc_opts
  {
    my $kjcopts = "";
    $opts{raw} && ($kjcopts .= " -raw " . $opts{raw});
    $opts{altcodegen} && ($kjcopts .= " -z");
    $opts{atlas} && ($kjcopts .= " -E");
    $opts{'clone-with-serialization'} && ($kjcopts .= " -K");
    $opts{decoupled} && ($kjcopts .= " -X");
    $opts{dppartition} && ($kjcopts .= " -y");
    $opts{dpscaling} && ($kjcopts .= " -Y");
    $opts{frequencyreplacement} && ($kjcopts .= " -F");
    $opts{fission} && ($kjcopts .= " --fission " . $opts{fission});
    $opts{fusion} && ($kjcopts .= " -o");
    $opts{ilppartition} && ($kjcopts .= " -A");
    $opts{linearpartition} && ($kjcopts .= " -B");
    $opts{linearreplacement} && ($kjcopts .= " -I");
    $opts{linearreplacement2} && ($kjcopts .= " -Z");
    $opts{linearreplacement3} && ($kjcopts .= " -R");
    $opts{'magic-net'} && ($kjcopts .= " -M");
    $opts{noanneal} && ($kjcopts .= " -W");
    $opts{nofieldprop} && ($kjcopts .= " -L");
    $opts{nolinearcollapse} && ($kjcopts .= " -H");
    $opts{numbers} && ($kjcopts .= " -N" . $opts{numbers});
    $opts{partition} && ($kjcopts .= " -a");
    $opts{poptopeek} && ($kjcopts .= " -P");
    $opts{'print-partitioned-source'} && ($kjcopts .= " -c");
    $opts{ptraccess} && ($kjcopts .= " -Q");
    $opts{ratematch} && ($kjcopts .= " -x");
    $opts{rawcol} && ($kjcopts .= " -q");
    $opts{'raw-uni'} && ($kjcopts .= " -U");
    $opts{removeglobals} && ($kjcopts .= " -G");
    $opts{simplesjfusion} && ($kjcopts .= " -S");
    $opts{simulatework} && ($kjcopts .= " -T");
    $opts{sjtopipe} && ($kjcopts .= " -J");
    $opts{stats} && ($kjcopts .= " -.");
    $opts{sync} && ($kjcopts .= " -k");
    $opts{unroll} && ($kjcopts .= " -u " . $opts{unroll});
    $opts{viram} && ($kjcopts .= " -V");
    $opts{cluster} && ($kjcopts .= " -cluster");
    $opts{destroyfieldarray} && ($kjcopts .= " -destroyfieldarray");
    $opts{wbs} && ($kjcopts .= " -wbs");
    $opts{spacetime} && ($kjcopts .= " -spacetime");
    return $kjcopts;
}

sub get_lib_opts
  {
    my $libopts = '';
    $opts{iterations} && ($libopts .= " -i " . $opts{iterations});
    $opts{nosched} && ($libopts .= " -nosched");
    $opts{norun} && ($libopts .= " -norun");
    $opts{printdot} && ($libopts .= " -printdot");
    $opts{printsched} && ($libopts .= " -printsched");
    return $libopts;
  }
